<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://oragekk.me/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://oragekk.me/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Oragekk&amp;apos;s Blog</title>
    <link>https://oragekk.me/</link>
    <description>上冬十二的博客</description>
    <language>zh-CN</language>
    <pubDate>Thu, 12 Oct 2023 01:58:24 GMT</pubDate>
    <lastBuildDate>Thu, 12 Oct 2023 01:58:24 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>开源软件</category>
    <category>GitHub</category>
    <category>AI</category>
    <category>Vue</category>
    <category>Flutter</category>
    <category>Dart</category>
    <category>Blog</category>
    <category>收藏</category>
    <category>Vercel</category>
    <category>python</category>
    <category>浏览器</category>
    <category>CSS</category>
    <category>JavaScript</category>
    <category>Linux</category>
    <category>前端跨平台</category>
    <category>iOS</category>
    <category>Swift</category>
    <category>About</category>
    <category>使用指南</category>
    <item>
      <title>vuepress-plugin-meting2</title>
      <link>https://oragekk.me/tutorial/OSS/meting2.html</link>
      <guid>https://oragekk.me/tutorial/OSS/meting2.html</guid>
      <source url="https://oragekk.me/rss.xml">vuepress-plugin-meting2</source>
      <description>支持vuepress2.x的音乐播放器</description>
      <category>开源软件</category>
      <category>GitHub</category>
      <pubDate>Wed, 11 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>嘿~<br>
🍰🍰🍰 播放器有了，撒花✿✿ヽ(°▽°)ノ✿🎉🎉🎉</p>
<p align="center">
   <a href="https://www.npmjs.com/package/vuepress-plugin-meting2" target="_blank"><img alt="npm" src="https://img.shields.io/npm/v/vuepress-plugin-meting2.svg"></a>&nbsp;
   <a href="https://github.com/moefyit/vuepress-plugin-meting2/stargazers" target="_blank"><img alt="GitHub stars" src="https://img.shields.io/github/stars/oragekk/vuepress-plugin-meting2"></a>&nbsp;
   <a href="https://www.npmjs.com/package/vuepress-plugin-meting2" target="_blank"><img alt="downloads" src="https://img.shields.io/npm/dt/vuepress-plugin-meting2.svg"></a>&nbsp;
   <a href="https://www.npmjs.com/package/vuepress-plugin-meting2" target="_blank"><img alt="downloads" src="https://img.shields.io/npm/dm/vuepress-plugin-meting2.svg"></a>&nbsp;
   <a href="https://github.com/oragekk/vuepress-plugin-meting2/blob/main/LICENSE" target="_blank"><img alt="GitHub license" src="https://img.shields.io/github/license/oragekk/vuepress-plugin-meting2"></a>
</p>
<p>文档👉🏻戳这里<a href="https://github.com/OrageKK/vuepress-plugin-meting2" target="_blank" rel="noopener noreferrer">文档</a></p>
<h2> 介绍</h2>
<p>借鉴了<a href="https://github.com/u2sb/vuepress-plugin-sbaudio" target="_blank" rel="noopener noreferrer">vuepress-plugin-sbaudio</a>和<a href="https://github.com/moefyit/vuepress-plugin-meting" target="_blank" rel="noopener noreferrer">vuepress-plugin-meting</a> 在此表示感谢 </p>
<p>借鉴MetingJS解析和使用APlayer作为播放组件</p>
<h2> 安装很方便</h2>

<h2> 使用也很方便</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 可作为组件引入</h3>
]]></content:encoded>
    </item>
    <item>
      <title>谷歌发布多平台应用开发神器Project IDX！PaLM 2加持</title>
      <link>https://oragekk.me/tutorial/idx-dev.html</link>
      <guid>https://oragekk.me/tutorial/idx-dev.html</guid>
      <source url="https://oragekk.me/rss.xml">谷歌发布多平台应用开发神器Project IDX！PaLM 2加持</source>
      <description>Project IDX，PaLM 2加持，代码效率翻倍</description>
      <category>AI</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>8 月 8 日，谷歌宣布推出 AI 代码编辑器 Project IDX，这是一个基于浏览器的开发环境：集成 AI、支持全栈编程语言、跨平台真机预览、一键部署，用于构建全栈网络和多平台应用程序。<br>
<img src="https://s3.bmp.ovh/imgs/2023/08/15/c778fbcb229fc714.png" alt="" loading="lazy"></p>
<p>一直以来，从 0 开始构建应用，都是一项复杂的工作。尤其是跨越手机、Web 和桌面平台的程序。</p>
<p>这是一片无尽的复杂海洋，需要把技术堆栈融合在一起，来引导、编译、测试、部署、监控应用程序。</p>
<p>多年来，谷歌一直致力于让多平台程序开发流程更快、更顺畅。</p>
<p>经过几个月的成果，团队成功做出了 Project IDX。</p>
<p>谷歌在创建 Project IDX 时并没有构建新的 IDE（集成开发环境），而是使用 VS Code 作为其项目的基础。这让团队能够专注于与 Codey 的集成，Codey 是谷歌基于 PaLM 2 的编程任务基础模型。Project IDX 支持智能代码补全，可以帮助开发者解答一般编码问题，提供与你正在处理的代码有关的特定问题（包括解释能力）的类似 ChatGPT/Bard 的聊天机器人，以及添加如 “添加注释” 等上下文代码操作的能力。<br>
目前，Project IDX 支持 Angular、Flutter、Next.js、React、Svelte 和 Vue 等框架以及 JavaScript 和 Dart 等语言，后续还将支持 Python、Go 和其他语言。</p>
<h2> Project IDX 特性</h2>
<ul>
<li><strong>随时随地快速开始</strong>：你能够在任何地方、任何设备上进行开发，具有本地开发的全部保真度。每个 Project IDX 工作空间都具有基于 Linux 的虚拟机的全部功能，配合云中托管的通用访问权限。</li>
</ul>
<figure><img src="https://s3.bmp.ovh/imgs/2023/08/15/6ce0e43362735ec2.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li><strong>一键导入或从模板创建</strong>：从 GitHub 导入现有项目，让你继续之前的进度。还可以创建新项目，预先包含流行框架的模板，包括 Angular、Flutter、Next.js、React、Svelte、Vue 和如 JavaScript、Dart 以及（即将推出的）Python、Go 等语言。IDX 还在积极努力为更多项目类型和框架添加一流支持。</li>
</ul>
<figure><img src="https://s3.bmp.ovh/imgs/2023/08/15/5fb316d7a0d02033.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li><strong>跨平台预览</strong>：应用成功发布后，需要优化设计和不同平台上的行为（像用户那样预览自己的应用），而 IDX 内置的网络预览（目前只支持 web 预览），和即将推出的完全配置的 Android 模拟器和嵌入式 iOS 模拟器，所有这些都可以直接在浏览器中使用。</li>
</ul>
<figure><img src="https://s3.bmp.ovh/imgs/2023/08/15/f0ee99149149ef4b.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li><strong>AI 助手</strong>：我们花费大量时间编写代码，而人工智能的最新进展创造了巨大的机会，可以让我们的时间变得更加高效。IDX 正在探索 Google 在 AI 领域的创新 —— 包括 为 Android Studio 中的 Studio Bot 提供支持的 Codey 和 PaLM 2 模型、Google Cloud 中的 Duet [4] 等 —— 可以帮助你不仅更快地编写代码，还可以编写更高质量的代码。</li>
</ul>
<figure><img src="https://s3.bmp.ovh/imgs/2023/08/15/c40f15f7d756b746.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p><strong>一键部署</strong>：在最后，将应用推向生产方面的一个常见痛点是部署它。通过集成 Firebase Hosting，通过几次点击就可以部署你的 Web 应用的可共享预览，或通过快速、安全和全球托管平台部署到生产环境。由于 Firebase Hosting 支持由 Cloud Functions 提供动力的动态后端，所以它非常适合像 Next.js 这样的全栈框架。</p>
</li>
<li>
<p><strong>IDX 申请链接</strong>：<a href="https://idx.dev/" target="_blank" rel="noopener noreferrer">https://idx.dev/</a></p>
</li>
</ul>
<h2> IDX 背后的 AI 模型 Codey</h2>
<p>根据介绍，IDX 由 Codey 提供支持。</p>
<p>在 Google I/O 2023 大会上，谷歌正式发布 Codey。这是一款新型 AI 驱动工具，能够编写并理解代码内容。这款新工具被外界视为谷歌对于 GitHub Copilot 的回应，属于同 Replit 结盟打造的成果。</p>
<p>Codey 基于谷歌的下一代大语言模型 PaLM 2，并采用谷歌自家产品代码及大量合法许可的源代码作为训练素材。更重要的是，Codey 仍在不断学习和发展，从谷歌服务生态系统的各个项目中持续汲取新的力量。</p>
<p>Codey 支持 20 多种编程语言，包括 Go、谷歌标准 SQL、Java、JavaScript、Python 以及 TypeScript。开发者可以通过 Visual Studio Code、JetBrains IDE、Google Shell 编辑器以及 Google Cloud 托管工作站服务的扩展来访问 Codey。开发者能够直接在 IDE 的聊天框中与该模型交流（例如 Android Studio Bot），或者在文本文件中编写注释以指示其生成相关代码。它支持各种编码任务，通过以下方式帮助开发人员更快地工作并缩小技能差距：</p>
<p>代码完成：Codey 根据提示中输入的代码上下文建议接下来的几行。</p>
<p>代码生成：小程根据开发人员的自然语言提示生成代码。</p>
<p>代码聊天：Codey 允许开发人员与机器人对话，以获得调试、文档、学习新概念和其他与代码相关问题的帮助。</p>
<p>Codey 在处理与编码相关的提示词方面接受了专门训练，谷歌还通过其他训练让该模型学会了处理关于 Google Cloud 的一般查询。</p>
<h2> 目前在用的辅助AI开发工具</h2>
<h3> - <a href="https://codegeex.cn/zh-CN" target="_blank" rel="noopener noreferrer">CodeGeeX 智能编程助手</a></h3>
<ul>
<li><strong>代码自动生成和补全</strong> CodeGeeX可以根据自然语言注释描述的功能自动生成代码，也可以根据已有的代码自动生成后续代码，补全当前行或生成后续若干行，帮助你提高编程效率。</li>
<li><strong>提供代码翻译能力</strong> 基于AI大模型对代码进行语义级翻译，支持多种编程语言互译</li>
<li><strong>自动添加注释</strong> CodeGeeX可以给代码自动添加行级注释，节省大量开发时间。没有注释的历史代码，也不再是问题。</li>
</ul>
<p>基于<a href="https://github.com/THUDM/CodeGeeX2/" target="_blank" rel="noopener noreferrer">CodeGeeX2</a>: 更强大的多语言代码生成模型<br>
是多语言代码生成模型 CodeGeeX (KDD’23) 的第二代模型。不同于一代 CodeGeeX（完全在国产华为昇腾芯片平台训练） ，CodeGeeX2 是基于 ChatGLM2 架构加入代码预训练实现，得益于 ChatGLM2 的更优性能，CodeGeeX2 在多项指标上取得性能提升（+107% &gt; CodeGeeX；仅 60 亿参数即超过 150 亿参数的 StarCoder-15B 近 10%），更多特性包括：</p>
<ul>
<li><strong>更强大的代码能力</strong>：基于 ChatGLM2-6B 基座语言模型，CodeGeeX2-6B 进一步经过了 600B 代码数据预训练，相比一代模型，在代码能力上全面提升，HumanEval-X 评测集的六种编程语言均大幅提升 (Python +57%, C++ +71%, Java +54%, JavaScript +83%, Go +56%, Rust +321%)，在 Python 上达到 35.9% 的 Pass@1 一次通过率，超越规模更大的 StarCoder-15B。</li>
<li><strong>更优秀的模型特性</strong>：继承 ChatGLM2-6B 模型特性，CodeGeeX2-6B 更好支持中英文输入，支持最大 8192 序列长度，推理速度较一代 CodeGeeX-13B 大幅提升，量化后仅需 6GB 显存即可运行，支持轻量级本地化部署。<br>
更全面的 AI 编程助手：CodeGeeX 插件（VS Code, Jetbrains）后端升级，支持超过 100 种编程语言，新增上下文补全、跨文件补全等实用功能。结合 Ask CodeGeeX 交互式 AI 编程助手，支持中英文对话解决各种编程问题，包括且不限于代码解释、代码翻译、代码纠错、文档生成等，帮助程序员更高效开发。</li>
<li><strong>更开放的协议</strong>：CodeGeeX2-6B 权重对学术研究完全开放，填写登记表申请商业使用。</li>
</ul>
<h3> - <a href="https://aws.amazon.com/cn/codewhisperer/" target="_blank" rel="noopener noreferrer">AWS CodeWhisperer</a></h3>
<p>4月18日，亚马逊云科技宣布，实时AI编程助手Amazon CodeWhisperer正式可用，同时推出的还有供所有开发人员免费使用的个人版（CodeWhisperer Individual）。CodeWhisperer帮助开发者基于注释生成代码，追踪开源参考，扫描查找漏洞。此外，还可以帮助开发者创建代码胜任如下场景，比如常规、耗时的无差别任务，或是在使用不熟悉的API或SDK时构建示例代码，亦或要正确高效地使用亚马逊云科技API操作，还有其他场景比如编写读写文件、处理图像、编写单元测试等代码。</p>
<p>Amazon CodeWhisperer 为多种编程语言提供基于人工智能（AI）的代码建议，包括 Python、Java、JavaScript、TypeScript、C#、Go、Rust、PHP、Ruby、Kotlin、C、C++、Shell 脚本、SQL 和 Scala。您可以使用来自多个 IDE 的服务，包括 JetBrains IDE（IntelliJ IDEA、PyCharm、WebStorm 和 Rider）、Visual Studio（VS）Code、AWS Cloud9、AWS Lambda 控制台、JupyterLab 和 Amazon SageMaker Studio。</p>
<h3> - <a href="https://poe.com/" target="_blank" rel="noopener noreferrer">Poe</a></h3>
<p>国内可注册，使用方便，免费，有针对代码和程序专门优化的gpt-3.5-turbo模型 <strong>Assistant</strong><br>
当然还有其他的模型，包含一些限额和付费的，你也可以创建自己的bot</p>
<ul>
<li>Claude-2-100k</li>
<li>Claude-instant-100k</li>
<li>gpt-4-32k（Powered by gpt-4-32k. Since this is a beta model, the usage limit is subject to change.）</li>
<li>Google-PaLM（Powered by Google's PaLM 2 chat-bison-001 model）</li>
</ul>
<p><em>CodeGeeX2</em>和<em>AWS CodeWhisperer</em>都提供了VSCode的插件可以使用，体验下来，<em>CodeGeeX2</em>支持的文件类型更多一点，而且反应也还算迅速，<em>AWS CodeWhisperer</em>只支持了主流开发语言，对于如dart、Vue、markdown、CSS等非主流编程语言支持效果很差，目前两者都免费，体验下来<strong>CodeGeeX2</strong>更不错一点，根据注释生成代码，给现有代码生成注释，代码翻译，纠错等功能也比较实用</p>
<h2> Some thoughts🤔</h2>
<p>看来云上开发将来一定是主流趋势，程序员再也不用因为换设备，换环境而苦恼，集成式一体开发环境，开箱即用，开发随时可中断，可恢复，不受限于设备，环境，地点影响<br>
而且集成AI代码助手，各大厂家都在发力了，微软的<strong>GitHub Copilot</strong>,亚马逊的<strong>CodeWhisperer</strong>，还有即将到来的Google的<strong>Project IDX</strong> 方便快捷的开发，将大量繁琐重复的工作交给AI来执行</p>
<h2> That's It</h2>
<blockquote>
<p>参考资料：</p>
<ul>
<li>OSC 开源社区（ID：oschina2013)</li>
<li><a href="https://developers.googleblog.com/2023/08/introducing-project-idx-experiment-to-improve-full-stack-multiplatform-app-development.html" target="_blank" rel="noopener noreferrer">https://developers.googleblog.com/2023/08/introducing-project-idx-experiment-to-improve-full-stack-multiplatform-app-development.html</a></li>
<li><a href="https://codeandhack.com/google-codey/" target="_blank" rel="noopener noreferrer">https://codeandhack.com/google-codey/</a></li>
</ul>
</blockquote>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/08/15/c778fbcb229fc714.png" type="image/png"/>
    </item>
    <item>
      <title>Vue常见优化手段</title>
      <link>https://oragekk.me/posts/Web/Vue/optimization.html</link>
      <guid>https://oragekk.me/posts/Web/Vue/optimization.html</guid>
      <source url="https://oragekk.me/rss.xml">Vue常见优化手段</source>
      <description>相关信息 永远不要过早优化，优化也有相应的代价 开发时间变长 开发成本增加 代码难以阅读 增加维护成本 何时优化，因地制宜，是一门艺术，尽量把优化的思想带入写代码的过程中 本文章的优化手段基于vue2</description>
      <category>Vue</category>
      <pubDate>Wed, 17 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>永远不要过早优化，优化也有相应的代价</p>
<ul>
<li>开发时间变长</li>
<li>开发成本增加</li>
<li>代码难以阅读</li>
<li>增加维护成本</li>
</ul>
<p>何时优化，因地制宜，是一门艺术，尽量把优化的思想带入写代码的过程中</p>
</div>
<p>本文章的优化手段基于<code>vue2</code></p>
<!-- more -->
<h2> 服务端渲染 SSR or 预渲染</h2>
<p>客户端渲染：使用 JavaScript 框架进行页面渲染<br>
服务端渲染：服务端将HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。</p>
<p><strong>优点：</strong></p>
<p>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。对客户端渲染的页面来说，简直无能为力，因为返回的HTML是一个空壳，它需要执行 JavaScript 脚本之后才会渲染真正的页面。<br>
用户将会更快速地看到完整渲染的页面</p>
<p><strong>缺点:</strong></p>
<p>为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况<br>
由于服务器增加了渲染HTML的需求，使得原本只需要输出静态资源文件的nodejs服务，新增了数据获取的IO和渲染HTML的CPU占用，<br>
服务器渲染应用程序，需要处于 Node.js server 运行环境。</p>
<h3> 如何实现？</h3>
<p>想要在服务器端渲染，我们需要做什么呢？那就是同构我们的项目，Vue.js 是构建客户端应用程序的框架，服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在服务器和客户端上运行</p>
<p>当运行在不同环境中时，我们的代码将不会完全相同，同构就是让一份代码，既可以在服务端中执行，也可以在客户端中执行，并且执行的效果都是一样的，都是完成这个html的组装，正确的显示页面。<br>
对于同构应用来说，我们必须实现客户端与服务端的路由、模型组件、数据模型的共享。</p>
<h3> 服务器端渲染注意事项</h3>
<p>为避免造成交叉请求状态污染，每个请求应该都是全新的、独立的应用程序实例。<br>
由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染(SSR)过程中被调用。<br>
通用代码不可接受像 window 或 document，这种仅浏览器可用的全局变量<br>
浏览器可能会更改的一些特殊的 HTML 结构，例如，浏览器会在</p>
<p>内部自动注入 ，然而，由于 Vue 生成的虚拟 DOM(virtual DOM) 不包含 ，所以会导致无法匹配。</p>
<h2> 使用key</h2>
<p>对于通过循环生成的列表，应给每个列表项一个稳定且唯一的key，这有利于在列表变动时，尽量少的删除、新增、改动元素</p>
<h2> 使用冻结的对象</h2>
<p>冻结的对象不会被响应化，如果对象很多，嵌套结构很深，遍历过程需要花费很多时间，如果对象不需要动态更改，可以使用冻结对象，如：商品列表等纯展示页面，并不会通过用户交互来更改</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>vue在处理过程中，如果发现对象是冻结对象，就不会去遍历对象，不会变成响应式</p>
<h4> 下面是1000000个对象的加载过程</h4>
<p><strong>vue</strong></p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/05/17/225d8b0bb0b07ab1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>冻结对象</strong></p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/05/17/3c863e0c03a3a382.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可见vue把对象深度遍历成为响应式，对于大量结构复杂的数据来说，是很耗时间的</p>
<h2> 使用函数式组件</h2>
<p>函数式组件，设置<code>functional:true</code>，函数式组件没有<code>data</code>，这以为它无状态（没有<mark>响应式数据</mark>）</p>
<p>，也没用实例（没有<code>this</code>上下文），所以组件树中不存在函数式组件，一个函数式组件就像这样</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：在 2.3.0 之前的版本中，如果一个函数式组件想要接收 prop，则 <code>props</code> 选项是必须的。在 2.3.0 或以上的版本中，你可以省略 <code>props</code> 选项，所有组件上的 attribute 都会被自动隐式解析为 prop。</p>
<p>当使用函数式组件时，该引用将会是 HTMLElement，因为他们是无状态的也是无实例的。</p>
</blockquote>
<p>在 2.5.0 及以上版本中，如果你使用了<a href="https://v2.cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener noreferrer">单文件组件</a>，那么基于模板的函数式组件可以这样声明：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>组件需要的一切都是通过 <code>context</code> 参数传递，它是一个包括如下字段的对象：</p>
<ul>
<li><code>props</code>：提供所有 prop 的对象</li>
<li><code>children</code>：VNode 子节点的数组</li>
<li><code>slots</code>：一个函数，返回了包含所有插槽的对象</li>
<li><code>scopedSlots</code>：(2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</li>
<li><code>data</code>：传递给组件的整个<a href="https://v2.cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener noreferrer">数据对象</a>，作为 <code>createElement</code> 的第二个参数传入组件</li>
<li><code>parent</code>：对父组件的引用</li>
<li><code>listeners</code>：(2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 <code>data.on</code> 的一个别名。</li>
<li><code>injections</code>：(2.3.0+) 如果使用了 <a href="https://v2.cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener noreferrer"><code>inject</code></a> 选项，则该对象包含了应当被注入的 property。</li>
</ul>
<p>在添加 <code>functional: true</code> 之后，需要更新我们的锚点标题组件的渲染函数，为其增加 <code>context</code> 参数，并将 <code>this.$slots.default</code> 更新为 <code>context.children</code>，然后将 <code>this.level</code> 更新为 <code>context.props.level</code>。</p>
<p>因为函数式组件只是函数，所以渲染开销(<strong>时间</strong>和<strong>内存</strong>)也低很多。</p>
<p>在作为包装组件时它们也同样非常有用。比如，当你需要做这些时：</p>
<ul>
<li>程序化地在多个组件中选择一个来代为渲染；</li>
<li>在将 <code>children</code>、<code>props</code>、<code>data</code> 传递给子组件之前操作它们。</li>
</ul>
<p>下面是一个 <code>smart-list</code> 组件的例子，它能根据传入 prop 的值来代为渲染更具体的组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用计算属性</h2>
<p>如果模版中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存它们</p>
<h2> 非实时绑定的表单项</h2>
<p>当使用<code>v-model</code>绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致vue发生重新渲染（<code>rerender</code>），这会带来一些性能的开销。</p>
<p>我们可以通过使用<code>lazy</code>或不使用<code>v-model</code>的方式解决该问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。</p>
<p>vue设计思想是关注的是数据而不是界面，代码的可维护性和可阅读性也很重要，js执行线程和浏览器渲染线程是互斥的，所以运行动画时执行jS线程动画会卡顿</p>
<p>如双向绑定的文本框输入的内容改变，输入abcd，会进行4次重新渲染，可以使用<code>v-model.lazy</code>,监听<code>@change</code>，不使用监听的是<code>@input</code></p>
<h2> 保持对象引用稳定</h2>
<p>在绝大部分情况下，<code>vue</code>出发<code>rerender</code>的时机是其依赖的数据发生<strong>变化</strong></p>
<p>若数据没有发生变化，哪怕给数据重新赋值了，<code>vue</code>也不会做出任何处理的</p>
<p>下面是vue判断数据<strong>没有变化</strong>的源码</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染</p>
<p>对于原始数据类型，保持其值不变即可</p>
<p>对于对象类型，保持其引用不变即可</p>
<h2> 使用v-show替代v-if</h2>
<p>对于频繁切换显示状态的元素，使用v-show可以保证虚拟的dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点及其重要</p>
<h2> 使用延迟装载defer</h2>
<p>首页白屏时间主要受到两个因素的影响：</p>
<ul>
<li>
<p>打包体积过大</p>
<p>巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个<code>&lt;div&gt;</code>，没有可显示的内容</p>
</li>
<li>
<p>需要立即渲染的内容太多</p>
</li>
</ul>
<p>JS传输完成后，浏览器开始执行JS构造页面</p>
<p>但可能一开始要渲染的组件太多，不仅JS的事件很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏loading过久</p>
<p>一个可行的办法就是延迟装载组件，让组件按照指定的先后顺序依次一个一个渲染出来</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>延迟装载是一个思路，本质上就是利用<code>requestAnimationFrame</code>事件分批渲染内容，它的具体实现多种多样</p>
</div>
<p>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的<a href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">回调函数</a>更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>
<p><code>callback</code>： 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noopener noreferrer">DOMHighResTimeStamp</a>参数，该参数与<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now" target="_blank" rel="noopener noreferrer">performance.now()</a>的返回值相同，它表示<code>requestAnimationFrame()</code> 开始去执行回调函数的时刻。</p>
<p>思路：浏览器渲染1s渲染60次，第一次渲染一部分，第二次一部分，隔开渲染,分批绘制</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用keep-alive</h2>
<p>用于缓存内部组件实例，里面有include和exclude属性，max设置最大缓存数，超过后，自动删除最久没用的。</p>
<p>受到keep-alive影响，其内部的组件都具有两个生命周期，<code>activated</code>和<code>deactivated</code> ,分别再组件激活和失活时触发，第一次<code>activated</code>是在<code>mounted</code>之后。</p>
<p>一般用在需要多个页面频繁操作的场景（导航条）</p>
<h2> 长列表优化</h2>
<p>一般用在app端下拉的时候，或者列表很长的时候，通过一个固定大小的渲染池来解决。通过滚动条等一些操作，减少页面渲染市场，有现成的库，vue-virtual-scroller</p>
<p><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener noreferrer">https://github.com/Akryum/vue-virtual-scroller</a></p>
<p>通过v-once创建低开销的静态组件，渲染一次后就缓存起来了，除非你非常留意渲染速度，不然最好不要用，因为有的开发者不知道这个属性或者看漏了，然后花费好几个小时来找为什么模板无法正确更新。</p>
<h2> 打包体积优化</h2>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>静态资源的优化使用对象存储加CDN</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<h2> 基础优化</h2>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/57/wallhaven-577og5.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Vue2响应式原理解析</title>
      <link>https://oragekk.me/posts/Web/Vue/vue2-principle.html</link>
      <guid>https://oragekk.me/posts/Web/Vue/vue2-principle.html</guid>
      <source url="https://oragekk.me/rss.xml">Vue2响应式原理解析</source>
      <description>前言 首先要知道vue2 是2013年 基于 ES5开发出来的，我们常说的重渲染就是重新运行render函数 vue2 的响应式原理是利⽤ES5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持结合发布订阅模式的⽅式来实现的。</description>
      <category>Vue</category>
      <pubDate>Tue, 16 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">前言</p>
<p>首先要知道vue2 是2013年 基于 ES5开发出来的，我们常说的重渲染就是重新运行<code>render</code>函数</p>
<p>vue2 的响应式原理是利⽤ES5 的⼀个 API ，<code>Object.defineProperty()</code>对数据进⾏劫持结合发布订阅模式的⽅式来实现的。</p>
</div>
<!-- more -->

<h2> 1. 思路</h2>
<p>带入作者的角度思考一下，想要达成响应式的特点应该是:<strong>属性更新，自动调用依赖<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">的函数</a></strong><a class="footnote-anchor" id="footnote-ref1">进行重新渲染</a></p><a class="footnote-anchor" id="footnote-ref1">
<ol>
<li>使用属性描述符<code>Object.defineProperty</code>监听属性的赋值</li>
<li>赋值完成后调用依赖该属性的函数，那如何获取依赖的函数呢？看第三点</li>
<li>由于依赖会调用属性的get方法，所以可以在get方法中<strong>收集依赖</strong></li>
<li>然后在set方法中执行这些依赖的函数，称为<strong>派发更新</strong></li>
</ol>
<p>基于以上思路的简单实现代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a><h2><a class="footnote-anchor" id="footnote-ref1"></a> 2. 原理</h2>
<p>vue2响应式原理简单来说就是vue官网上的这图片</p>
<figure><img src="https://v2.cn.vuejs.org/images/data.png" alt="原理图" tabindex="0" loading="lazy"><figcaption>原理图</figcaption></figure>
<p>通过 <code>Object.defineProperty</code> 遍历对象的每一个属性，把每一个属性变成一个 <code>getter</code> 和 <code>setter</code> 函数，读取属性的时候调用 <code>getter</code>，给属性赋值的时候就会调用 <code>setter</code>.</p>
<p>当运行 <code>render</code> 函数的时候,发现用到了响应式数据，这时候就会运行 <code>getter</code> 函数，然后 watcher（发布订阅）就会记录下来。当响应式数据发生变化的时候，就会调用 <code>setter</code> 函数，watcher 就会再记录下来这次的变化，然后通知 <code>render</code> 函数，数据发生了变化，然后就会重新运行 <code>render</code> 函数，重新生成虚拟 dom 树。</p>
<h2> 3. 深入了解</h2>
<p>我们要明白，响应式的最终目标：<strong>是当对象本身或对象属性发生变化时，会运行一些函数，最常见的就是 render 函数。不是只有 render，只要数据发生了变化后运行了一些函数，就是响应式,比如 watch。</strong></p>
<p>在具体实现上，vue 采用了几个核心部件:</p>
<ol>
<li>
<p><strong>Observer</strong></p>
</li>
<li>
<p><strong>Dep</strong></p>
</li>
<li>
<p><strong>Watcher</strong></p>
</li>
<li>
<p><strong>Scheduler</strong></p>
</li>
</ol>
<h2> 4. Observer</h2>
<p>observer 要实现的目标非常简单，就是把一个普通的对象转换成响应式的对象</p>
<p>为了实现这一点，observer 把对象的每个属性通过 <code>object.defineProperty</code> 转换为带有 <code>getter</code> 和 <code>setter</code> 的属性，这样一来，当访问或者设置属性时，vue 就会有机会做一些别的事情。</p>
<p><mark>在组件的生命周期中，这件事发生在 <code>beforeCreate</code> 之后，create 之前。</mark></p>
<p>具体实现上，他会递归遍历对象的所有属性，以完成深度的属性转换。</p>
<p>但是由于遍历只能遍历到对象的当前属性，无法监测到将来动态添加或者删除的属性，因此 vue 提供了<code>$set</code>和<code>$delete</code> 两个实例方法，但是 vue 并不提倡这样使用，我讲到 dep 的时候我再说为什么。</p>
<p>对于数组的话，vue 会更改它的隐式原型，之所以这样做是因为 vue 需要监听那些可能改变数组内容的方法。</p>
<p>数组 --&gt; vue 自定义的对象 --&gt; Array.prototype</p>
<p>总之，observer 的目标，就是要让一个对象，它属性的读取，赋值，内部数组的变化都要能够被 vue 感知到。</p>
<h3> 4.1. 手动转换响应式对象</h3>
<p>Vue提供了静态方法：<code>Vue.observable()</code> 手动将普通对象转为响应式对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2. data</h3>
<p>Vue不允许动态添加根级响应式属性，所以需要在组件实例化之前通过配置中的 <code>data</code> 字段，声明所有根级响应式属性，哪怕属性值为 <code>null</code>。由此带来的好处有：</p>
<ol>
<li>更易于维护： data对象就像组件的状态结构（schema）, 提前声明所有响应式属性，后期有助于开发者理解和修改组件逻辑。</li>
<li>消除了在依赖项跟踪系统中的一类边界情况。</li>
<li>使Vue实例能够更好的配合类型检查系统工作。</li>
</ol>
<h3> 4.3. 「动态添加或删除属性」</h3>
<p>由于Vue会在初始化实例时，对所有属性（配置里 <code>data</code> 中存在的属性）执行 getter/setter 的转化。</p>
<p>那么对于 <strong>「动态添加或删除」</strong> 的属性，Vue是无法自动检查其变化。</p>
<p>因此，Vue提供了以下方式来手动完成响应式数据。</p>
<ol>
<li>添加：<strong>「Vue.set(target, key, val)」</strong> 或 <strong>「this.$set(target, key, val)」</strong></li>
<li>删除：<strong>「Vue.delete(target, key)」</strong> 或 <strong>「this.$delete(target, key)」</strong></li>
<li>批量操作：<code>this.reactiveObj = Object.assign({}, this.reactiveObj, obj)</code></li>
</ol>
<p>举个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.4. <strong>「关于数组」</strong></h3>
<p>由于js的限制， Vue不能检测到以下数组变动：</p>
<ol>
<li>当利用索引直接改变数组项时， 例如：<code>vm.arr[idx] = newValue</code></li>
<li>当修改数组长度时 ，例如： <code>vm.arr.length = newLength</code></li>
</ol>
<p>举个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了让上述数组操作具有响应式，采用以下方法处理：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了可以通过静态方法 <code>Vue.set()</code> 和 实例方法 <code>this.$set()</code> 响应式的修改数组项的值。还可以使用数组方法 - <code>splice()</code> 。</p>
<p>因为，Vue对一些可以改变数组自身内容的操作API，如：splice()、sort()、push()、pop()、reverse()、shift()、unshift() 等进行了拦截和重写。从而在开发者使用这些API时，可以触发响应式数据，进而更新视图。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. Dep</h2>
<p>这里有两个问题没解决，就是读取属性时要做什么事，属性变化时又要做什么事，这个问题就得需要 dep 来解决</p>
<p>dep 的含义是 dependency 表示依赖的意思。</p>
<p>vue 会为响应式对象中的每一个属性，对象本身，数组本身创建一个 dep 实例，每个 dep 实例都可以做两件事情：</p>
<p>1，记录依赖：是谁在用我</p>
<p>2，派发更新：我变了，我要通知那些用我的人</p>
<p>当读取响应式对象的某一个属性时，他会进行依赖收集，有人用到了我</p>
<p>当改变某个属性时，他会派发更新，那些用我的人听好了，我变了</p>
<p>为什么尽量不要使用<code>$set</code> <code>$delete</code> ?</p>
<p>因为如果模板上没有用到值的话，你凭空加了一个数据,理论上来说应该不会重新运行<code>render</code>函数，但是上一级的dep发现自身发生改变了，所以也会导致重新运行render函数。</p>
<p>所以vue不建议使用<code>$set</code> 和<code>$delete</code>,最好提前先写上数据,哪怕先给数据赋值为 null;</p>
<h2> 6. watcher</h2>
<p>这里又出现了一个问题，就是 dep 如何知道是谁在用我呢</p>
<p>watcher 就解决了这个问题</p>
<p>当函数执行的过程中，用到了响应式数据，响应式数据是无法知道是谁在用自己的</p>
<p>所以，我们不要直接执行函数，而是把函数交给一个 watcher 的东西去执行，watch 是一个对象，每个函数执行时都应该创建一个 watcher，通过 wacher 去执行</p>
<p>watcher 会创建一个全局变量，让全局变量记录当前负责执行的 watcher 等于自己，然后再去执行函数，在函数执行的过程中，如果发生了依赖记录，那么 dep 就会把这个全局变量记录下来，表示有一个 wathcer 用到了我这个属性。</p>
<p>当 dep 进行派发更行时，他会通知之前记录的所有 watcher，我变了。</p>
<h2> 7. Scheduler</h2>
<p>现在还剩下最后一个问题啊，就是 dep 通知 watcher 之后，如果 wathcer 执行重新运行对应的函数，就有可能导致频繁运行，从而导致效率低下，试想，如果一个交给 watcher 的函数，它里面用到了属性 a,b,c,d,那么 a,b,c,d 都会记录依赖，然后这四个值都以此重新赋值，那么就会触发四次更新，这样显然不行啊，所以当 watcher 收到派发更新的通知后，实际上并不是立即执行，而是通过一个叫做 nextTick 的工具方法，把这些需要执行的 watcher 放到事件循环的微队列，nextTick 是通过 Promise then 来完成的。</p>
<p>也就是说，在响应式数据发生变化时，render 函数执行是异步的，并且在微队列中。</p>
<h2> 8. <strong>异步更新队列</strong></h2>
<blockquote>
<p>Vue侦听到数据变化，就会开启一个队列。但是组件不会立即重新渲染，而是先会缓冲在同一个事件循环中的发生的所有数据变化。此时如果同一个watcher被多次触发，只会被推入到队列中一次，这样可以**「避免不必要的计算和DOM更操作」**。<br>
在下一个事件循环”tick“中， Vue刷新队列并执行实际（已去重的）工作（更新渲染）。<br>
为此，Vue提供了异步更新的监听接口 —— <code>Vue.nextTick(callback)</code> 或 <code>this.$nextTick(callback)</code> 。当数据发生改变，异步DOM更新完成后，callback回调将被调用。开发者可以在回调中，操作更新后的DOM。</p>
</blockquote>
<p><strong>「举例1」</strong></p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例，通过一个NextTick组件的渲染，了解下 的用法。为了方便查看组件渲染时，<code>render</code>函数被调用的过程，在组件定义时，直接给出<code>render</code>函数。当点击按钮后，会在数据修改前后，使用<code>nextTick</code>工具方法。分别写入两个读取界面Dom的函数。结果会发现，第一个 <code>$nextTick</code> 回调函数获取的数据为旧数据，第二个 <code>$nextTick</code>回调函数获取的数据为新数据。</p>
<p>分析一下：</p>
<p>按钮点击后，异步队列的添加步骤是：</p>
<ol>
<li>第一个 <code>$nextTick</code> ，会将自己的回调函数（fn1）加入到当前的异步队列中。</li>
<li>修改数据后， 经过派发更新，Scheduler会将包含了watcher队列执行逻辑的函数（fn2）加入到当前的异步队列中。</li>
<li>第二个 <code>$nextTick</code>， 已将自己的回调函数（fn3）加入到当前的异步队列中。</li>
</ol>
<p>当异步队列执行时，会依次执行 fn1 ， fn2，fn3。而当fn2执行后，界面才会更新最新数据，所以fn1，fn3获取的界面数据前者为旧数据，后者为新数据。</p>
<p><strong>「举例2」</strong></p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码，当设置 <code>this.a = 'world'</code> 后，访问DOM元素内容，但完成未更新。此时，立即使用 <code>this.$nextTick()</code> 监听DOM更新，并在监听回调调用时，获取更新后的DOM内容。</p>
<p>另外， <code>this.$nextTick()</code> 其内部尝试使用原生的 <code>Promise.then</code>、<code>MutationObserve</code>、<code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout</code> 替代。并且最终返回一个<code>Promise</code>对象，所以可以使用 <code>async/await</code> 语法替代 <code>callback</code>的写法。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9. 总流程图</h2>
<figure><img src="https://s3.bmp.ovh/imgs/2023/05/16/6ebf6f55fe1cd59e.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>依赖：某个函数在运行期间用到这个属性的get方法 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/5w/wallhaven-5wmyo8.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Dart 中的并发</title>
      <link>https://oragekk.me/posts/cross-platform/Flutter/concurrency.html</link>
      <guid>https://oragekk.me/posts/cross-platform/Flutter/concurrency.html</guid>
      <source url="https://oragekk.me/rss.xml">Dart 中的并发</source>
      <description>Dart 通过 async-await、isolate 以及一些异步类型概念（例如 Future 和 Stream）支持了并发代码编程。本篇文章会对 async-await、Future 和 Stream 进行简略的介绍，而侧重点放在 isolate 的讲解上。 在应用中，所有的 Dart 代码都在 isolate 中运行。每一个 Dart 的 isolate 都有独立的运行线程，它们无法与其他 isolate 共享可变对象。在需要进行通信的场景里，isolate 会使用消息机制。很多 Dart 应用都只使用一个 isolate，也就是 main isolate。你可以创建额外的 isolate 以便在多个处理器核心上执行并行代码。</description>
      <category>Flutter</category>
      <category>Dart</category>
      <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Dart 通过 async-await、isolate 以及一些异步类型概念（例如 <code>Future</code> 和 <code>Stream</code>）支持了并发代码编程。本篇文章会对 async-await、<code>Future</code> 和 <code>Stream</code> 进行简略的介绍，而侧重点放在 isolate 的讲解上。</p>
<p>在应用中，所有的 Dart 代码都在 <strong>isolate</strong> 中运行。每一个 Dart 的 isolate 都有独立的运行线程，它们无法与其他 isolate 共享可变对象。在需要进行通信的场景里，isolate 会使用消息机制。很多 Dart 应用都只使用一个 isolate，也就是 main isolate。你可以创建额外的 isolate 以便在多个处理器核心上执行并行代码。</p>
<p>尽管 Dart 的 isolate 模型设计是基于操作系统提供的进程和线程等更为底层的原语进行设计的， Dart 虚拟机对其的使用是一个具体的实现，在本篇文章中，我们不对其具体实现展开讨论。</p>
<h2> 异步的类型和语法</h2>
<p>如果你已经对 <code>Future</code>、<code>Stream</code> 和 async-await 比较熟悉了，可以直接跳到 <a href="https://dart.cn/guides/language/concurrency#how-isolates-work" target="_blank" rel="noopener noreferrer">isolate 部分</a> 进行阅读。</p>
<h3> Future 和 Stream 类型</h3>
<p>Dart 语言和库通过 <code>Future</code> 和 <code>Stream</code> 对象，来提供会在当前调用的未来返回某些值的功能。以 JavaScript 中的 Promise 为例，在 Dart 中一个最终会返回 <code>int</code> 类型值的 promise，应当声明为 <code>Future&lt;int&gt;</code>；一个会持续返回一系列 <code>int</code> 类型值的 promise，应当声明为 <code>Stream&lt;int&gt;</code>。</p>
<p>让我们用 dart:io 来举另外一个例子。<code>File</code> 的同步方法 <a href="https://api.dart.cn/stable/dart-io/File/readAsStringSync.html" target="_blank" rel="noopener noreferrer"><code>readAsStringSync()</code></a> 会以同步调用的方式读取文件，在读取完成或者抛出错误前保持阻塞。这个会返回 <code>String</code> 类型的对象，或者抛出异常。而与它等效的异步方法 <a href="https://api.dart.cn/stable/dart-io/File/readAsString.html" target="_blank" rel="noopener noreferrer"><code>readAsString()</code></a>，会在调用时立刻返回 <code>Future&lt;String&gt;</code> 类型的对象。在未来的某一刻，<code>Future&lt;String&gt;</code> 会结束，并返回一个字符串或错误。</p>
<h4> 为什么异步的代码如此重要？</h4>
<p>It matters whether a method is synchronous or asynchronous because most apps need to do more than one thing at a time.</p>
<p>大部分应用需要在同一时刻做很多件事。例如，应用可能会发起一个 HTTP 请求，同时在请求返回前对用户的操作做出不同的界面更新。异步的代码会有助于应用保持更高的可交互状态。</p>
<p>异步场景包括调用系统 API，例如非阻塞的 I/O 操作、HTTP 请求或与浏览器交互。还有一些场景是利用 Dart 的 isolate 进行计算，或等待一个计时器的触发。这些场景要么是在不同的线程运行，要么是被系统或 Dart 运行时处理，让 Dart 代码可以在计算时同步运行。</p>
<h3> async-await 语法</h3>
<p><code>async</code> 和 <code>await</code> 关键字是用声明来定义异步函数和获取它们的结果的方式。</p>
<p>下面是一段同步代码调用文件 I/O 时阻塞的例子：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是类似的代码，但是变成了 <strong>异步调用</strong>：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>main()</code> 函数在调用 <code>_readFileAsync()</code> 前使用了 <code>await</code> 关键字，让原生代码（文件 I/O）执行的同时，其他的 Dart 代码（例如事件处理器）能继续执行。使用 <code>await</code> 后，<code>_readFileAsync()</code> 调用返回的 <code>Future&lt;String&gt;</code> 类型也转换为了 <code>String</code>。从而在将结果 <code>content</code> 赋予变量时，隐式转换为 <code>String</code> 类型。</p>
<p><strong>备注:</strong></p>
<p><code>await</code> 关键字仅在函数体前定义了 <code>async</code> 的函数中有效。</p>
<p>如下图所示，无论是在 Dart VM 还是在系统中， Dart 代码都会在 <code>readAsString()</code> 执行非 Dart 代码时暂停。在 <code>readAsString()</code> 返回值后，Dart 代码将继续执行。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/basics-await.png" alt="类似于流程图的图形显示了应用程序代码从开始到退出的执行过程，在这之间等待本地I/O" tabindex="0" loading="lazy"><figcaption>类似于流程图的图形显示了应用程序代码从开始到退出的执行过程，在这之间等待本地I/O</figcaption></figure>
<p>如果你想了解更多关于 <code>async</code>、<code>await</code> 和 <code>Future</code> 的内容，可以访问 <a href="https://dart.cn/codelabs/async-await" target="_blank" rel="noopener noreferrer">异步编程 codelab</a> 进行学习。</p>
<h2> Isolate 的工作原理</h2>
<p>现代的设备通常会使用多核 CPU。开发者为了让程序在设备上有更好的表现，有时会使用共享内容的线程来并发运行代码。然而，状态的共享可能会 <a href="https://baike.baidu.com/l/kex6qKvt" target="_blank" rel="noopener noreferrer">产生竞态条件，从而造成错误</a>，也可能会增加代码的复杂度。</p>
<p>Dart 代码并不在多个线程上运行，取而代之的是它们会在 isolate 内运行。每一个 isolate 会有自己的堆内存，从而确保 isolate 之间互相隔离，无法互相访问状态。由于这样的实现并不会共享内存，所以你也不需要担心 <a href="https://baike.baidu.com/l/My2bXiba" target="_blank" rel="noopener noreferrer">互斥锁和其他锁</a>。</p>
<p>在使用 isolate 时，你的 Dart 代码可以在同一时刻进行多个独立的任务，并且使用可用的处理器核心。 Isolate 与线程和进程近似，但是<mark>每个 isolate 都拥有独立的内存，以及运行事件循环的独立线程。</mark></p>
<p><strong>Platform note:</strong> Only the <a href="https://dart.cn/overview#platform" target="_blank" rel="noopener noreferrer">Dart Native platform</a> implements isolates. To learn more about the Dart Web platform, see the <a href="https://dart.cn/guides/language/concurrency#concurrency-on-the-web" target="_blank" rel="noopener noreferrer">Concurrency on the web</a> section.</p>
<div class="hint-container info">
<p class="hint-container-title">平台说明</p>
<p>只有<a href="https://dart.cn/overview#platform" target="_blank" rel="noopener noreferrer">Dart Native</a>平台实现了隔离器。要了解更多关于Dart网络平台的信息，请参见<a href="#%E5%9C%A8web%E7%9A%84%E5%B9%B6%E5%8F%91">Web的并发性部分</a>。</p>
</div>
<h3> 主 isolate</h3>
<p>在一般场景下，你完全无需关心 isolate。通常一个 Dart 应用会在主 isolate 下执行所有代码，如下图所示：</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/basics-main-isolate.png" alt="图中显示了一个主隔离区，它运行，对事件作出反应，然后退出" tabindex="0" loading="lazy"><figcaption>图中显示了一个主隔离区，它运行<code>main()</code>，对事件作出反应，然后退出</figcaption></figure>
<p>就算是只有一个 isolate 的应用，只要通过使用 async-await 来处理异步操作，也完全可以流畅运行。一个拥有良好性能的应用，会在快速启动后尽快进入事件循环。这使得应用可以通过异步操作快速响应对应的事件。</p>
<h3> Isolate 的生命周期</h3>
<p>如下图所示，每个 isolate 都是从运行 Dart 代码开始的，比如 <code>main()</code> 函数。执行的 Dart 代码可能会注册一些事件监听，例如处理用户操作或文件读写。当 isolate 执行的 Dart 代码结束后，如果它还需要处理已监听的事件，那么它依旧会继续被保持。处理完所有事件后，isolate 会退出。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/basics-isolate.png" alt="一个更一般的图显示，任何隔离体都会运行一些代码，选择性地对事件做出反应，然后退出" tabindex="0" loading="lazy"><figcaption>一个更一般的图显示，任何隔离体都会运行一些代码，选择性地对事件做出反应，然后退出</figcaption></figure>
<h3> 事件处理</h3>
<p>在客户端应用中，主 isolate 的事件队列内，可能会包含重绘的请求、点击的通知或者其他界面事件。例如，下图展示了包含四个事件的事件队列，队列会按照先进先出的模式处理事件。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/event-loop.png" alt="一个显示事件被逐一送入事件循环的图。" tabindex="0" loading="lazy"><figcaption>一个显示事件被逐一送入事件循环的图。</figcaption></figure>
<p>如下图所示，在 <code>main()</code> 方法执行完毕后，事件队列中的处理才开始，此时处理的是第一个重绘的事件。而后主 isolate 会处理点击事件，接着再处理另一个重绘事件。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/event-handling.png" alt="显示主隔离区逐一执行事件处理程序的图" tabindex="0" loading="lazy"><figcaption>显示主隔离区逐一执行事件处理程序的图</figcaption></figure>
<p>如果某个同步执行的操作花费了很长的处理时间，应用看起来就像是失去了响应。在下图中，处理点击事件的代码比较耗时，导致紧随其后的事件并没有及时处理。这时应用可能会产生卡顿，所有的动画都无法流畅播放。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/event-jank.png" alt="图中显示了一个执行时间过长的分接处理程序" tabindex="0" loading="lazy"><figcaption>图中显示了一个执行时间过长的分接处理程序</figcaption></figure>
<p>在一个客户端应用中，耗时过长的同步操作，通常会导致 <a href="https://flutter.cn/docs/perf/rendering-performance" target="_blank" rel="noopener noreferrer">卡顿的动画</a>。而最糟糕的是，应用界面可能完全失去响应。</p>
<h3> 后台运行对象</h3>
<p>如果你的应用受到耗时计算的影响而出现卡顿，例如 <a href="https://flutter.cn/docs/cookbook/networking/background-parsing" target="_blank" rel="noopener noreferrer">解析较大的 JSON 文件</a>，你可以考虑将耗时计算转移到单独工作的 isolate，通常我们称这样的 isolate 为 <strong>后台运行对象</strong>。下图展示了一种常用场景，你可以生成一个 isolate，它将执行耗时计算的任务，并在结束后退出。这个 isolate 工作对象退出时会把结果返回。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/isolate-bg-worker.png" alt="A figure showing a main isolate and a simple worker isolate" tabindex="0" loading="lazy"><figcaption>A figure showing a main isolate and a simple worker isolate</figcaption></figure>
<p>每个 isolate 都可以通过消息通信传递一个对象，这个对象的所有内容都需要满足可传递的条件。并非所有的对象都满足传递条件，在无法满足条件时，消息发送会失败。举个例子，如果你想发送一个 <code>List&lt;Object&gt;</code>，你需要确保这个列表中所有元素都是可被传递的。假设这个列表中有一个 <code>Socket</code>，由于它无法被传递，所以你无法发送整个列表。</p>
<p>你可以查阅 <a href="https://api.dart.cn/stable/dart-isolate/SendPort/send.html" target="_blank" rel="noopener noreferrer"><code>send()</code> 方法</a> 的文档来确定哪些类型可以进行传递。</p>
<p>Isolate 工作对象可以进行 I/O 操作、设置定时器，以及其他各种行为。它会持有自己内存空间，与主 isolate 互相隔离。这个 isolate 在阻塞时也不会对其他 isolate 造成影响。</p>
<h2> 代码示例</h2>
<p>本节将重点讨论使用 <code>Isolate</code> API 实现 isolate 的一些示例。</p>
<h3> 实现一个简单的 isolate 工作对象</h3>
<p>这些例子实现了一个主隔离器，它生成了一个简单的工作隔离器。 <a href="https://api.dart.cn/dev/dart-isolate/Isolate/run.html" target="_blank" rel="noopener noreferrer"><code>Isolate.run()</code></a> 简化了设置和管理工作者隔离区的步骤:</p>
<ol>
<li>生成（启动并创建）一个隔离器</li>
<li>在生成的隔离体上运行一个函数</li>
<li>捕获结果</li>
<li>将结果返回给主隔离区</li>
<li>工作完成后，终止隔离区的运行</li>
<li>检查、捕获并将异常和错误抛回给主隔离区</li>
</ol>
<div class="hint-container tip">
<p class="hint-container-title">备注</p>
<p>如果你使用Flutter，考虑使用<a href="https://api.flutter-io.cn/flutter/foundation/compute-constant.html" target="_blank" rel="noopener noreferrer">Flutter的<code>compute()</code>函数</a>而不是<code>Isolate.run()</code>。<code>compute</code>函数允许你的代码在<a href="https://dart.cn/overview#platform" target="_blank" rel="noopener noreferrer">本地和非本地平台</a>上工作。当只针对原生平台时，使用<code>Isolate.run()</code>以获得更符合人类工程学的的API。</p>
</div>
<h4> 在一个新的隔离区中运行一个现有的方法</h4>
<p>主 isolate 的代码如下：</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的隔离器会执行作为第一个参数传递的函数, <code>_readAndParseJson</code>:</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li><code>Isolate.run()</code> 产生了一个隔离器，即后台工作者， 而 <code>main()</code> 则在等待结果</li>
<li>生成的隔离器会执行传递给 <code>run()</code>的参数: the function <code>_readAndParseJson()</code>.</li>
<li><code>Isolate.run()</code> 从返回中获取结果，并将该值送回主隔离区，从而关闭工作隔离区。</li>
<li>工作者隔离区会将保存结果的内存<em>转移</em>到主隔离区。它并<em>不复制</em>数据。工作者隔离区会执行一个验证通道，以确保对象被允许转移。</li>
</ol>
<p><code>_readAndParseJson()</code> 是一个现有的异步函数，可以很容易地直接在主隔离区中运行。使用 <code>Isolate.run()</code> 来运行它，从而实现了并发性。工作者隔离区完全抽象了<code>_readAndParseJson()</code>的计算过程。它可以在不阻塞主隔离区的情况下完成。</p>
<p><code>Isolate.run()</code> 的结果总是一个Future，因为主隔离区的代码仍在继续运行。工作者隔离区执行的计算是同步的还是异步的，并不影响主隔离区，因为无论如何，它都是在并发地运行。</p>
<h4> Sending closures with isolates</h4>
<p>您也可以在主隔离区中直接使用函数字面或闭包，用<code>run()</code> 创建一个简单的工作隔离区。</p>
<div class="language-dart line-numbers-mode" data-ext="dart"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的完成情况与前一个例子相同。一个新的隔离器产生了，计算了一些东西，并把结果送了回来。</p>
<p>不过，现在这个隔离体发送的是一个<a href="https://dart.cn/guides/language/language-tour#anonymous-functions" target="_blank" rel="noopener noreferrer">闭包</a>。与典型的命名函数相比，闭包的限制较少，无论是在功能上还是在代码中的编写方式上。在这个例子中，<code>Isolate.run()</code>执行的是看起来像本地代码的东西，同时进行。在这个意义上，你可以把<code>run()</code>想象成一个 "并行运行 "的<a href="https://dart.cn/guides/language/language-tour#control-flow-statements" target="_blank" rel="noopener noreferrer">控制流操作符</a>。</p>
<h3> 实现一个简单的 isolate 工作对象</h3>
<p><code>Isolate.run()</code> a抽取了一些较低级别的、与隔离物相关的API，以简化隔离物管理：</p>
<ul>
<li><a href="https://api.dart.cn/stable/dart-isolate/Isolate/spawn.html" target="_blank" rel="noopener noreferrer"><code>Isolate.spawn()</code></a> and <a href="https://api.dart.cn/stable/dart-isolate/Isolate/exit.html" target="_blank" rel="noopener noreferrer"><code>Isolate.exit()</code></a></li>
<li><a href="https://api.dart.cn/stable/dart-isolate/ReceivePort-class.html" target="_blank" rel="noopener noreferrer"><code>ReceivePort</code></a> and <a href="https://api.dart.cn/stable/dart-isolate/SendPort-class.html" target="_blank" rel="noopener noreferrer"><code>SendPort</code></a></li>
</ul>
<p>您可以直接使用这些基元来对隔离区的功能进行更精细的控制。例如，<code>run()</code>在返回一条消息后就会关闭其隔离区。如果您想允许多个消息在隔离区之间传递，该怎么办呢？您可以用与<code>run()</code>的实现方式大致相同的方式来设置自己的隔离区，只是以稍微不同的方式利用<code>SendPort</code>的<a href="https://api.dart.cn/stable/dart-isolate/SendPort/send.html" target="_blank" rel="noopener noreferrer"><code>send()</code>方法</a>。</p>
<p>如果你想在 isolate 之间建立更多的通信，那么你需要使用 <code>SendPort</code> 的 <a href="https://api.dart.cn/stable/dart-isolate/SendPort/send.html" target="_blank" rel="noopener noreferrer"><code>send()</code> 方法</a>。下图展示了一种常见的场景，主 isolate 会发送请求消息至 isolate 工作对象，然后它们之间会继续进行多次通信，进行请求和回复。</p>
<figure><img src="https://dart.cn/guides/language/concurrency/images/isolate-custom-bg-worker.png" alt="图中显示了主隔离器催生隔离器，然后发送请求消息，工作隔离器用回复消息进行响应；显示了两个请求-回复循环。" tabindex="0" loading="lazy"><figcaption>图中显示了主隔离器催生隔离器，然后发送请求消息，工作隔离器用回复消息进行响应；显示了两个请求-回复循环。</figcaption></figure>
<p>下方列举的 <a href="https://github.com/dart-lang/samples/tree/master/isolates" target="_blank" rel="noopener noreferrer">isolate 示例</a> 包含了发送多次消息的使用方法：</p>
<ul>
<li><a href="https://github.com/dart-lang/samples/tree/master/isolates/bin/send_and_receive.dart" target="_blank" rel="noopener noreferrer">send_and_receive.dart</a> 展示了如何从主 isolate 发送消息至生成的 isolate，与前面的示例较为接近，不过没有使用 <code>run()</code> 方法；</li>
<li><a href="https://github.com/dart-lang/samples/tree/master/isolates/bin/long_running_isolate.dart" target="_blank" rel="noopener noreferrer">long_running_isolate.dart</a> 展示了如何生成一个长期运行、且多次发送和接收消息的 isolate。</li>
</ul>
<h2> 性能和 isolate 组</h2>
<p>当一个 isolate 调用了 <a href="https://api.dart.cn/stable/dart-isolate/Isolate/spawn.html" target="_blank" rel="noopener noreferrer"><code>Isolate.spawn()</code></a>，两个 isolate 将拥有同样的执行代码，并归入同一个 <strong>isolate 组</strong> 中。 Isolate 组会带来性能优化，例如新的 isolate 会运行由 isolate 组持有的代码，即共享代码调用。同时，<code>Isolate.exit()</code> 仅在对应的 isolate 属于同一组时有效。</p>
<p>某些场景下，你可能需要使用 <a href="https://api.dart.cn/stable/dart-isolate/Isolate/spawnUri.html" target="_blank" rel="noopener noreferrer"><code>Isolate.spawnUri()</code></a>，使用执行的 URI 生成新的 isolate，并且包含代码的副本。然而，<code>spawnUri()</code> 会比 <code>spawn()</code> 慢很多，并且新生成的 isolate 会位于新的 isolate 组。另外，当 isolate 在不同的组中，它们之间的消息传递会变得更慢。</p>
<div class="hint-container tip">
<p class="hint-container-title">备注</p>
<p><img src="https://dart.cn/assets/img/shared/flutter/icon/64.png" alt="Flutter logo" width="20" loading="lazy">Flutter 不支持 <code>Isolate.spawnUri()</code>。</p>
</div>
<h2> 在Web的并发</h2>
<p>所有的Dart应用程序都可以使用<code>async-await</code>、<code>Future</code>和<code>Stream</code>进行非阻塞、交错的计算。然而，<a href="(https://dart.cn/overview#platform)">Dart web 平台</a>并不支持隔离器。Dart网络应用程序可以使用网络工作者在后台线程中运行脚本，这与隔离程序类似。不过，<a href="https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener noreferrer">web workers</a>的功能和能力与隔离器有些不同。</p>
<p>例如，当Web工作者在线程之间发送数据时，他们会来回复制数据。不过，数据复制的速度可能非常慢，尤其是对于大的消息。隔离器也做同样的事情，但也提供了API，可以更有效地传输保存消息的内存。</p>
<p>创建Web Worker和Isolates也有不同。你只能通过声明一个单独的程序入口并单独编译来创建网络工作者。启动Web Worker类似于使用<code>Isolate.spoonUri</code>来启动一个隔离器。您也可以使用<code>Isolate.spown</code>来启动一个隔离器，这需要的资源较少，因为它<a href="https://dart.cn/guides/language/concurrency#performance-and-isolate-groups" target="_blank" rel="noopener noreferrer">重用了一些与催生隔离器相同的代码和数据</a>。Web Worker没有一个同等的API。</p>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/72/wallhaven-7286w9.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 工作原理</title>
      <link>https://oragekk.me/posts/cross-platform/Flutter/principle.html</link>
      <guid>https://oragekk.me/posts/cross-platform/Flutter/principle.html</guid>
      <source url="https://oragekk.me/rss.xml">Flutter 工作原理</source>
      <description>Flutter 工作原理 本文档解释了使 Flutter API 正常工作的 Flutter 工具包内部工作原理。由于 Flutter widget 是以积极组合的形式构建的，所以使用 Flutter 构建的用户界面含有大量 widget。为了支撑这些负载，Flutter 使用了次线性算法来布局和构建 widget，这些数据结构使树形结构优化更加高效，并且具有很多常量因子优化。通过一些额外的机制，该设计也允许开发者利用回调（用于构建用户可见的 widget）来轻松创建无限滚动列表。 积极可组合性 组合性是 Flutter 最为出众的一个特性。widget 通过组合其他 widget 的方式进行构建，并且这些 widget 自身由更基础的 widget 构建。比如，Padding 是一个 widget 而非其他 widget 的属性。因此，使用 Flutter 创建的用户界面是由多个 widget 组成的。</description>
      <category>Flutter</category>
      <pubDate>Wed, 26 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Flutter 工作原理</h1>
<p>本文档解释了使 Flutter API 正常工作的 Flutter 工具包内部工作原理。由于 Flutter widget 是以积极组合的形式构建的，所以使用 Flutter 构建的用户界面含有大量 widget。为了支撑这些负载，Flutter 使用了次线性算法来布局和构建 widget，这些数据结构使树形结构优化更加高效，并且具有很多常量因子优化。通过一些额外的机制，该设计也允许开发者利用回调（用于构建用户可见的 widget）来轻松创建无限滚动列表。</p>
<h2> 积极可组合性</h2>
<p>组合性是 Flutter 最为出众的一个特性。widget 通过组合其他 widget 的方式进行构建，并且这些 widget 自身由更基础的 widget 构建。比如，<code>Padding</code> 是一个 widget 而非其他 widget 的属性。因此，使用 Flutter 创建的用户界面是由多个 widget 组成的。</p>
<p>widget 递归构建的底层是 RenderObjectwidget，它将在渲染树的底部创建子节点。渲染树是一种存储用户界面几何信息的数据结构，该几何信息在 <strong>布局</strong> 期间计算并在 <strong>绘制</strong> 及 <strong>命中测试</strong> 期间使用。大多数 Flutter 开发者无需直接创建这些对象，而是使用 widget 来操纵渲染树。</p>
<p>为了支持 widget 层的积极可组合性， Flutter 在 widget 和树渲染层使用了大量的高效算法和优化措施，这些将在下面小节中进行介绍。</p>
<h3> 次线性布局</h3>
<p>使用大量 widget 及渲染对象并保持高性能的关键是使用高效的算法。其中最重要的是确定渲染对象几何空间（比如大小和位置）的<strong>布局</strong>算法的性能。其他一些工具包使用 O(N²) 或更糟糕的布局算法（例如，约束域中的不动点迭代）。 Flutter 的目标在于布局初始化的线性性能，及一般情况下更新现有布局的<code>次线性布局性能</code>。通常情况下，布局所花费的时间应该比对象渲染要多得多。</p>
<p>Flutter 对每一帧执行一次布局操作，且布局算法仅在一次传递中完成。 <strong>约束</strong>信息通过父节点调用每个子节点的布局方法向下传递。子节点递归执行自身的布局操作，并在它们的布局方法中返回<strong>几何</strong>信息以便将其添加到渲染树中。需要注意的是，一旦渲染对象从布局中返回，该对象将不会被再次访问 <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">，直到下一帧布局的执行。该策略将可能存在的单独测量和布局传递合并为单次传递，因此，每个渲染对象在布局过程中<strong>最多</strong>被访问<strong>两次</strong> <sup class="footnote-ref"></sup></a><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2">：一次在树的向下传递过程中，一次在树的向上传递过程中。</a></p><a class="footnote-anchor" id="footnote-ref2">
</a><p><a class="footnote-anchor" id="footnote-ref2">针对这个通用协议，Flutter 拥有多种实现。最常用的是 <code>RenderBox</code>，它以二维的笛卡尔坐标进行运算。在盒子布局中，约束是最小及最大宽高。在布局过程中，子节点通过选择这些边界内的大小来确定其几何信息。子节点在布局中返回后，由父节点确定该子节点在父坐标系中的位置 <sup class="footnote-ref"></sup></a><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3">。注意，子节点的布局并不取决于它的位置，这是因为它的位置直到它从布局中返回后才确定。因此父节点可以在无需重新计算子节点布局的情况下重新定位子节点的位置信息。</a></p><a class="footnote-anchor" id="footnote-ref3">
<p>更广泛地讲，在布局期间，从父节点流向子节点的<strong>唯一</strong>信息是约束信息，从子节点流向父节点的<strong>唯一</strong>信息是几何信息。通过这些不变量可减少布局期间所需的工作量：</p>
<ul>
<li>如果父节点对子节点使用与上一次布局中相同的约束，且子节点没有将自己的布局标记为脏，那么该节点可立即从布局中返回，以切断布局的向下传递。</li>
<li>当父节点调用子节点的布局方法时，父节点会表明它是否使用从子节点返回的大小信息。如果父节点经常不使用此信息，即使子节点重新选择了大小，父节点依旧无需重新计算其布局，这是因为父节点需要保证新的大小符合现有约束。</li>
<li><strong>严格</strong>约束是指恰好由一个有效几何满足的约束。比如，如果最小最大宽度彼此相等，且最小最大高度彼此相等，那么满足这些约束的唯一大小便是具有该宽度及高度的大小。如果父节点提供了严格约束，即便父节点在布局中使用了子节点的大小，在子节点重新计算布局时，父节点的布局也无需重新计算，这是因为子节点在没有父节点新约束的情况下无法更改其大小。</li>
<li>渲染对象可以声明仅使用父节点提供的约束来确定其几何信息。此类声明通知框架： <strong>即便约束为非严格约束，以及父节点的布局取决于子节点的大小，</strong> 该渲染对象父节点的布局在子节点的布局重新计算时仍无需重新计算，这是因为子节点在没有父节点新约束的情况下无法更改其大小。</li>
</ul>
<p>这些优化措施的效果是，当渲染对象包含脏节点时，在布局过程中，只有这些节点以及它们周围子树的有限节点才允许被访问。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref3"></a> 次线性 widget 构建</h3>
<p>Flutter 使用类似于布局的次线性算法来构建 widget。widget 构建完成后，它们将被保留了用户页面逻辑结构的 <strong>element 树</strong> 保存。 Element 树是非常有必要的，这是因为 widget 自身是<strong>不可变的</strong>，这意味着（其他情况除外），它们无法记住父（或子）节点与其他 widget 的关系。 Element 还保存了与 Stateful widget 相关联的 <strong>state</strong> 对象。</p>
<p>由于用户输入（或来自其他地方的响应），比如开发者在关联的 state 对象上调用了 <code>setState()</code> 方法，element 可能会变脏。框架维护了一个脏 element 列表，使得 <strong>构建</strong> 过程可跳过干净的 element，直接跳转到脏的 element。构建过程中，信息在 element 树中向下 <strong>单向</strong> 传递，这意味着该阶段中每个 element 最多会被访问一次。一个 element 一旦被清洗，它将不会再次变脏，这是因为通过归纳，它所有的祖先 element 也都是干净的 <sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup><a class="footnote-anchor" id="footnote-ref4">。</a></p><a class="footnote-anchor" id="footnote-ref4">
<p>由于 widget 是<strong>不可变的</strong>，因此父节点使用相同的 widget 来重新构建 element，如果 element 没有将自己标记为脏，那么该 element 可立即从构建中返回，以切断构建的向下传递。另外，element 只需比较两个 widget 所引用的对象标识来确定新 widget 与旧 widget 是否相同。开发者可利用该优化实现<strong>投影</strong>模式，即 widget 包含了被存储为成员变量、在构建过程中预先构建的子 widget</p>
<p>构建过程中，Flutter 同时使用 <code>Inheritedwidgets</code> 来避免父链的遍历。如果 widget 经常遍历它们的父链，比如确定当前的主题颜色，那么构建阶段树的深底将变为 O(N²)，由于 Flutter 的积极可组合性，其数量可能非常巨大。为了避免这些父链的遍历，框架通过在每个 element 上维护一个 <code>Inheritedwidget</code> 哈希表来向下传递 element 树中的信息。通常情况下，多个 element 引用相同的哈希表，并且该表仅在 element 引入新的 <code>Inheritedwidget</code> 时改变。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref4"></a> 线性协调</h3>
<p>不同于传统做法，Flutter 没有使用树差异比较算法。相反，框架通过使用 O(N) 算法独立地检查每个 element 的子节点来决定是否重用该 element。子列表协调算法针对以下情况进行了优化：</p>
<ul>
<li>旧的子列表为空。</li>
<li>两个列表完全相同。</li>
<li>在列表的某个位置插入或删除一个或多个 widget。</li>
<li>如果新旧列表都包含相同 key <sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup><a class="footnote-anchor" id="footnote-ref5"> 的 widget，那么这两个 widget 就会被认为是相同的。</a></li><a class="footnote-anchor" id="footnote-ref5">
</a></ul><a class="footnote-anchor" id="footnote-ref5">
<p>通常的做法是从新旧子列表的头部和尾部开始对每一个 widget 的运行时类型和 key 进行匹配，这样就可能找到在两个列表中间所有不匹配子节点的（非空）范围。然后框架将旧子列表中该范围内的子项根据它的 key 放入一个哈希表中。接下来，框架将会遍历新的子列表以寻找该范围内能够匹配哈希表中的 key 的子项。无法匹配的子项将会被丢弃并从头开始重建，匹配到的子项则使用它们新的 widget 进行重建。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref5"></a> 树结构优化</h3>
<p>重用 element 对性能非常重要，这是因为 element 拥有两份关键数据：Stateful widget 的状态对象及底层的渲染对象。当框架能够重用 element 时，用户界面的逻辑状态信息是不变的，并且可以重用之前计算的布局信息，这通常可以避免遍历整棵子树。事实上，重用 element 是非常有价值的，因为 Flutter 支持 <strong>全局</strong> 树更新，以此保留状态和布局信息。</p>
<p>开发者可通过将 <code>GlobalKey</code> 与其中一个 widget 相关联来实施全局树更新。每个全局 key 在整个应用中都是唯一的，并使用特定于线程的哈希表进行注册。在构建过程中，开发者可以使用全局 key 将 widget 移动到 element 树的任意位置。框架将不会在该位置上重新构建 element，而是检查哈希表并将现有的 element 从之前的位置移动到新的位置，从而保留整棵子树。</p>
<p>重新构建的子树中的渲染对象能够保留它们的布局信息，这是因为布局约束是渲染树从父节点传递到子节点的唯一信息。子列表发生变化后，父节点将会被标记为脏，但如果新的父节点传递给子节点的布局约束与该子节点从旧的父节点接收到的相同，那么子节点可立即从布局中返回，从而切断布局的向下传递。</p>
<p>开发者广泛使用全局 key 和全局树更新来实现 hero transition 及导航等效果。</p>
<h3> 恒定因子优化</h3>
<p>除了上述算法优化，实现积极可组合还需依赖几个重要的恒定因子优化。这些优化对于上面所讨论的主要算法是非常重要的。</p>
<ul>
<li><strong>子模型无关</strong>。与大多数使用子列表的工具包不同， Flutter 渲染树不会记住一个特定的子模型。比如，类 <code>RenderBox</code> 存在一个抽象的 <code>visitChildren()</code> 方法，而非具体的 <strong>firstChild</strong> 和 <strong>nextSibling</strong> 接口。许多子类仅支持直接作为其成员变量的单个子项，而非子项列表。比如，由于 <code>RenderPadding</code> 仅支持单个子节点，因此它拥有一个更为简单、高效的布局方法。</li>
<li><strong>视觉渲染树、widget 逻辑树</strong>。在 Flutter 中，渲染树在与设备无关的视觉坐标系中运行，这意味着即使 x 轴的读取方向是从右到左，其左侧的值依旧小于右侧。Widget 树通常在逻辑坐标中运行，这意味着拥有 <strong>开始</strong> 和 <strong>结束</strong> 值的视觉解释取决于读取方向。逻辑坐标到视觉坐标的转换是在 widget 树和渲染树之间的切换中完成的。这种方法更为高效的原因是，渲染树中的布局和绘制计算比 widget 到渲染树的切换更加频繁，并且可以避免重复的坐标转换。</li>
<li><strong>通过专门的渲染对象处理文本</strong>。大多数渲染对象都不清楚文本的复杂性。相反，文本是由专门的渲染对象 <code>RenderParagraph</code> 进行处理，它是渲染树中的一个叶子节点。开发者使用组合形式将文本并入到用户界面中，而非使用文本感知渲染对象进行子类化。该模式意味着 <code>RenderParagraph</code> 可避免文本布局在父节点提供相同布局约束下的重复计算，这是非常常见的，即使在树优化期间也是如此。</li>
<li><strong>可观察对象</strong>。 Flutter 使用模型观察及响应设计模式。显而易见，响应模式占主导地位，但 Flutter 在某些叶子节点的数据结构上使用了可观察对象。比如 <code>Animation</code> 会在值发生变化时通知观察者列表。 Flutter 将这些可观察对象从 widget 树转移到渲染树中，渲染树直接监听这些对象，并在它们改变时仅重绘管道的相关阶段。比如，更改 <code>Animation&lt;Color&gt;</code> 可能只触发绘制阶段，而非整个构建和绘制阶段。</li>
</ul>
<p>总的来说，这些优化对通过积极组合方式产生的大型树结构的性能产生了重大影响。</p>
<h3> 元素和 RenderObject 树的分离</h3>
<p>Flutter 中的<code>RenderObject</code>和<code>Element</code>（Widget）树是同构的（严格来说，<code>RenderObject</code>树是<code>Element</code>树的一个子集）。一个明显的简化是将这些树合并成一棵树。然而，在实践中，将这些树分开是有很多好处的：</p>
<ul>
<li>
<p><strong>性能</strong> 当布局发生变化时，只有布局树的相关部分需要被行走。由于组成的原因，元素树经常有许多额外的节点需要被跳过。</p>
</li>
<li>
<p><strong>明确性</strong> 更清晰的关注点分离允许小部件协议和渲染对象协议各自针对其特定需求进行专业化，简化了 API 表面，从而降低了错误的风险和测试负担。</p>
</li>
<li>
<p><strong>类型安全</strong> 呈现对象树可以更具有类型安全性，因为它可以在运行时保证子代将具有适当的类型（每个坐标系，例如，有自己的呈现对象类型）。组成部件可以不考虑布局时使用的坐标系（例如，同一个部件暴露了应用程序模型的一部分，可以在盒子布局和狭长布局中使用），因此在元素树中，验证呈现对象的类型需要在树上行走。</p>
</li>
</ul>
<h2> 无限滚动</h2>
<p>对于工具包来说，实现无限滚动列表是非常困难的。Flutter 支持基于 <strong>构造器</strong> 模式实现的简单无限滚动列表界面，其中 <code>ListView</code> 使用回调按需构建 widget，即它们只在滚动过程中才对用户可见。该功能需要 <strong>视窗感知布局</strong> 及 <strong>按需构建 widget</strong> 的支持。</p>
<h3> 视窗感知布局</h3>
<p>同 Flutter 中的大多数东西一样，可滚动的 widget 是基于组合模式构建的。可滚动 widget 的外部是一个 <code>Viewport</code>，这是一个拥有更大内部空间的盒子，这意味着它的子节点可以超出视窗口的边界并滚动到可视区域中。但是，视窗口没有 <code>RenderBox</code> 子节点，而是拥有被称为 <strong>sliver</strong>，实现了视窗感知协议的<code>RenderSliver</code> 子节点。</p>
<p>sliver 布局协议中父节点向下传递给子节点的约束信息及接收到的几何信息的结构与盒子布局相同。但约束和几何数据在两个协议之间不同。在 sliver 协议中，子节点接收到的是关于视窗口的信息，这其中包含剩余的可见空间量。它们返回的几何数据支持各种滚动链接效果，包括可折叠标题及视差。</p>
<p>不同的 sliver 以不同的方式填充视窗口中的可用空间。比如，生成线性子列表的 sliver 按顺序排列每个子节点，直到 sliver 中无任何子节点或可用空间。同理，生成二维子节点网格的 sliver 仅填充网格中的可见区域。由于它们知道还有多大的可见空间，sliver 可以生成有限的子节点，即使它们可能生成无限的子节点。</p>
<p>可组合 sliver 来创建特定的滚动布局和效果。比如，单个视窗口可以有一个折叠标题、一个线性列表和一个网格。所有这些 sliver 将按照 sliver 布局协议进行协作，只生成那些在视窗口实际可见的子节点，而不管这些子节点是否属于标题、列表或网格<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup><a class="footnote-anchor" id="footnote-ref6">。</a></p><a class="footnote-anchor" id="footnote-ref6">
</a><h3><a class="footnote-anchor" id="footnote-ref6"></a> 按需构建 widget</h3>
<p>如果 Flutter 拥有一个严格的<strong>从构建到布局，再到绘制</strong>的管道，那么前面的内容将不足以实现无限滚动列表，这是因为只有在布局阶段才能通过视窗口获取可用的空间信息。如果没有额外的机制，在布局阶段构建用于填充空间的 widget 已经太迟了。 Flutter 使用将管道的构建与布局交叉在一起的方式来解决这个问题。在布局阶段的任意时刻，<strong>只要这些 widget 是当前布局的渲染对象的子节点</strong>，框架就可以按需构建新的 widget。</p>
<p>只有严格控制构建及布局中消息传播的算法，才能实现构建和布局的交叉执行。也就是说，在构建过程中，消息只能沿构建树向下传递。当渲染对象进行布局时，布局遍历过程中并没有访问该渲染对象的子树，这意味通过子树构建的写入无法使到目前为止已进入布局计算过程的任何信息失效。无独有偶，一旦布局从渲染对象中返回，在当前布局过程中，该渲染对象将永远不会被再次访问，这意味后续布局计算生成的任何写入都不会使用于构建渲染对象的子树的信息失效。</p>
<p>此外，线性协调及树结构优化对于在滚动过程中有效更新 element，以及当 element 在视窗口边缘滚动进出视图期间修改渲染树至关重要。</p>
<h2> 人机工程 API</h2>
<p>速度只有在框架能够被有效使用时才有意义。为了引导设计更高可用性的 Flutter API， Flutter 已经在与开发者进行的广泛用户体验研究中进行了反复测试。这些研究有时证实了已有的设计决策，有时有助于引导功能的优先级，有时会改变 API 的设计方向。比如，Flutter 的 API 文档很多，用户体验的研究不仅证实了这些文档的价值，也同时强调了示例代码及说明性图表的重要性。</p>
<p>本节将要讨论 Flutter API 设计中为提高可用性所做的一些决策。</p>
<h3> 与开发者思维模式相匹配的专项 API</h3>
<p>Flutter 中 <code>widget</code>、<code>Element</code> 和 <code>RenderObject</code> 的基类节点不定义子类模型。该机制允许每个节点对适用于该节点的子模型进行定制化。</p>
<p>大多数 <code>widget</code> 对象都有一个子 <code>widget</code> 对象，因此它只暴露了一个 <code>child</code> 参数。一些 widget 支持任意数量的子节点，并暴露了一个获取子节点列表的 <code>children</code> 参数。有些 widget 无任何子节点、不保留内存且无任何参数。同样的，<code>RenderObjects</code> 暴露特定于子模型的 API。 <code>RenderImage</code> 是一个没有子节点的叶子节点。 <code>RenderPadding</code> 只持有一个子节点，因此它有一个指向单个子节点的指针存储空间。 <code>RenderFlex</code> 接受任意数量的子节点，并通过链表对其进行管理。</p>
<p>在一些罕见情况下，将使用更复杂的子类模型。渲染对象 <code>RenderTable</code> 的构造函数需要使用二维数组来存储子节点，所以该类暴露了用于控制行和列数量的 getter 及 setter 方法，还有一些可以用 x、y 轴坐标来替换单个子节点的特殊方法，可通过提供一个新的子节点数组来添加新行，并用单个数组及列的个数来替换整个子节点列表。该对象并不像大多数渲染对象那样使用链表，而是使用可索引数组来实现。</p>
<p><code>Chip</code> widget 和 <code>InputDecoration</code> 对象具有与其控制中的插槽相匹配的字段。如果一个通用子模型将强制语义定义在子列表之上，比如将第一个子节点定义为前缀，第二个子节点定义为后缀，那么专用子模型允许使用特有的命名属性。</p>
<p>这种灵活性允许树中的每个子节点以其最常用的方式操作它的角色。很少有人想要在表格中插入一个单元格，从而导致其他所有单元格被环绕；同样的，很少有人想要通过索引而不是通过引用从 flex 行中删除子项。</p>
<p><code>RenderParagraph</code> 对象是最极端的情况：它有一个完全不同类型的子节点，<code>TextSpan</code>。在 <code>RenderParagraph</code> 的边界，<code>RenderObject</code> 树会被转换为 <code>TextSpan</code> 树。</p>
<p>专门用于满足开发者期望的 API 的一切方法不仅适用于子模型。</p>
<p>专门存在一些琐碎的 widget，以便开发者在寻找问题解决方案时能够发现并使用它们。一旦知道如何使用 <code>Expanded</code> 和大小为零的 <code>SizedBox</code> 子部件，就可以轻松地为行或列添加空格，但你会发现这种模式是没有必要的，因为搜索 <code>space</code> 所找到的 <code>Spacer</code>，它是直接使用 <code>Expanded</code> 和 <code>SizedBox</code> 来达到同样的效果的。</p>
<p>同理，可以通过在构建过程中不包含 widget 子树来轻松隐藏 widget 子树。但开发者通常希望有一个 widget 来执行该操作，因此 <code>Visibility</code> 的存在便是将此模式封装在一个简单的可重用 widget 中。</p>
<h3> 明确的参数</h3>
<p>UI 框架往往拥有大量的属性，因此很少有开发者能够记住每个类的每个构造函数参数的作用。由于 Flutter 使用响应式编程范式，因此在 Flutter 中，构建方法通常会对构造函数进行多次调用。通过利用 Dart 的命名参数，Flutter 中的 API 能够使这些构建方法保持清晰易懂。</p>
<p>该模式已被扩展到任何具有多个参数（尤其是具有 boolean 类型参数）的方法，因此独立的 <code>true</code> 或 <code>false</code> 值在方法调用中总是自我描述的。此外，为避免 API 中通常由双重否定所造成的困惑， boolean 类型的参数和属性始终以肯定的形式命名（比如，使用 <code>enabled: true</code> 而非 <code>disabled: false</code>）。</p>
<h3> 参数陷阱</h3>
<p>在 Flutter 框架中被大量使用的一项技术是定义不存在错误条件的 API。这样可以避免考虑整个错误类别。</p>
<p>比如插值函数允许插值的一端或两端为空，而不是将其定义为错误：两个空值之间的插值永远为空，并且从空值或空值插值等效于对指定类型进行零模拟插值。这意味着不小心将 null 传递给插值函数的开发者不会遇到错误，而是会得到一个合理结果。</p>
<p>一个更加微妙的例子是 <code>Flex</code> 布局算法。该布局给予 flex 渲染对象的空间被它的子节点所划分。因此 flex 的大小应该是整个可用空间。在最初的设计中提供无限空间将导致失败：这意味着 flex 应该是无限大且无用的布局设置。然而，通过对 API 的改造，在为 flex 对象提供无限空间时，渲染对象会调整自身大小来满足所需子节点的大小，从而减少可能出现的错误次数。</p>
<p>该方法也可用于避免使用允许创建不符合逻辑的数据的构造函数。例如，<code>PointerDownEvent</code> 的构造函数不允许将 <code>PointerEvent</code> 的 <code>down</code> 属性设置为 <code>false</code>（这种情况是自相矛盾的）；相反，构造函数没有关于字段 <code>down</code> 的参数，且将值始终设置为 <code>true</code>。</p>
<p>一般情况下，该方法用于为输入域中的所有值定义有效的解释。最简单的例子是 <code>Color</code> 的构造函数。相对于接受四个整型参数（分别用于表示红色、绿色、蓝色和 alpha），其中任何一个都可能超出范围，它的默认构造函数仅接受一个整数值，并定义每位的含义（例如，低八位代表红色），以便任何输入都是有效的颜色值。</p>
<p>一个更复杂的例子是 <code>paintImage()</code> 函数。该函数需要 11 个参数，其中一些具有相当宽泛的输入域，但它们都经过精心设计且大部分都能够彼此相交，因此很少出现无效组合。</p>
<h3> 积极报告错误</h3>
<p>并非所有的错误都能被设计出来。对于那些遗漏的错误，在 debug 版本中，Flutter 通常会尝试尽早捕获并立即报告。它使用了大量的断言，对构造函数参数进行了详细的完整性检查，并监视其生命周期，一旦检测到不一致，它们会立即引发异常。</p>
<p>这在某些情况下是极端情况：比如，在执行单元测试时，无论测试用例正在做什么，每个 <code>RenderBox</code> 子类都会主动地检查其内部大小调整方法是否满足内部大小调整契约。这有助于捕获可能无法执行的 API 错误。</p>
<p>当异常抛出时，它们会包含尽可能多的信息。 Flutter 中的一些错误会主动探测相关的堆栈跟踪信息，以确定实际错误最可能发生的位置。其他错误则通过相关树来确定坏数据的来源。最常见的错误包含详细说明（在某些情况下会包含避免错误的示例代码），或指向其他文档的链接。</p>
<h3> 响应式</h3>
<p>可变的基于树结构的 API 受二元访问模式的影响：创建树的原始状态通常使用与后续更新完全不同的操作集。Flutter 的渲染层使用了这种范式，因为它是维护持久树的有效方法，是高效布局和绘制的关键所在。但这也意味着，与渲染层的直接交互是十分笨拙的，甚至极其容易出错。</p>
<p>Flutter 在 widget 层引入了一个使用响应式来操作底层渲染树的组合机制<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup><a class="footnote-anchor" id="footnote-ref7">。该 API 通过将树的创建和更新步骤整合到一个单一的树结构描述（构建）中，从而将树操作抽象出来，这包括：每次系统状态更新之后，开发者用于描述用户界面的新配置；框架对于新配置所需要进行的一系列树更新计算。</a></p><a class="footnote-anchor" id="footnote-ref7">
</a><h3><a class="footnote-anchor" id="footnote-ref7"></a> 插值</h3>
<p>由于 Flutter 鼓励开发者描述与当前应用状态相匹配的界面配置，因此存在一种在这些配置之间执行隐式的动画机制。</p>
<p>例如，假设界面在状态 S1 由一个圆形组成，在状态 S2 时由一个正方形组成。如果没有动画机制，状态更改将导致不和谐的界面更改。隐式动画则允许界面在几个帧的时间里由圆形平滑地过渡到正方形。</p>
<p>每个可执行隐式动画的特性都包含一个 Stateful widget，它用于记录输入的当前值，并在输入值改变时开始执行动画序列，并在指定的持续时间内从当前值转换为新值。</p>
<p>这是使用不可变对象的 <code>lerp</code>（线性插值）函数来实现的。每个状态（这里为圆形和正方形）代表一个配置中包含恰当设置（比如颜色、笔划宽度等）且知道如何绘制自己的不可变对象。在动画绘制中间步骤时，开始和结束值连同表示动画中点的 <strong>t</strong> 值一并传递给 <code>lerp</code>函数。其中 0.0 代表开始 <code>start</code>，1.0 代表结束 <code>end</code><sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup><a class="footnote-anchor" id="footnote-ref8">，并且该方法返回表示中间阶段的第三个不可变对象。</a></p><a class="footnote-anchor" id="footnote-ref8">
<p>对于从圆形到正方形的转换，<code>lerp</code> 函数将返回一个圆角正方形对象，其半径被描述为从 <strong>t</strong> 值导出的分数，使用 <code>lerp</code> 函数进行插值计算的颜色，以及使用 <code>lerp</code> 函数进行双倍插值计算的笔划宽度。该对象与圆形、正方形一样具有相同的接口实现，并且可以在请求时进行自我绘制。</p>
<p>该技术允许状态机、状态到配置的映射、动画和插值机制以及与如何绘制每一桢完全分离的特定逻辑。</p>
<p>在 Flutter 中，该机制得到了广泛应用，无论是像 <code>Color</code> 和 <code>Shape</code> 这样的基本类型，还是像 <code>Decoration</code>，<code>TextStyle</code> 或 <code>Theme</code> 这样更为复杂的类型，都是可以进行插值处理的。它们通常是由可插入组件构成的，并且插入更复杂的对象通常就像递归插入描述复杂对象的所有值一样简单。</p>
<p>一些插值对象由类层次结构定义。比如，形状由 <code>ShapeBorder</code> 接口表示，并且存在多种形状类型，包括： <code>BeveledRectangleBorder</code>、<code>BoxBorder</code>、<code>CircleBorder</code>、<code>RoundedRectangleBorder</code> 和 <code>StadiumBorder</code>。单一的 <code>lerp</code> 函数并不能了解所有可能的类型信息，因此接口定义了 <code>lerpFrom</code> 和 <code>lerpTo</code> 方法以替代静态的 <code>lerp</code> 方法。当被告知从形状 A 切换到 B 时，将首选询问 B 是否 <code>lerpFrom</code> A，如其答案为否，则询问 A 是否可以 <code>lerpTo</code> B （如两者的答案均为否，如果 <code>t</code> 的值小于 0.5 则返回 A，否则返回 B）。</p>
<p>这允许类层次结构的任意扩展，后续新增的能够在先前已知值与它们之间进行插值处理。</p>
<p>在某些情况下，插值本身不能被任何可用的类描述，并且定义一个私有类来描述中间状态。比如在 <code>CircleBorder</code> 和 <code>RoundedRectangleBorder</code> 之间进行插值时就是如此。</p>
<p>该机制的另外一个优点是：它可以处理从中间态到新值的插值。比如，在圆形到正方形过渡的中途，形状可能再次改变，导致动画需要插值到一个三角形。只要该三角形类是 <code>lerpFrom</code> 圆形到正方形的中间类，就可以无缝进行转换。</p>
</a><h2><a class="footnote-anchor" id="footnote-ref8"></a> 结论</h2>
<p>Flutter 一切都是 widget 的口号是围绕着通过组合 widget 来构建用户界面， widget 又由更为基础的 widget 构成。这种积极组合的结果是需要精心设计的算法和数据结构才能有效处理大量的 widget。通过一些额外的机制，这些数据结构还能使开发者轻松构建无限滚动列表，以便在 widget 可见时进行按需构建。</p>
<hr>
<p><strong>脚注：</strong></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>至少对于布局来说。它可能会重新审视绘制、在必要时构建辅助功能树、以及必要时的命中测试。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>现实情况当然更复杂一些。有些布局涉及内部维度及基线测量，这涉及到相关子树的额外遍历 （在最坏的情况下，使用积极缓存来降低潜在的二次性能）。但是，这些情况非常罕见。特别是在常见的 shrink-wrapping 情况下，根本不需要内部尺寸。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote3" class="footnote-item"><p>严格来说，子节点的位置不是其 RenderBox 几何体的一部分，因此无需在布局期间进行实际计算。许多渲染对象隐式地将它们的单个子节点相对于它们自身的原点定位在 0,0 处，这根本不需要进行计算或存储。一些渲染对象避免计算它们子节点的位置直到最后可能需要的时刻（比如，在绘制过程中），以避免以后没有被绘制时的计算。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote4" class="footnote-item"><p>该规则有一个例外。正如 <a href="https://flutter.cn/docs/resources/inside-flutter#building-widgets-on-demand" target="_blank" rel="noopener noreferrer">按需构建 widget</a> 中所描述的，由于布局约束的变化，一些 widget 可以被重建。如果 widget 在同一帧中因与此无关的原因被标记为脏，同时也由于它受布局约束的影响，该 widget 将会被构建两次。该次冗余构建仅限于 widget 自身，并不会影响其后代节点。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote5" class="footnote-item"><p>键是一个可选的与 widget 相关联的不透明对象，它的相等操作符用于影响协调算法。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote6" class="footnote-item"><p>对于可访问性，并在 widget 构建及在窗口显示的过程中为应用提供几毫米的时间，视窗口会在可见 widget 的前后为几百个像素构建（但不进行绘制）widget。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote7" class="footnote-item"><p>该方法首次在 Facebook 的 React 框架中得到了广泛使用。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote8" class="footnote-item"><p>实际上，允许 <strong>t</strong> 值超过 0.0-1.0 的范围，这同样适用于某些曲线。比如 elastic 缓动曲线通过短暂的过冲来表示弹跳效应。插值逻辑通常可以在适当情况下推算出起始或结束点。对于某些类型，比如在插入颜色时，<strong>t</strong> 值被有效地固定到 0.0-1.0 的范围。 <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/4v/wallhaven-4vp2x3.png" type="image/png"/>
    </item>
    <item>
      <title>如何利用GitHub Action提交URL到搜索引擎</title>
      <link>https://oragekk.me/blog/auto-push.html</link>
      <guid>https://oragekk.me/blog/auto-push.html</guid>
      <source url="https://oragekk.me/rss.xml">如何利用GitHub Action提交URL到搜索引擎</source>
      <description>相关信息 这是一个GitHub Actions的配置文件，整体思路是，获取本次更新的url （通过对比两次提交的sitemap.xml文件），所以触发条件是deploy分支有推送并修改了sitemap.xml文件，再利用python脚本进行url推送到百度、Bing、Google 脚本代码请看这里👉提交URL到搜索引擎（百度、Bing、Google）</description>
      <category>Blog</category>
      <pubDate>Mon, 17 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>这是一个<code>GitHub Actions</code>的配置文件，整体思路是，获取本次更新的url<br>
（通过对比两次提交的sitemap.xml文件），所以触发条件是deploy分支有推送并修改了<code>sitemap.xml</code>文件，再利用python脚本进行url推送到百度、Bing、Google</p>
<p>脚本代码请看这里👉<a href="/posts/Python/submit-url">提交URL到搜索引擎（百度、Bing、Google）</a></p>
</div>
<!-- more -->
<p>前些天不是写了Bing的提交脚本吗，但是每次都要自己手动跑脚本也很麻烦，但我又没有服务器，所以用上了GitHub Actions了嘛<br>
总的来说做了以下事情：</p>
<ol>
<li>提交代码并修改sitemap.xml 后触发工作流</li>
<li>比对上一次提交和本次提交的新增URL</li>
<li>将URL分别提交给百度站长、Bing、Google 供搜索引擎快速收录</li>
<li></li>
</ol>
<h2> 流程解读</h2>
<h2> 配置代码</h2>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 配置解读</h2>
<h4> 触发</h4>
<p>这个例子的触发机制如下：</p>
<ol>
<li>当有推送行为发生</li>
<li>推送分支为<code>gh-pages</code></li>
<li><code>sitemap.xml</code>文件被修改</li>
</ol>
<h4> 配置运行环境</h4>
<p>这里指定<code>ubuntu-latest</code></p>
<h4> 步骤</h4>
<ol>
<li>
<p>拉取 gh-pages 分支代码到路径<code>gh-pages</code></p>
</li>
<li>
<p>获取上一次提交SHA-1值使用如下命令，将获取到的倒数第二次git提交SHA-1值存储到环境变量<code>GITHUB_OUTPUT</code><sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">中，方便后续使用</a></p><a class="footnote-anchor" id="footnote-ref1">
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a></li><a class="footnote-anchor" id="footnote-ref1">
<li>
<p>获取上一步存储到到<code>GITHUB_OUTPUT</code>的commitid，并拉取代码代码到路径prev，ref可以是分支，tag，commitid</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>拉取main分支代码到路径main</p>
</li>
<li>
<p>安装python环境并设置缓存</p>
</li>
<li>
<p>安装python依赖库</p>
</li>
<li>
<p>运行脚本读取配置在仓库--&gt;Settings--&gt;Secrets and variables--&gt;Actions--&gt;Repository secrets中的环境变量，并把上次提交的sitemap.xml和本次提交的sitemap.xml作为命令行参数提交给python脚本</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/17/67c1bc7646f4be1d.png" alt="Repository secrets" tabindex="0" loading="lazy"><figcaption>Repository secrets</figcaption></figure>
</li>
</a></ol><a class="footnote-anchor" id="footnote-ref1">
<hr class="footnotes-sep">
</a><section class="footnotes"><a class="footnote-anchor" id="footnote-ref1">
</a><ol class="footnotes-list"><a class="footnote-anchor" id="footnote-ref1">
</a><li id="footnote1" class="footnote-item"><a class="footnote-anchor" id="footnote-ref1"></a><p><a class="footnote-anchor" id="footnote-ref1"></a><a href="https://docs.github.com/zh/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable" target="_blank" rel="noopener noreferrer">设置步骤的输出参数</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/l3/wallhaven-l3xk6q.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>素材设计</title>
      <link>https://oragekk.me/site/design.html</link>
      <guid>https://oragekk.me/site/design.html</guid>
      <source url="https://oragekk.me/rss.xml">素材设计</source>
      <description>相关信息 素材、设计相关好用的网站 工具类</description>
      <category>收藏</category>
      <pubDate>Tue, 11 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>素材、设计相关好用的网站</p>
</div>
<h2> 工具类</h2>
]]></content:encoded>
    </item>
    <item>
      <title>公开API</title>
      <link>https://oragekk.me/site/public-api.html</link>
      <guid>https://oragekk.me/site/public-api.html</guid>
      <source url="https://oragekk.me/rss.xml">公开API</source>
      <description>相关信息 免费公开的API网站，提供多种公共接口服务</description>
      <category>收藏</category>
      <pubDate>Tue, 28 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>免费公开的API网站，提供多种公共接口服务</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Vercel deploy忽略指定分支</title>
      <link>https://oragekk.me/tutorial/vercel-deploy.html</link>
      <guid>https://oragekk.me/tutorial/vercel-deploy.html</guid>
      <source url="https://oragekk.me/rss.xml">Vercel deploy忽略指定分支</source>
      <description>Vercel Ignored Build Step使用</description>
      <category>Vercel</category>
      <pubDate>Fri, 31 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[
<p>一招教你解决Vercel deploy时总是任意分支都可以触发，如果你的项目有多个分支，可以指定某一个或几个有提交时触发deploy</p>
<!-- more -->
<h2> 1. 前言</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>这不是刚把博客部署从GitHub Pages转移到了Vercel上，稍微加快了一点国内的访问速度，然后发现了一个新问题~</p>
<p>原先是推送到<code>main</code>分之，通过Github Action 工作流进行部署到<code>gh-page</code> 分支上</p>
<p>转移到Vercel之后，工作流我并没有删掉，所以流程还是一样，就导致<code>main</code>提交了---&gt;Action----&gt;<code>gh-page</code>提交</p>
<p>会触发两次Vercel的部署，当然<code>gh-page</code>是存放静态页面的分支，buid肯定是失败的。下边来解决这个问题吧</p>
</div>
<h2> 2. 步骤</h2>
<p>如图所示，打开setting-Git-Ignored Build Step</p>
<p>启用“忽略构建步骤”字段。如果命令返回“0”，则将跳过构建。但是，如果返回代码“1”或更大，则将生成新的部署。</p>
<p>我是使用系统环境变量来做的，方式有很多，看自己方便吧，在Command处输入以下脚本表示只构建main分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>系统环境变量默认是曝光的，如果不生效，在Environment Variables 中勾选</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> Automatically expose System Environment Variables</label></li>
</ul>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/31/5ae4ba35bd181dcf.png" alt="setting-Git-Ignored Build Step" tabindex="0" loading="lazy"><figcaption>setting-Git-Ignored Build Step</figcaption></figure>
<h2> 3. 使用脚本</h2>
<p>要在“忽略构建步骤”中运行 bash 脚本，您需要在该字段中设置以下内容：请注意该文件应该存在于您的存储库中。 bash 脚本示例： bash script.shbash 脚本的示例：<code>bash script.sh</code></p>
<p><strong>注意</strong> 您也可以使用 Node 脚本（例如 ）。<code>node ignore-step.js</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个示例 Ignored Build Step 脚本，其中只允许部署对生产环境所做的提交。应将环境变量“VERCEL_ENV”添加到您的项目中。</p>
<p>通过使用此命令，Vercel 将仅在“VERCEL_ENV”的值为“production”时构建部署。该变量已添加到环境变量 UI，使其可用于项目。</p>
<h2> 4. <a href="#_7-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%80%E8%A7%88%E8%A1%A8">使用环境变量</a></h2>
<p>您可以直接在 Ignored Build Step 字段中创建引用系统环境变量的命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个示例 Ignored Build Step 命令，其中只允许部署对生产环境所做的提交。</p>
<p>下面是一个示例脚本，它将有条件地构建某些分支：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个示例 Ignored Build Step 命令，其中只允许部署从分支“main”和“staging”进行的提交。</p>
<h2> 5. 使用文件夹和工作区</h2>
<p>在继续之前，请记住 Ignored Build Step 在您选择的“根目录”的同一文件夹中运行。因此，您可能需要稍微调整一下以适应您的需要。要构建仅考虑特定文件夹的新部署，您可以使用以下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“忽略构建步骤”命令的示例。如果将更改提交给“./packages/frontend/”，该命令将产生一个非空响应，从而允许构建继续进行。<br>
通过使用此命令，Vercel 将仅在目录内进行更改时构建部署。如果该文件夹是您选择的“根目录”，则可以使用：<code>packages/frontend/``./packages/frontend/</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“忽略的生成步骤”命令的示例。如果将更改提交到 “.”，则该命令将生成非空响应，从而允许继续生成。</p>
<p>您还可以访问部署中的其他文件夹以检查更改。如果您在构建前端时选择了“根目录”，并且您的应用程序必须仅在进行更改时部署，您可以使用： <code>packages/web</code> <code>../../packages/docs</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“忽略的生成步骤”命令的示例。如果将更改提交到“../../packages/docs“，该命令将产生一个非空响应，允许构建继续。</p>
<h2> 6. 在本地调试命令</h2>
<p>要在本地调试忽略的构建步骤命令，首先使用可以复制 Vercel 上可用设置的文件夹非常重要。为此，您可以应用以下步骤：</p>
<ol>
<li>使用 将存储库克隆到另一个文件夹。<code>git clone --depth=10 (...)</code></li>
<li>在终端中运行命令或脚本。</li>
<li>您可以使用 检查最后一个命令返回的退出代码。<code>echo $?</code></li>
</ol>
<h2> 7. 系统环境变量一览表</h2>
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>VERCEL</code></td>
<td style="text-align:left">指示应用已在 Vercel 上部署和运行的指示器。 例：。<code>1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CI</code></td>
<td style="text-align:left">指示代码在<a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener noreferrer">持续集成</a>环境中运行的指示器。 例：。 <strong>注意：</strong> 此变量仅在<a href="https://vercel.com/docs/concepts/deployments/configure-a-build" target="_blank" rel="noopener noreferrer">构建步骤</a>期间公开。<code>1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_ENV</code></td>
<td style="text-align:left">部署和运行应用<a href="https://vercel.com/docs/concepts/projects/environment-variables#environments" target="_blank" rel="noopener noreferrer">的环境</a>。该值可以是 、 或 。<code>production``preview``development</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_URL</code></td>
<td style="text-align:left"><a href="https://vercel.com/docs/concepts/deployments/generated-urls" target="_blank" rel="noopener noreferrer">生成的部署 URL</a> 的域名。例：。该值不包括协议方案。<code>*.vercel.app``https://</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_REGION</code></td>
<td style="text-align:left">运行应用的<a href="https://vercel.com/docs/concepts/edge-network/regions" target="_blank" rel="noopener noreferrer">区域的</a> ID。 例：。 <strong>注意：</strong> 此变量仅在<a href="https://vercel.com/docs/concepts/functions" target="_blank" rel="noopener noreferrer">无服务器函数</a>的运行时公开。<code>cdg1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_PROVIDER</code></td>
<td style="text-align:left">从中触发部署的 Git 提供程序。 例：。<code>github</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_REPO_SLUG</code></td>
<td style="text-align:left">从中触发部署的源存储库。 例：。<code>my-site</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_REPO_OWNER</code></td>
<td style="text-align:left">拥有从中触发部署的存储库的帐户。 例：。<code>acme</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_REPO_ID</code></td>
<td style="text-align:left">从中触发部署的存储库的 ID。 例：。<code>117716146</code></td>
</tr>
<tr>
<td style="text-align:left"><mark><code>VERCEL_GIT_COMMIT_REF</code></mark></td>
<td style="text-align:left">触发部署的提交的 git 分支。 例：。<code>improve-about-page</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_SHA</code></td>
<td style="text-align:left">触发部署的提交的 git <a href="https://help.github.com/articles/github-glossary/#commit" target="_blank" rel="noopener noreferrer">SHA</a>。 例：。<code>fa1eade47b73733d6312d5abfad33ce9e4068081</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_MESSAGE</code></td>
<td style="text-align:left">附加到触发部署的提交的消息。 例：。<code>Update about page</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_AUTHOR_LOGIN</code></td>
<td style="text-align:left">附加到部署项目的提交作者的用户名。 例：。<code>johndoe</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_COMMIT_AUTHOR_NAME</code></td>
<td style="text-align:left">附加到部署项目的提交的作者的名称。 例：。<code>John Doe</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_PREVIOUS_SHA</code></td>
<td style="text-align:left">项目和分支的上次成功部署的 git <a href="https://help.github.com/articles/github-glossary/#commit" target="_blank" rel="noopener noreferrer">SHA</a>。 例：。 <strong>注意：</strong> 仅当提供了<a href="https://vercel.com/docs/concepts/projects/overview#ignored-build-step" target="_blank" rel="noopener noreferrer">忽略的生成步骤</a>时，才会公开此变量。<code>fa1eade47b73733d6312d5abfad33ce9e4068080</code></td>
</tr>
<tr>
<td style="text-align:left"><code>VERCEL_GIT_PULL_REQUEST_ID</code></td>
<td style="text-align:left">触发部署的拉取请求 ID。如果在发出拉取请求之前在分支上创建了部署，则此值将为空字符串。 例：。<code>23</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/31/5ae4ba35bd181dcf.png" type="image/png"/>
    </item>
    <item>
      <title>提交URL到搜索引擎（百度、Bing、Google）</title>
      <link>https://oragekk.me/posts/Python/submit-url.html</link>
      <guid>https://oragekk.me/posts/Python/submit-url.html</guid>
      <source url="https://oragekk.me/rss.xml">提交URL到搜索引擎（百度、Bing、Google）</source>
      <description>相关信息 这是一个利用GitHub Actions自动触发的工作流进行解析更新的url并推送到搜索引擎的python脚本,除了之前介绍过的bing api之外，还增加了百度和Google的相关内容 关于GitHub Actions的介绍可以看这里👉GitHub Actions 关于GitHub Actions的配置可以看这里👉如何利用GitHub Actions推送URL到搜索引擎</description>
      <category>python</category>
      <pubDate>Mon, 17 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>这是一个利用<code>GitHub Actions</code>自动触发的工作流进行解析更新的url并推送到搜索引擎的python脚本,除了之前介绍过的bing api之外，还增加了百度和Google的相关内容</p>
<p>关于<code>GitHub Actions</code>的介绍可以看这里👉<a href="/tutorial/github/github-action">GitHub Actions</a></p>
<p>关于<code>GitHub Actions</code>的配置可以看这里👉<a href="/blog/auto-push">如何利用GitHub Actions推送URL到搜索引擎</a></p>
</div>
<!-- more -->
<h2> 流程图</h2>
<h2> 代码</h2>
<details class="hint-container details"><summary>代码</summary>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>依赖库</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 注意点</h2>
<ol>
<li>
<p>此脚本不可直接使用，需配合GitHub Action，如果想要直接使用，请替换其中的环境变量为你的内容</p>
<ul>
<li><code>os.environ["BAIDU_KEY"]</code> 百度推送token</li>
<li><code>os.environ["BING_KEY"]</code>  bing_api_key</li>
<li><code>os.environ["GOOGLE_JSON"]</code> google indexing api 认证json</li>
<li>取消 <code>从命令行参数提取sitemap</code>的步骤，直接赋值</li>
</ul>
</li>
<li>
<p>google indexing api参考这里👉<a href="https://developers.google.com/search/apis/indexing-api/v3/quickstart?hl=zh_CN" target="_blank" rel="noopener noreferrer">Indexing API 快速入门</a></p>
</li>
</ol>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/l8/wallhaven-l8z52r.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>GitHub Actions 使用介绍</title>
      <link>https://oragekk.me/tutorial/github/github-action.html</link>
      <guid>https://oragekk.me/tutorial/github/github-action.html</guid>
      <source url="https://oragekk.me/rss.xml">GitHub Actions 使用介绍</source>
      <description>GitHub Actions 是什么？ Github Actions 是 Github 官方出的持续集成服务, 挺早之前就推出了。类似的还有如微软的DevOps、GitLab CI、Circle CI、Travis CI等等。大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</description>
      <category>GitHub</category>
      <pubDate>Fri, 14 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<!-- more -->

<h2> GitHub Actions 是什么？</h2>
<p>Github Actions 是 Github 官方出的持续集成服务, 挺早之前就推出了。类似的还有如微软的DevOps、GitLab CI、Circle CI、Travis CI等等。大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p>
<p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>
<p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p>
<h2> 什么是CI/CD？</h2>
<p><a href="https://link.zhihu.com/?target=https%3A//www.redhat.com/en/topics/devops/what-is-ci-cd" target="_blank" rel="noopener noreferrer">What is CI/CD? (redhat.com)</a></p>
<p>字面意思就是持续集成Continuous Intergation/持续分发Continuous Delivery持续部署Continuous Deployment，网上有太多同质的解释都太过于晦涩，</p>
<p>提到CI/CD就离不开一个词叫流水线。流水线上每个人的工作是分工明确的，而且工程是有先后顺序，就像造一台车，先造零件，然后组装、喷涂、内饰最后还要测试。软件开发同样如此，有前期的产品设计，UI设计、单元的开发，产品的测试，优化迭代等都由不同的人负责。</p>
<p>CI/CD另一个作用就是解决团队代码中的冲突或错误。你提交的代码是否会和其他人的有冲突，如果有就不准你提交，回去再和其他哥们儿商量下。同样这一点也能解决你上传BUG代码的问题，同样禁止你。</p>
<p>如果要做的这几点那就一定需要一个中心化的工厂而且有另一个高效的团队来管理这个工厂的正常运行。CI/CD背后的提供商就是这样的工厂，而为了保证“持续”这个词，任何人都不可能24小时不睡觉帮你在工厂审核你的代码，所以自动化也是CI/CD的一个关键，自动触发机制使得以上所有的操作都是自动化完成的。所以这个工厂其实是无人化的工厂。</p>
<p>说到底CI/CD并不是一项新的技术，而是一种行业的标准，任何人在其上工作都必须遵守的标准，正因有这样的标准化流程，才能让团队的每一个人都能在自己的岗位上有效输出。说白了也就是领导团队想方设法提高员工效率榨干每一分钟的防摸鱼工具。（笑）</p>
<p>确实是这样，CI/CD的标准化工具的出现使得从开发到部署的周期大幅度缩短，再配上云开发的代码仓，那简直就是：云仓CI，法力无边。Github Action出现了。</p>
<h2> 基本概念</h2>
<p>GitHub Actions 有一些自己的术语。</p>
<p>（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p>
<p>（2）<strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p>
<p>（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p>
<p>（4）<strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p>
<h2> 关于工作流程</h2>
<p>工作流是一个可配置的自动化过程，将运行一个或多个作业。工作流由签入到存储库的YAML文件定义，并将在存储库中的事件触发时运行，或者可以手动触发，或者按照定义的计划。</p>
<p>工作流定义在存储库的 <code>.github/workflows</code> 目录中，一个存储库可以有多个工作流，每个工作流可以执行一组不同的任务。例如，您可以有一个工作流来构建和测试拉取请求，另一个工作流在每次创建发布时部署您的应用程序，还有一个工作流在每次有人打开新问题时添加标签。</p>
<p>workflow 文件的配置字段非常多，详见<a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">官方文档</a>。下面是一些基本字段。</p>
<p><strong>（1）<code>name</code></strong></p>
<p><code>name</code>字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>（2）<code>on</code></strong></p>
<p><code>on</code>字段指定触发 workflow 的条件，通常是某些事件。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码指定，<code>push</code>事件触发 workflow。</p>
<p><code>on</code>字段也可以是事件的数组。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码指定，<code>push</code>事件或<code>pull_request</code>事件都可以触发 workflow。</p>
<p>完整的事件列表，请查看<a href="https://help.github.com/en/articles/events-that-trigger-workflows" target="_blank" rel="noopener noreferrer">官方文档</a>。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p>
<p><strong>（3）<code>on.&lt;push|pull_request.&lt;tags|branches</code></strong></p>
<p>指定触发事件时，可以限定分支或标签。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码指定，只有<code>master</code>分支发生<code>push</code>事件时，才会触发 workflow。</p>
<p><strong>（4）<code>jobs.&lt;job_id.name</code></strong></p>
<p>workflow 文件的主体是<code>jobs</code>字段，表示要执行的一项或多项任务。</p>
<p><code>jobs</code>字段里面，需要写出每一项任务的<code>job_id</code>，具体名称自定义。<code>job_id</code>里面的<code>name</code>字段是任务的说明。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的<code>jobs</code>字段包含两项任务，<code>job_id</code>分别是<code>my_first_job</code>和<code>my_second_job</code>。</p>
<p><strong>（5）<code>jobs.&lt;job_id.needs</code></strong></p>
<p><code>needs</code>字段指定当前任务的依赖关系，即运行顺序。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>job1</code>必须先于<code>job2</code>完成，而<code>job3</code>等待<code>job1</code>和<code>job2</code>的完成才能运行。因此，这个 workflow 的运行顺序依次为：<code>job1</code>、<code>job2</code>、<code>job3</code>。</p>
<p><strong>（6）<code>jobs.&lt;job_id.runs-on</code></strong></p>
<p><code>runs-on</code>字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p>
<ul>
<li><code>ubuntu-latest</code>，<code>ubuntu-18.04</code>或<code>ubuntu-16.04</code></li>
<li><code>windows-latest</code>，<code>windows-2019</code>或<code>windows-2016</code></li>
<li><code>macOS-latest</code>或<code>macOS-10.14</code></li>
</ul>
<p>下面代码指定虚拟机环境为<code>ubuntu-18.04</code>。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>（7）<code>jobs.&lt;job_id.steps</code></strong></p>
<p><code>steps</code>字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p>
<ul>
<li><code>jobs.&lt;job_id.steps.name</code>：步骤名称。</li>
<li><code>jobs.&lt;job_id.steps.run</code>：该步骤运行的命令或者 action。</li>
<li><code>jobs.&lt;job_id.steps.env</code>：该步骤所需的环境变量。</li>
</ul>
<p>下面是一个完整的 workflow 文件的范例。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>steps</code>字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p>
<h3> 工作流基础</h3>
<p>工作流必须包含以下基本组件：</p>
<ol>
<li>一个或多个将触发工作流的事件。</li>
<li>一个或多个作业，每个作业都将在运行机器上执行并运行一系列一个或多个步骤。</li>
<li>每个步骤都可以运行您定义的脚本或运行操作，这是一个可重用的扩展，可以简化您的工作流程。</li>
</ol>
<h3> 工作流触发</h3>
<p>可以有多种触发方式，具体参见<a href="https://docs.github.com/zh/actions/using-workflows/triggering-a-workflow" target="_blank" rel="noopener noreferrer">官方文档</a>,下面以我的一个工作流举例讲解触发事件</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子的触发机制如下：</p>
<ol>
<li>当有推送行为发生</li>
<li>推送分支为<code>gh-pages</code></li>
<li><code>sitemap.xml</code>文件被修改</li>
<li>每天 UTC 23:00触发<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></li><a class="footnote-anchor" id="footnote-ref1">
<li>push下的分支和文件要同时触发才会使工作流运行</li>
</a></ol><a class="footnote-anchor" id="footnote-ref1">
<div class="hint-container danger">
<p class="hint-container-title">注意!!!</p>
<p>虽然官方文档未提及需要把<code>.github/workflows</code>目录下的工作流文件存储于指定触发分支下，但我实际操作中发现，如我设置的触发分支为<code>gh-pages</code>但假如我的.yaml文件在<code>main</code>分支下不在<code>gh-pages</code>根目录的<code>.github/workflows</code>文件夹下，实际并不会触发。</p>
</div>
</a><h2><a class="footnote-anchor" id="footnote-ref1"></a> 实例</h2>
<hr>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>这是一个<code>GitHub Actions</code>的配置文件，整体思路是，获取本次更新的url<br>
（通过对比两次提交的sitemap.xml文件），所以触发条件是deploy分支有推送并修改了<code>sitemap.xml</code>文件，再利用python脚本进行url推送到百度、Bing、Google</p>
<p>脚本代码请看这里👉<a href="/posts/Python/submit-url">提交URL到搜索引擎（百度、Bing、Google）</a></p>
</div>
<!-- more -->
<p>前些天不是写了Bing的提交脚本吗，但是每次都要自己手动跑脚本也很麻烦，但我又没有服务器，所以用上了GitHub Actions了嘛<br>
总的来说做了以下事情：</p>
<ol>
<li>提交代码并修改sitemap.xml 后触发工作流</li>
<li>比对上一次提交和本次提交的新增URL</li>
<li>将URL分别提交给百度站长、Bing、Google 供搜索引擎快速收录</li>
<li></li>
</ol>
<h2> 流程解读</h2>
<h2> 配置代码</h2>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 配置解读</h2>
<h4> 触发</h4>
<p>这个例子的触发机制如下：</p>
<ol>
<li>当有推送行为发生</li>
<li>推送分支为<code>gh-pages</code></li>
<li><code>sitemap.xml</code>文件被修改</li>
</ol>
<h4> 配置运行环境</h4>
<p>这里指定<code>ubuntu-latest</code></p>
<h4> 步骤</h4>
<ol>
<li>
<p>拉取 gh-pages 分支代码到路径<code>gh-pages</code></p>
</li>
<li>
<p>获取上一次提交SHA-1值使用如下命令，将获取到的倒数第二次git提交SHA-1值存储到环境变量<code>GITHUB_OUTPUT</code><sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup><a class="footnote-anchor" id="footnote-ref2">中，方便后续使用</a></p><a class="footnote-anchor" id="footnote-ref2">
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a></li><a class="footnote-anchor" id="footnote-ref2">
<li>
<p>获取上一步存储到到<code>GITHUB_OUTPUT</code>的commitid，并拉取代码代码到路径prev，ref可以是分支，tag，commitid</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>拉取main分支代码到路径main</p>
</li>
<li>
<p>安装python环境并设置缓存</p>
</li>
<li>
<p>安装python依赖库</p>
</li>
<li>
<p>运行脚本读取配置在仓库--&gt;Settings--&gt;Secrets and variables--&gt;Actions--&gt;Repository secrets中的环境变量，并把上次提交的sitemap.xml和本次提交的sitemap.xml作为命令行参数提交给python脚本</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/17/67c1bc7646f4be1d.png" alt="Repository secrets" tabindex="0" loading="lazy"><figcaption>Repository secrets</figcaption></figure>
</li>
</a></ol><a class="footnote-anchor" id="footnote-ref2">
<hr class="footnotes-sep">
</a><section class="footnotes"><a class="footnote-anchor" id="footnote-ref2">
</a><ol class="footnotes-list"><a class="footnote-anchor" id="footnote-ref2">
</a><li id="footnote1" class="footnote-item"><a class="footnote-anchor" id="footnote-ref2"></a><p><a class="footnote-anchor" id="footnote-ref2">可以使用 </a><a href="https://crontab.guru/" target="_blank" rel="noopener noreferrer">crontab guru</a> 帮助生成 cron 语法并确认其运行时间。 为了帮助入门，还提供了 <a href="https://crontab.guru/examples.html" target="_blank" rel="noopener noreferrer">crontab guru 示例</a>列表。计划工作流程的通知将发送给最后修改工作流程文件中的 cron 语法的用户。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/actions/monitoring-and-troubleshooting-workflows/notifications-for-workflow-runs" target="_blank" rel="noopener noreferrer">工作流程运行通知</a>”。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p><a href="https://docs.github.com/zh/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable" target="_blank" rel="noopener noreferrer">设置步骤的输出参数</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/j3/wallhaven-j3zvvp.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>前端-Q&amp;A</title>
      <link>https://oragekk.me/posts/Web/Q_A.html</link>
      <guid>https://oragekk.me/posts/Web/Q_A.html</guid>
      <source url="https://oragekk.me/rss.xml">前端-Q&amp;A</source>
      <description>前端-Q&amp;amp;A 浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</description>
      <category>浏览器</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 前端-Q&amp;A</h1>
<h2> 浏览器是如何渲染页面的？</h2>
<p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p>
<p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p>
<!-- more -->
<hr>
<p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p>
<p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p>
<p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p>
<hr>
<p>渲染的第一步是<strong>解析 HTML</strong>。</p>
<p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p>
<p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p>
<p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p>
<p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p>
<hr>
<p>渲染的下一步是<strong>样式计算</strong>。</p>
<p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p>
<p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p>
<p>这一步完成后，会得到一棵带有样式的 DOM 树。</p>
<hr>
<p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p>
<p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p>
<p>大部分时候，DOM 树和布局树并非一一对应。</p>
<p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p>
<hr>
<p>下一步是<strong>分层</strong></p>
<p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p>
<p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p>
<p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p>
<hr>
<p>再下一步是<strong>绘制</strong></p>
<p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p>
<hr>
<p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p>
<p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p>
<p>它会从线程池中拿取多个线程来完成分块工作。</p>
<hr>
<p>分块完成后，进入<strong>光栅化</strong>阶段。</p>
<p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p>
<p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p>
<p>光栅化的结果，就是一块一块的位图</p>
<hr>
<p>最后一个阶段就是<strong>画</strong>了</p>
<p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p>
<p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p>
<p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p>
<p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p>
<h2> 什么是 reflow？</h2>
<p>reflow 的本质就是重新计算 layout 树。</p>
<p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p>
<p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p>
<p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p>
<p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p>
<h2> 什么是 repaint？</h2>
<p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p>
<p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p>
<p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p>
<h2> 为什么 transform 的效率高？</h2>
<p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p>
<p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>
<h2> 阐述一下 JS 的事件循环</h2>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，<mark>微队列的任务一定具有最高的优先级，必须优先调度执行</mark>。</p>
<h2> JS 中的计时器能做到精确计时吗？为什么？</h2>
<p>不行，因为：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器的事件循环</title>
      <link>https://oragekk.me/posts/Web/Browser/event-loop.html</link>
      <guid>https://oragekk.me/posts/Web/Browser/event-loop.html</guid>
      <source url="https://oragekk.me/rss.xml">浏览器的事件循环</source>
      <description>浏览器的进程模型 何为进程？ 程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</description>
      <category>浏览器</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 浏览器的进程模型</h2>
<h3> 何为进程？</h3>
<p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p>
<!-- more -->
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/9e81b88e42fe104f.png" alt="何为进程" tabindex="0" loading="lazy"><figcaption>何为进程</figcaption></figure>
<p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>
<h3> 何为线程？</h3>
<p>有了进程后，就可以运行程序的代码了。</p>
<p>运行代码的「人」称之为「线程」。</p>
<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>
<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/5badc062636572ac.png" alt="何为线程" tabindex="0" loading="lazy"><figcaption>何为线程</figcaption></figure>
<h3> 浏览器有哪些进程和线程？</h3>
<p><strong>浏览器是一个多进程多线程的应用程序</strong></p>
<p>浏览器内部工作极其复杂。</p>
<p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/8a913a1d57ab9ad1.png" alt="浏览器有哪些进程和线程" tabindex="0" loading="lazy"><figcaption>浏览器有哪些进程和线程</figcaption></figure>
<blockquote>
<p>可以在浏览器的任务管理器中查看当前的所有进程</p>
</blockquote>
<p>其中，最主要的进程有：</p>
<ol>
<li>
<p>浏览器进程</p>
<p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p>
</li>
<li>
<p>网络进程</p>
<p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p>
</li>
<li>
<p><strong>渲染进程</strong>（本节课重点讲解的进程）</p>
<p>渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p>
<p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p>
<blockquote>
<p>将来该默认模式可能会有所改变，有兴趣的同学可参见<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability" target="_blank" rel="noopener noreferrer">chrome官方说明文档</a></p>
</blockquote>
</li>
</ol>
<h2> 渲染主线程是如何工作的？</h2>
<p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>
<ul>
<li>解析 HTML</li>
<li>解析 CSS</li>
<li>计算样式</li>
<li>布局</li>
<li>处理图层</li>
<li>每秒把页面画 60 次</li>
<li>执行全局 JS 代码</li>
<li>执行事件处理函数</li>
<li>执行计时器的回调函数</li>
<li>......</li>
</ul>
<blockquote>
<p>思考题：为什么渲染进程不适用多个线程来处理这些事情？</p>
</blockquote>
<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p>
<p>比如：</p>
<ul>
<li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li>
<li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li>
<li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li>
<li>......</li>
</ul>
<p>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/3be6637939475013.png" alt="排队" tabindex="0" loading="lazy"><figcaption>排队</figcaption></figure>
<ol>
<li>在最开始的时候，渲染主线程会进入一个无限循环</li>
<li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li>
<li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li>
</ol>
<p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>
<p><strong>整个过程，被称之为事件循环（消息循环）</strong></p>
<h2> 若干解释</h2>
<h3> 何为异步？</h3>
<p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>
<ul>
<li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li>
<li>网络通信完成后需要执行的任务 -- <code>XHR</code>、<code>Fetch</code></li>
<li>用户操作后需要执行的任务 -- <code>addEventListener</code></li>
</ul>
<p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/aa0ac442c15daaf3.png" alt="image-20220810104344296" tabindex="0" loading="lazy"><figcaption>image-20220810104344296</figcaption></figure>
<p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p>
<p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/04/11/4f53367a24118e95.png" alt="异步" tabindex="0" loading="lazy"><figcaption>异步</figcaption></figure>
<p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p>
<blockquote>
<p>面试题：如何理解 JS 的异步？</p>
<p>参考答案：</p>
<p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>
<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>
<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>
<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>
<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>
</blockquote>
<h3> JS为何会阻碍渲染？</h3>
<p>先看代码</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>点击按钮后，会发生什么呢？</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>三秒之后h1文字变更，主线程被阻塞</p>
</div>
<h3> 任务有优先级吗？</h3>
<p>任务没有优先级，在消息队列中先进先出</p>
<p>但<strong>消息队列是有优先级的</strong></p>
<p>根据 W3C 的最新解释:</p>
<ul>
<li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>
在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li>
<li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br>
<a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener noreferrer">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li>
</ul>
<blockquote>
<p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p>
</blockquote>
<p>在目前 chrome 的实现中，至少包含了下面的队列：</p>
<ul>
<li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li>
<li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li>
<li>微队列：用户存放需要最快执行的任务，优先级「最高」</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p>
<p>例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></div>
<blockquote>
<p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p>
</blockquote>
<blockquote>
<p>面试题：阐述一下 JS 的事件循环</p>
<p>参考答案：</p>
<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p>
<p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p>
<p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p>
<p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，<mark>微队列的任务一定具有最高的优先级，必须优先调度执行</mark>。</p>
</blockquote>
<blockquote>
<p>面试题：JS 中的计时器能做到精确计时吗？为什么？</p>
<p>参考答案：</p>
<p>不行，因为：</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li>
<li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
</blockquote>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/04/11/9e81b88e42fe104f.png" type="image/png"/>
    </item>
    <item>
      <title>CSS 属性计算过程</title>
      <link>https://oragekk.me/posts/Web/CSS/calculation.html</link>
      <guid>https://oragekk.me/posts/Web/CSS/calculation.html</guid>
      <source url="https://oragekk.me/rss.xml">CSS 属性计算过程</source>
      <description>CSS 属性计算过程 你是否了解 CSS 的属性计算过程呢？ 有的同学可能会讲，CSS属性我倒是知道，例如： p{ color : red; }</description>
      <category>CSS</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> CSS 属性计算过程</h1>
<p>你是否了解 CSS 的属性计算过程呢？</p>
<p>有的同学可能会讲，CSS属性我倒是知道，例如：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 CSS 代码中，p 是元素选择器，color 就是其中的一个 CSS 属性。</p>
<p>但是要说 CSS 属性的计算过程，还真的不是很清楚。</p>
<p>没关系，通过此篇文章，能够让你彻底明白什么是 CSS 属性的计算流程。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;">
<p>首先，不知道你有没有考虑过这样的一个问题，假设在 HTML 中有这么一段代码：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1 标题呈现出来的外观是如下：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060724.png" alt="image-20220813140724136" style="zoom:50%;">
<p>目前我们没有设置该 h1 的任何样式，但是却能看到该 h1 有一定的默认样式，例如有默认的字体大小、默认的颜色。</p>
<p>那么问题来了，我们这个 h1 元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014216.png" alt="image-20220815094215982" style="zoom:30%;">
<p>答案是**该元素上面会有 CSS 所有的属性。**你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png" alt="image-20220813141516153" tabindex="0" loading="lazy"><figcaption>image-20220813141516153</figcaption></figure>
<p>换句话说，<strong>我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式</strong>。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS 样式时，往往只会书写必要的部分，例如前面的：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color 属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS 样式，只不过你没有书写的样式，<strong>大概率可能</strong>会使用其默认值。例如上图中 h1 一个样式都没有设置，全部都用的默认值。</p>
<p>但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014459.png" alt="image-20220815094458940" style="zoom:25%;">
<p>嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。</p>
<p>总的来讲，属性值的计算过程，分为如下这么 <em>4</em> 个步骤：</p>
<ul>
<li>确定声明值</li>
<li>层叠冲突</li>
<li>使用继承</li>
<li>使用默认值</li>
</ul>
<h2> 确定声明值</h2>
<p>首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS 样式，例如前面的：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们声明了 p 元素为红色，那么就会应用此属性设置。</p>
<p>当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-063500.png" alt="image-20220813143500066" tabindex="0" loading="lazy"><figcaption>image-20220813143500066</figcaption></figure>
<p>在上面的示例中，作者样式表中设置了 color 属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如 display、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end 等属性对应的值。</p>
<p>这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。</p>
<h2> 层叠冲突</h2>
<p>在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。</p>
<p>此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：</p>
<ul>
<li>比较源的重要性</li>
<li>比较优先级</li>
<li>比较次序</li>
</ul>
<p>来来来，我们一步一步来看。</p>
<h3> 比较源的重要性</h3>
<p>当不同的 CSS 样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。</p>
<p>那么问题来了，咱们的样式表的源究竟有几种呢？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-100047.png" alt="image-20220823180047075" style="zoom:40%;">
<p>整体来讲有三种来源：</p>
<ul>
<li>浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称<strong>用户代理样式</strong>。</li>
<li>网页的作者可以定义文档的样式，这是最常见的样式表，称之为<strong>页面作者样式</strong>。</li>
<li>浏览器的用户，可以使用自定义样式表定制使用体验，称之为<strong>用户样式</strong>。</li>
</ul>
<p>对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt; 用户代理样式</p>
<p>更详细的来源重要性比较，可以参阅 <em>MDN</em>：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade</a></em></p>
<p>我们来看一个示例。</p>
<p>例如现在有<strong>页面作者样式表</strong>和<strong>用户代理样式表</strong>中存在属性的冲突，那么会以作者样式表优先。</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-064222.png" alt="image-20220813144222152" tabindex="0" loading="lazy"><figcaption>image-20220813144222152</figcaption></figure>
<p>可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。</p>
<h3> 比较优先级</h3>
<p>那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。</p>
<p>例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，同属于<strong>页面作者样式</strong>，源的重要性是相同的，此时会以选择器的权重来比较重要性。</p>
<p>很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 <em>50px</em>。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-071546.png" alt="image-20210916151546500" style="zoom: 40%;">
<p>可以看到，落败的作者样式在 <em>Elements&gt;Styles</em> 中会被划掉。</p>
<p>有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：<em><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity</a></em></p>
<h3> 比较次序</h3>
<p>经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。</p>
<p>此时就会进入第三个步骤，比较样式声明的次序。</p>
<p>举个例子：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，同样都是<strong>页面作者样式</strong>，<strong>选择器的权重也相同</strong>，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用 <em>20px</em> 这一条属性值。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-103928.png" alt="image-20220823183928330" tabindex="0" loading="lazy"><figcaption>image-20220823183928330</figcaption></figure>
<p>至此，样式声明中存在冲突的所有情况，就全部被解决了。</p>
<h2> 使用继承</h2>
<p>层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。</p>
<p>那么如果没有声明的属性呢？此时就使用默认值么？</p>
<p><em>No、No、No</em>，别急，此时还有第三个步骤，那就是使用继承而来的值。</p>
<p>例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p 元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p 元素从最近的 div 身上继承到了 color 属性的值。</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065102.png" alt="image-20220813145102293" tabindex="0" loading="lazy"><figcaption>image-20220813145102293</figcaption></figure>
<p>这里有两个点需要同学们注意一下。</p>
<p>首先第一个是我强调了是<strong>最近的</strong> div 元素，看下面的例子：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065653.png" alt="image-20220813145652726" tabindex="0" loading="lazy"><figcaption>image-20220813145652726</figcaption></figure>
<p>因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到 color 对应的值，因此这里是<strong>谁近就听谁</strong>的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到 p 元素。</p>
<p>第二个就是哪些属性能够继承？</p>
<p>关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以 text-align 为例，如下图所示：</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070148.png" alt="image-20220813150147885" tabindex="0" loading="lazy"><figcaption>image-20220813150147885</figcaption></figure>
<h2> 使用默认值</h2>
<p>好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。</p>
<p>如下图所示：</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070825.png" alt="image-20220813150824752" tabindex="0" loading="lazy"><figcaption>image-20220813150824752</figcaption></figure>
<p>前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的 CSS 属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。</p>
<p>好了，这就是关于 CSS 属性计算过程的所有知识了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;">
<h2> 一道面试题</h2>
<p>好了，学习了今天的内容，让我来用一道面试题测试测试大家的理解程度。</p>
<p>下面的代码，最终渲染出来的效果，a 元素是什么颜色？p 元素又是什么颜色？</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大家能说出为什么会呈现这样的结果么？</p>
<p>解答如下：</p>
<figure><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-071941.png" alt="image-20220813151941113" tabindex="0" loading="lazy"><figcaption>image-20220813151941113</figcaption></figure>
<p>实际上原因很简单，因为 a 元素在用户代理样式表中已经设置了 color 属性对应的值，因此会应用此声明值。而在 p 元素中无论是作者样式表还是用户代理样式表，都没有对此属性进行声明，然而由于 color 属性是可以继承的，因此最终 p 元素的 color 属性值通过继承来自于父元素。</p>
<p>你答对了么？-）</p>
<hr>
<p>-<em>EOF</em>-</p>
]]></content:encoded>
      <enclosure url="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png" type="image/png"/>
    </item>
    <item>
      <title>你不知道的 CSS 之包含块</title>
      <link>https://oragekk.me/posts/Web/CSS/containing-block.html</link>
      <guid>https://oragekk.me/posts/Web/CSS/containing-block.html</guid>
      <source url="https://oragekk.me/rss.xml">你不知道的 CSS 之包含块</source>
      <description>你不知道的 CSS 之包含块 一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。 但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。 好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</description>
      <category>CSS</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 你不知道的 CSS 之包含块</h1>
<p>一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p>
<p>但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png" alt="image-20220814222004395" style="zoom: 20%;">
<p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png" alt="image-20220813140434032" style="zoom:50%;">
<p>包含块英语全称为<strong>containing block</strong>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p>
<p><em><a href="https://drafts.csswg.org/css2/#containing-block-details" target="_blank" rel="noopener noreferrer">https://drafts.csswg.org/css2/#containing-block-details</a></em></p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png" alt="image-20220814222458695" style="zoom:50%;">
<p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p>
<p>那么，这个包含块究竟说了什么内容呢？</p>
<p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p>
<p>来吧，少年，让我们从最简单的 case 开始看。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png" alt="image-20220814223152726" style="zoom: 50%;">
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png" alt="image-20220814223451349" style="zoom: 33%;">
<p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p>
<p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p>
<p>这个答案实际上是不准确的。正确的答案应该是，<strong>div.item 的宽高是根据它的包含块来计算的</strong>，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p>
<p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p>
<p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p>
<p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p>
<ul>
<li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li>
<li>如果 position 属性是 fixed，那么包含块由视口建立。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p>
<p>公布正确答案：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png" alt="image-20220814233548188" style="zoom: 33%;">
<p>怎么样？有没有和你所想象的对上？</p>
<p>其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。</p>
<p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。</p>
<p>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p>
<ul>
<li>transform 或 perspective 的值不是 none</li>
<li>will-change 的值是 transform 或 perspective</li>
<li>filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效).</li>
<li>contain 的值是 paint (例如: contain: paint;)</li>
</ul>
<p>我们还是来看一个示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png" alt="image-20220814234347149" style="zoom:33%;">
<p>可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。</p>
<p>好了，到这里，关于包含块的知识就基本讲完了。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png" alt="image-20220814234654914" style="zoom:33%;">
<p>我们再把 CSS 规范中所举的例子来看一下。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？</p>
<p>对应的结果如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>body</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody>
</table>
<p>首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。</p>
<p>不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下：</p>
<ul>
<li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的**块容器（block container）**的内容区域（content area）的边缘建立。</li>
</ul>
<p>没错，因为 em1 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 p2。</p>
<p>接下来添加如下的 CSS：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p>
<p>答案如下：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>p2</td>
</tr>
<tr>
<td>strong1</td>
<td>p2</td>
</tr>
</tbody>
</table>
<p>可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p>
<ul>
<li>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</li>
<li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li>
</ul>
<p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的  position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。</p>
<p>接下来我们继续修改我们的 CSS：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？</p>
<p>没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。</p>
<p>如下表所示：</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>包含块</th>
</tr>
</thead>
<tbody>
<tr>
<td>html</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>body</td>
<td>html</td>
</tr>
<tr>
<td>div1</td>
<td>initial C.B. (UA-dependent)</td>
</tr>
<tr>
<td>p1</td>
<td>div1</td>
</tr>
<tr>
<td>p2</td>
<td>div1</td>
</tr>
<tr>
<td>em1</td>
<td>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</td>
</tr>
<tr>
<td>strong1</td>
<td>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</td>
</tr>
</tbody>
</table>
<p>好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。</p>
<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png" alt="image-20220815093518833" style="zoom:33%;">
<p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p>
<p>具体你可以移步到：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</a></em></p>
<p>好了，这就是有关包含块的所有内容了，你学会了么？-）</p>
<hr>
<p>-<em>EOF</em>-</p>
]]></content:encoded>
    </item>
    <item>
      <title>通过UserAgent判断设备</title>
      <link>https://oragekk.me/posts/Web/JavaScript/judgment.html</link>
      <guid>https://oragekk.me/posts/Web/JavaScript/judgment.html</guid>
      <source url="https://oragekk.me/rss.xml">通过UserAgent判断设备</source>
      <description>通过 js 判断 moblie 端和 pc 端进而加载不同的 css 或者 js 废话不多说，上代码 &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &amp;quot;ipad&amp;quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &amp;quot;iphone os&amp;quot;; var bIsMidp = sUserAgent.match(/midp/i) == &amp;quot;midp&amp;quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &amp;quot;rv:1.2.3.4&amp;quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &amp;quot;ucweb&amp;quot;; var bIsAndroid = sUserAgent.match(/android/i) == &amp;quot;android&amp;quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &amp;quot;windows ce&amp;quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &amp;quot;windows mobile&amp;quot;; // document.writeln(&amp;quot;您的浏览设备为：&amp;quot;); if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { // alert(&amp;quot;手机浏览！&amp;quot;); } else { // alert(&amp;quot;PC浏览！&amp;quot;); document.write(&amp;quot;&amp;lt;script type=&amp;apos;text/javascript&amp;apos; size=&amp;apos;150&amp;apos; alpha=&amp;apos;0.8&amp;apos; zIndex=&amp;apos;-10&amp;apos; src=&amp;apos;../js/dist/ribbon.js&amp;apos;&amp;gt;&amp;lt;\/script&amp;gt;&amp;quot;); document.write(&amp;quot;&amp;lt;script type=&amp;apos;text/javascript&amp;apos; color=&amp;apos;0,188,212&amp;apos; opacity=&amp;apos;0.7&amp;apos; zIndex=&amp;apos;-2&amp;apos; count=&amp;apos;99&amp;apos; src=&amp;apos;http://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js&amp;apos;&amp;gt;&amp;lt;\/script&amp;gt;&amp;quot;); 	} } browserRedirect(); &amp;lt;/script&amp;gt;</description>
      <category>JavaScript</category>
      <pubDate>Tue, 07 Feb 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>通过 js 判断 moblie 端和 pc 端进而加载不同的 css 或者 js</p>
</blockquote>
<h2> 废话不多说，上代码</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 需要注意的是字符转义和引号嵌套的问题</h3>
]]></content:encoded>
    </item>
    <item>
      <title>评论插件 Waline 之邮件通知配置</title>
      <link>https://oragekk.me/blog/waline-mail.html</link>
      <guid>https://oragekk.me/blog/waline-mail.html</guid>
      <source url="https://oragekk.me/rss.xml">评论插件 Waline 之邮件通知配置</source>
      <description>评论插件 Waline 之邮件通知配置 ✨ 陆续优化中……这次到了评论的邮件通知，由于 waline 带后端，可以开启评论通知，我是部署在 Vercel 上的，配置一下就可以了，模版要感谢小波同学 前置注意点 1.邮件要注意每日发信限制，短时密集评论会导致直接被封，禁止发信 2.最好不要使用自己平常使用的邮箱，使用一个单独的邮箱来操作 3.有服务器的同学，自己部署SMTP服务可以不受限制</description>
      <category>Blog</category>
      <pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 评论插件 Waline 之邮件通知配置</h1>
<div class="hint-container info">
<p class="hint-container-title">✨</p>
<p>陆续优化中……这次到了评论的邮件通知，由于 waline 带后端，可以开启评论通知，我是部署在 Vercel 上的，配置一下就可以了，模版要感谢<a href="https://blog.ganxb2.com/" target="_blank" rel="noopener noreferrer">小波同学</a></p>
<p>前置注意点</p>
<p>1.邮件要注意每日发信限制，短时密集评论会导致直接被封，禁止发信</p>
<p>2.最好不要使用自己平常使用的邮箱，使用一个单独的邮箱来操作</p>
<p>3.有服务器的同学，自己部署SMTP服务可以不受限制</p>
</div>
<p>老规矩先放效果图:</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/29/8958076dc393c8df.png" alt="show" tabindex="0" loading="lazy"><figcaption>show</figcaption></figure>
<h2> 1. waline 官方邮件通知环境变量说明<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></h2><a class="footnote-anchor" id="footnote-ref1">
</a><h3><a class="footnote-anchor" id="footnote-ref1"></a> 1.1 waline 邮件通知必填环境变量</h3>
<p><code>SMTP_SERVICE: SMTP</code> 邮件发送服务提供商。例如 163 在受支持的运营商列表可以直接填写 163</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>你可以在 <a href="https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json" target="_blank" rel="noopener noreferrer">这里</a> 查看所有支持的运营商。</p>
<p>如果你的运营商不受支持，你必须填写 <code>SMTP_HOST 和 SMTP_PORT</code>。</p>
<ul>
<li>
<p><code>SMTP_HOST</code>: SMTP 服务器地址，一般可以在邮箱的设置中找到。</p>
</li>
<li>
<p><code>SMTP_PORT</code>: SMTP 服务器端口，一般可以在邮箱的设置中找到。</p>
</li>
</ul>
</div>
<p><code>SMTP_USER</code>: SMTP 邮件发送服务的用户名，一般为登录邮箱【切记要完整填写xxx@xxx.xx】。</p>
<p><code>SMTP_PASS</code>: SMTP 邮件发送服务的密码，一般为邮箱登录密码，部分邮箱(例如 163)是单独的 SMTP 密码。 <sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup></p><a class="footnote-anchor" id="footnote-ref2">
<p><code>SMTP_SECURE</code>: 是否使用 SSL 连接 SMTP。</p>
<p><code>SITE_NAME</code>: 网站名称，用于在消息中显示。</p>
<p><code>SITE_URL</code>: 网站地址，用于在消息中显示。</p>
<p><code>AUTHOR_EMAIL</code>: 博主邮箱，用来接收新评论通知。如果是博主发布的评论则不进行提醒通知。</p>
<div class="hint-container tip">
<p class="hint-container-title">注意</p>
<p>其中<code>SITE_NAME</code>如果有类似 <code>xxxx's Blog</code> 这种的网站名称，在 Vercel 中配置的时候，可以使用<code>xxxx Blog</code> 格式<br>
因为<code>'</code>单引号会在模版中被转义为<code>&amp;#39;s</code></p>
</div>
</a><h3><a class="footnote-anchor" id="footnote-ref2"></a> 1.2 waline 邮件通知选填环境变量</h3>
<p><code>SENDER_NAME</code>: 自定义发送邮件的发件人</p>
<p><code>SENDER_EMAIL</code>: 自定义发送邮件的发件地址</p>
<div class="hint-container tip">
<p class="hint-container-title">注意</p>
<p>其中<code>SENDER_NAME</code>和<code>SENDER_EMAIL</code> 要成对出现</p>
</div>
<h3> 1.3 waline 邮件通知模版环境变量</h3>
<p><code>MAIL_SUBJECT</code>: 自定义评论回复邮件标题</p>
<p><code>MAIL_TEMPLATE</code>: 自定义评论回复邮件内容</p>
<p><code>MAIL_SUBJECT_ADMIN</code>: 自定义新评论通知邮件标题</p>
<p><code>MAIL_TEMPLATE_ADMIN</code>: 自定义新评论通知邮件内容</p>
<h3> 1.4 waline邮件通知模版index.js服务端配置参数</h3>
<ul>
<li>
<p><code>mailSubject</code> 类型: string</p>
<p>评论回复邮件标题自定义，等同于环境变量 <code>MAIL_SUBJECT</code>。</p>
</li>
<li>
<p><code>mailTemplate</code> 类型: string</p>
<p>评论回复邮件内容自定义，等同于环境变量 <code>MAIL_TEMPLATE</code>。</p>
</li>
<li>
<p><code>mailSubjectAdmin</code> 类型: string</p>
<p>新评论通知邮件标题自定义，等同于环境变量 <code>MAIL_SUBJECT_ADMIN</code>。</p>
</li>
<li>
<p><code>mailTemplateAdmin</code> 类型: string</p>
<p>新评论通知邮件内容自定义，等同于环境变量 <code>MAIL_TEMPLATE_ADMIN</code>。</p>
</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>自此以下配置都是关于邮件模版的，1.3和1.4二选一配置即可，1.1是必填配置，自行填写即可。</p>
</div>
<h2> 2.根据部署方式选择合适的邮件模版修改方法</h2>
<h3> 2.1 vercel</h3>
<ul>
<li>环境变量<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup></li><a class="footnote-anchor" id="footnote-ref3">
<li>私有walie仓库index.js文件【推荐】</li>
</a></ul><a class="footnote-anchor" id="footnote-ref3">
</a><h3><a class="footnote-anchor" id="footnote-ref3"></a> 2.2 独立部署</h3>
<ul>
<li>修改服务端入口文件index.js</li>
</ul>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>如果你使用模板，请额外注意你需要自行保存这些配置，因为它们会在拉取官方最新模板时被覆盖。</p>
<p>建议将官方最新模板上传到自己的仓库，并进行修改。</p>
</div>
<h2> 3.开始配置</h2>
<h3> 3.1 设置完毕1.1中Vercel配置必须的环境变量</h3>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/29/ab416544129053c3.png" alt="1.1" tabindex="0" loading="lazy"><figcaption>1.1</figcaption></figure>
<h3> 3.2 继续使用环境变量设置模版</h3>
<p><code>MAIL_SUBJECT_ADMIN</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>MAIL_TEMPLATE_ADMIN</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MAIL_SUBJECT</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>MAIL_TEMPLATE</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 使用服务端入口文件index.js变量设置模版</h3>
<p>文件初始内容为:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container danger">
<p class="hint-container-title">注意!!!</p>
<p>在我查阅资料的过程中，发现很多教程中填写index.js的方式都是错误的，如下:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是导致很多人index.js配置不成功的原因，把模版配置写在了postSave这个钩子函数里边,在Vercel部署的过程中就会直接报错，语法不正确</p>
</div>
<p>正确使用姿势:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 结语</h3>
<p>至此，大功告成，所有的注意点我都写在上边了</p>
<p>此模版来自SaraKale<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup><a class="footnote-anchor" id="footnote-ref4">，经</a><a href="https://blog.ganxb2.com/" target="_blank" rel="noopener noreferrer">小波同学</a>修改美化<br>
其他模版同理，可以去SaraKale这里看看</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p><a href="https://waline.js.org/guide/features/notification.html" target="_blank" rel="noopener noreferrer">https://waline.js.org/guide/features/notification.html</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>如 163 的 SMTP 授权码只生成一次，要复制存下来，如果丢失，后续不会再显示，只能重新生成 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote3" class="footnote-item"><p>Vercel 的环境变量大小限制为 4KB ，所以如果您的模板很长，请使用代码配置， <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote4" class="footnote-item"><p><a href="https://www.sarakale.top/blog/posts/537344b2.html" target="_blank" rel="noopener noreferrer">waline 邮件通知模板样式一览</a> <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/29/8958076dc393c8df.png" type="image/png"/>
    </item>
    <item>
      <title>终端究极美化iTerm2+Pure</title>
      <link>https://oragekk.me/posts/Linux/iterm2-pure.html</link>
      <guid>https://oragekk.me/posts/Linux/iterm2-pure.html</guid>
      <source url="https://oragekk.me/rss.xml">终端究极美化iTerm2+Pure</source>
      <description>提示 之前介绍了ZSH的安装和使用，这次把最终成果介绍一下，就是ZSH + iTerm2 + Pure 前置工作：安装ZSH，请参照之前的文章👉zsh安装</description>
      <category>Linux</category>
      <pubDate>Fri, 24 Mar 2023 16:40:37 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>之前介绍了ZSH的安装和使用，这次把最终成果介绍一下，就是ZSH + iTerm2 + Pure</p>
<p>前置工作：安装ZSH，请参照之前的文章👉<a href="/posts/Linux/zsh.html" target="blank">zsh安装</a></p>
</div>
<!-- more -->
<h2> 目录</h2>

<h2> 先看效果图</h2>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/140a5562a8b9e334.png" alt="界面" tabindex="0" loading="lazy"><figcaption>界面</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/810d0c1d2a4d7069.png" alt="命令提示" tabindex="0" loading="lazy"><figcaption>命令提示</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/052c26b51ecde528.png" alt="流输出" tabindex="0" loading="lazy"><figcaption>流输出</figcaption></figure>
<h2> 安装pure</h2>
<p>👉<a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p>可以使用 npm 或手动安装。需要 Git 2.15.2+ 和 ZSH 5.2+。已知旧版本的 ZSH 可以工作，但不推荐使用。</p>

<p>如果是手动安装的，将克隆的 repo 的路径添加到 $HOME/.zshrc 中的 $fpath 。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>将以下内容复制到 <code>.zshrc</code>文件中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 .zshrc 中设置 ZSH_THEME="" 以禁用 oh-my-zsh 主题。</p>
<p>到这里就基本完成了，如果要基于pure做详细定制，请参考文档</p>
<h2> iTerm2</h2>
<p>👉戳这里下载 <a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener noreferrer">官方下载地址</a></p>
<p>效果图我自用的配置文件在这里 👉 <a href="https://pan.baidu.com/s/1cG-gSwoPouYXeZ-P2pjmAg" target="_blank" rel="noopener noreferrer">链接</a>  密码:74aq</p>
<h3> 1.主题配置</h3>
<p>访问iTerm2主题网站👉<a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener noreferrer">iTerm2-Color-Schemes</a></p>
<p>可以下载zip包并解压到本地，进入解压缩的文件目录，找到schemes文件夹，里边全是主题配置，可以对照github上的效果图来选择</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/2eee92812c17fc48.png" alt="导入" tabindex="0" loading="lazy"><figcaption>导入</figcaption></figure>
<h3> 2. 标签页配色</h3>
<p>标签配色默认为黑色，不能与操作页面保持统一</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/9995b0382a76bba8.png" alt="默认" tabindex="0" loading="lazy"><figcaption>默认</figcaption></figure>
<p>打开iTerm2，打开Preferences配置界面，Appearence -&gt; General，将 Theme 改为 Minimal</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/411e917c7fb3d2b9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 设置 Status bar</h3>
<p>iTerm2 提供了不少的 Status bar，开启后我们可以在终端的最上方非常方便的实时查看本机的一些信息。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/d93a133dcd5fe00c.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>打开iTerm2，打开Preferences配置界面，Profiles -&gt; session-&gt; 勾选 Status bar enable-&gt; configure Status bar，选择自己想要的展示内容即可。向下托动放入Active Components 中即可,我这里只选了CPU、内存、网络</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/918522902136668f.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 光标选择</h3>
<p>iterm提供了三种光标可供选择：_、|、[]。</p>
<p>打开iTerm2，打开Preferences配置界面，Profiles -&gt; text-&gt; cursor，选择自己想要的光标即可。</p>
<h3> 5.配置SSH快速连接</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果出现没有权限，就命令前面加上sudo</p>
<p>键盘输入i编辑文件，插入以下内容：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>myserver.sh文件中变量解释：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入完成后键盘esc 然后输入:wq退出，接下来给文件赋权</p>
<p>chmod 777 <a href="http://myserver.sh" target="_blank" rel="noopener noreferrer">myserver.sh</a><br>
打开iTerm2，打开Preferences配置界面，Profiles -&gt; general，左下角点击+号，新建profile，参考下面图片在对应位置输入内容即可。</p>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/349fdd06e7bc428d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Name:根据需求输入，通常选择标识性较强的内容便于区分，例如服务器的IP地址</p>
<p>Command：这里选择login Shell</p>
<p>Send text at start ：填写格式形如A B C D E这样，每一个部分之间用空格隔开，根据自己实际情况填写,下面是对每一部分内容的解释</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>A 代表咱们上面写的本机保存sh脚本的路径：/Users/iterm/myserver.sh</p>
<p>B 代表服务器端口号一般远程连接端口为：22</p>
<p>C 代表服务器用户名一般为：root</p>
<p>D 代表服务器IP：公网IP填写</p>
<p>E 代表服务器密码：根据自己实际的服务器密码填写<br>
设置好之后打开iTerm2，点击profiles，点击前面自己新增的连接远程服务器的profile的名字</p>
<p>首次连接需要输入一次服务器密码，之后再连接就免密码登陆了</p>
</div>
<h2> 结语</h2>
<p>当然这里只介绍一部分，还有很多高级玩法，需要用到的时候自己去研究一下了</p>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/24/140a5562a8b9e334.png" type="image/png"/>
    </item>
    <item>
      <title>使用Bing API提交网站URL</title>
      <link>https://oragekk.me/posts/Python/submit-bing.html</link>
      <guid>https://oragekk.me/posts/Python/submit-bing.html</guid>
      <source url="https://oragekk.me/rss.xml">使用Bing API提交网站URL</source>
      <description>提示 最近在做SEO，因为链接没有做同步，需要清除之前旧站的链接，重新提交，让搜索引擎尽快索引，google search console的已经基本做差不多了 bing最近因为 New Bing 的原因也用的比较多，所以做了一些工作，很方便的是，它可以直接同步GSC的站点数据，不过就只是域数据，URL还是要自己提交 为了尽快索引，只提交sitemap是不够的，还需要调用API手动提交URL</description>
      <category>python</category>
      <pubDate>Fri, 24 Mar 2023 10:52:27 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>最近在做SEO，因为链接没有做同步，需要清除之前旧站的链接，重新提交，让搜索引擎尽快索引，google search console的已经基本做差不多了</p>
<p>bing最近因为 <em>New Bing</em> 的原因也用的比较多，所以做了一些工作，很方便的是，它可以直接同步GSC的站点数据，不过就只是域数据，URL还是要自己提交</p>
<p>为了尽快索引，只提交sitemap是不够的，还需要调用API手动提交URL</p>
</div>
<h3> 官方示例</h3>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/25889c6c306381f8.png" alt="bing example" tabindex="0" loading="lazy"><figcaption>bing example</figcaption></figure>
<h3> python代码</h3>

<h3> 解读</h3>
<p>在上面的脚本中，我们首先指定了Sitemap的URL。然后，我们使用Python中的requests库获取Sitemap的内容，并使用Python中的xml.etree.ElementTree库解析Sitemap中的URL。</p>
<p>接下来，我们使用Bing API提交URL。我们首先指定Bing API的密钥和API URL，并设置请求头。然后，我们将Sitemap中提取的URL列表作为数据，将其作为JSON格式发送到Bing API。最后，我们检查响应的状态码，以确保URL已成功提交。</p>
<p>注意：在使用Bing API提交URL之前，需要先注册Bing Webmaster工具，并获取Bing API密钥。还需要将"<a href="https://example.com" target="_blank" rel="noopener noreferrer">https://example.com</a>"替换为自己的站点URL。</p>
<p>API密钥生成↘️</p>
<ol>
<li>访问<a href="https://www.bing.com/webmasters/" target="_blank" rel="noopener noreferrer">Bing Webmaster Tools</a></li>
<li>右上角设置</li>
</ol>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/24/6fb703876007f6b6.png" alt="API密钥生成" width="500" tabindex="0" loading="lazy"><figcaption>API密钥生成</figcaption></figure>
]]></content:encoded>
      <enclosure url="https://s3.bmp.ovh/imgs/2023/03/24/25889c6c306381f8.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter 基础大集合</title>
      <link>https://oragekk.me/posts/cross-platform/Flutter/newbie.html</link>
      <guid>https://oragekk.me/posts/cross-platform/Flutter/newbie.html</guid>
      <source url="https://oragekk.me/rss.xml">Flutter 基础大集合</source>
      <description>Flutter初学，demo</description>
      <category>Flutter</category>
      <category>前端跨平台</category>
      <pubDate>Mon, 20 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>把之前学习时候写的demo拿出来记录一下<br>
地址：<br>
<a href="https://github.com/OrageKK/flutter_my_app" target="_blank" rel="noopener noreferrer">flutter_my_app</a></p>
</div>
<p>demo是照着B站的视频敲的，现在可能用不上了，但是还是觉得当时写的demo对于想学习flutter的新手来说作用还是有的，因为视频课程很零散，所以我边看边写了一个app，里边基本介绍了大部分基础的用法，当然进阶的东西，这部分demo是没有的，最近也在忙，有空了再补一部分进阶的东西吧</p>
<p>现在在做的内容是native+flutter混编，其中坑也不少，有时间会慢慢记录一下</p>
<h2> 预览</h2>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/b4d8d0a22fcdfd1a.png" alt="home" width="500" tabindex="0" loading="lazy"><figcaption>home</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/a4e70357270289d9.png" alt="side" width="500" tabindex="0" loading="lazy"><figcaption>side</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/88359eef4b2eee2f.png" alt="animation" width="500" tabindex="0" loading="lazy"><figcaption>animation</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/a1e88c9565dd0831.png" alt="search" width="500" tabindex="0" loading="lazy"><figcaption>search</figcaption></figure>
<figure><img src="https://s3.bmp.ovh/imgs/2023/03/20/5e6fe8f921ad4079.png" alt="alert" width="500" tabindex="0" loading="lazy"><figcaption>alert</figcaption></figure>
<h2> Getting Started</h2>
<p>This project is a starting point for a Flutter application.</p>
<p>A few resources to get you started if this is your first Flutter project:</p>
<ul>
<li><a href="https://docs.flutter.dev/get-started/codelab" target="_blank" rel="noopener noreferrer">Lab: Write your first Flutter app</a></li>
<li><a href="https://docs.flutter.dev/cookbook" target="_blank" rel="noopener noreferrer">Cookbook: Useful Flutter samples</a></li>
</ul>
<p>For help getting started with Flutter development, view the<br>
<a href="https://docs.flutter.dev/" target="_blank" rel="noopener noreferrer">online documentation</a>, which offers tutorials,<br>
samples, guidance on mobile development, and a full API reference.</p>
<h2> 包含</h2>
<ul>
<li>路由管理</li>
<li>基础组件（Text、Image、Icon）</li>
<li>布局组件
<ul>
<li>容器组件Container</li>
<li>线性布局Row、Column</li>
<li>弹性布局Flex</li>
<li>流式布局Wrap</li>
<li>层叠布局Stack、Positioned</li>
<li>对齐与相对定位Align</li>
</ul>
</li>
<li>容器类组件
<ul>
<li>填充Padding</li>
<li>装饰容器DecoratedBox</li>
<li>变换Transform</li>
<li>剪裁Clip</li>
<li>页面骨架Scaffold、AppBar</li>
<li>抽屉菜单Drawer</li>
<li>底部Tab导航</li>
<li>页面body</li>
</ul>
</li>
<li>可滚动组件
<ul>
<li>GridView</li>
<li>ListView</li>
<li>TabBarView</li>
<li>CustomScrollView 和 Slivers</li>
</ul>
</li>
<li>动画
<ul>
<li>隐式动画</li>
<li>显式动画</li>
<li>交错动画</li>
<li>动画切换组件（AnimatedSwitcher）</li>
</ul>
</li>
</ul>
<h2> 使用库</h2>
<ul>
<li>fluttertoast: ^8.0.9</li>
<li>cached_network_image: ^3.2.2</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>评论系统从多说迁移到disqus指南</title>
      <link>https://oragekk.me/blog/disqus.html</link>
      <guid>https://oragekk.me/blog/disqus.html</guid>
      <source url="https://oragekk.me/rss.xml">评论系统从多说迁移到disqus指南</source>
      <description>由于多说评论系统将于 6 月 1 日下线，所以准备迁移至disqus，相比较的话对于国内环境还是多说好用一点，毕竟加载快，支持各大媒体的分享，也不用小伙伴们翻墙；而 disqus 分享也只支持 Facebook 和 twitter。。PS:貌似现在又被墙了，以后有时间再换吧，目前就先这样，国内据说畅言还不错</description>
      <category>Blog</category>
      <pubDate>Fri, 14 Apr 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>由于多说评论系统将于 6 月 1 日下线，所以准备迁移至<a href="https://disqus.com/" target="_blank" rel="noopener noreferrer">disqus</a>，相比较的话对于国内环境还是多说好用一点，毕竟加载快，支持各大媒体的分享，也不用小伙伴们翻墙；而 disqus 分享也只支持 Facebook 和 twitter。。PS:貌似现在又被墙了，以后有时间再换吧，目前就先这样，国内据说<a href="http://changyan.kuaizhan.com/static/help/" target="_blank" rel="noopener noreferrer">畅言</a>还不错</p>
</blockquote>
<h2> 迁移过程</h2>
<h3> 1.首先为了不丢失原有评论，导出多说评论</h3>
<figure><img src="http://i2.muimg.com/567571/f0d7b62ff410decf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.文件转换</h3>
<ul>
<li>由于 disqus 不支持多说导出的.json 文件，所以需要进行转换为 xml 文件，此处使用 github 上的轮子<a href="https://github.com/JamesPan/duoshuo-migrator" target="_blank" rel="noopener noreferrer">JamesPan/duoshuo-migrator</a></li>
<li>使用步骤
<ol>
<li>下载<a href="https://github.com/JamesPan/duoshuo-migrator/blob/master/duoshuo-migrator.py?raw=true" target="_blank" rel="noopener noreferrer">duoshuo-migrator.py</a>并安装依赖<br>
<img src="http://i2.muimg.com/567571/f98e1281fec1cdd7.png" alt="" loading="lazy"></li>
<li>执行 <code>python duoshuo-migrator.py -i ~/Desktop/export.json  -o disqus.xml</code>命令<br>
<img src="http://i2.muimg.com/567571/8e27bcddc31c29b2.png" alt="" loading="lazy"></li>
<li>将转换完成文件导入<br>
<img src="http://i2.muimg.com/567571/213761ad8cf62886.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
]]></content:encoded>
      <enclosure url="http://i2.muimg.com/567571/f0d7b62ff410decf.png" type="image/png"/>
    </item>
    <item>
      <title>Jekyll旧站回忆</title>
      <link>https://oragekk.me/blog/jekyll.html</link>
      <guid>https://oragekk.me/blog/jekyll.html</guid>
      <source url="https://oragekk.me/rss.xml">Jekyll旧站回忆</source>
      <description>“Yeah It&amp;apos;s on. ” 前言 Oragekk 的 Blog 就这么开通了。 跳过废话，直接看技术实现 2016 年，11 月 总算有个地方可以好好写点东西了。 作为一个程序员， 看多了别人的 Blog 这种轮子都是酷炫的不要不要的，自己其实一种想搞一个，前两天发现了 GitHub Pages +Jekyll 的技术方案，一下子就上瘾了。 终于可以有自己的自留地了，之前一直在简书上写一些技术类的文章，这次可以有个自己的地盘，想怎么写就怎么写。😝 哈哈。不过这些前端的东西对我也是一种挑战，似懂非懂的看着模板，和一堆 js+css+html 的代码。。一顿头大。。对照着效果，一步步自己改。改好了之后也是蛮有成就感的嘛</description>
      <category>Blog</category>
      <pubDate>Thu, 03 Nov 2016 12:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>“Yeah It's on. ”</p>
</blockquote>
<h2> 前言</h2>
<p>Oragekk 的 Blog 就这么开通了。</p>
<p><a href="#build">跳过废话，直接看技术实现 </a></p>
<p>2016 年，11 月 总算有个地方可以好好写点东西了。</p>
<p>作为一个程序员， 看多了别人的 Blog 这种轮子都是酷炫的不要不要的，自己其实一种想搞一个，前两天发现了 GitHub Pages +Jekyll 的技术方案，一下子就上瘾了。</p>
<p>终于可以有自己的自留地了，之前一直在简书上写一些技术类的文章，这次可以有个自己的地盘，想怎么写就怎么写。😝 哈哈。不过这些前端的东西对我也是一种挑战，似懂非懂的看着模板，和一堆 js+css+html 的代码。。一顿头大。。对照着效果，一步步自己改。改好了之后也是蛮有成就感的嘛</p>
<h2> <p id="build"></p></h2>
<h2> 正文</h2>
<p>接下来说说搭建这个博客的技术细节。</p>
<p>正好之前就有关注过 <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a> + <a href="http://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> 快速 Building Blog 的技术方案，非常轻松时尚。</p>
<p>其优点非常明显：</p>
<ul>
<li><strong>Markdown</strong> 带来的优雅写作体验</li>
<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>
<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
<ul>
<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>
</ul>
</li>
<li>Jekyll 的自定制非常容易，基本就是个模版引擎</li>
<li>Jekyll 的安装倒是不难，难的是安装它之前的一堆安装</li>
</ul>
<hr>
<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手</p>
<p>大的 Jekyll 主题直接 fork 了 Hux Blog<br>
本地调试环境需要 <code>gem install jekyll</code>，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功，现在淘宝的镜像地址也重定向了到<a href="http://gems.ruby-china.org/" target="_blank" rel="noopener noreferrer">gems.ruby-china.org</a> 公司的新电脑，正好连带配环境，装 rvm，ruby，gems，jekyll。搞定。不过最后的本地预览还是没搞好。索性我就改了 commit，去站点看效果。</p>
<p>之后看到域名还是 github 提供的固定域名，心里觉得不够高大上，果断万网去买了一个。还很便宜咯。。不过价格就不告诉你们了 😜</p>
<hr>
<p>以下引用自 Theme 作者</p>
<blockquote>
<p>Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），**不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……**所以为了体验，也补了不少 CSS 进去</p>
</blockquote>
<blockquote>
<p>最后就进入了耗时反而最长的<strong>做图、写字</strong>阶段，也算是进入了<strong>写博客</strong>的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。</p>
</blockquote>
<blockquote>
<p>第二天考虑中文字体的渲染，fork 了 <a href="http://www.typeisbeautiful.com/" target="_blank" rel="noopener noreferrer">Type is Beautiful</a> 的 <code>font</code> CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。</p>
</blockquote>
<hr>
<h2> 后记</h2>
<p>回顾这个博客的诞生，纯粹是出于个人兴趣。为了有个块自留地，可以无聊了写写，不开心了写写。</p>
<p>如果你恰好逛到了这里，希望你也能喜欢这个博客</p>
<p>—— 黄坤 后记于 2016.11</p>
]]></content:encoded>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://oragekk.me/demo/slides.html</link>
      <guid>https://oragekk.me/demo/slides.html</guid>
      <source url="https://oragekk.me/rss.xml">幻灯片页</source>
      <description>slidestart 幻灯片演示 一个简单的幻灯片演示与各种小贴士。 作者 Mr.Hope. 请滚动鼠标滚轮进入下一页 标注幻灯片 👇 (#/1/1) -- 标注幻灯片 使用 --- 标注水平幻灯片 在水平幻灯片中使用 -- 分割垂直幻灯片 使用 在幻灯片上添加属性 使用 在前一个 HTML 元素上添加属性 Markdown 你可以在幻灯片中使用 M...</description>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<!-- markdownlint-disable MD024 MD033 MD051 -->
]]></content:encoded>
      <enclosure url="https://oragekk.me/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>一人一句宋词</title>
      <link>https://oragekk.me/private/%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8F%A5%E5%AE%8B%E8%AF%8D.html</link>
      <guid>https://oragekk.me/private/%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8F%A5%E5%AE%8B%E8%AF%8D.html</guid>
      <source url="https://oragekk.me/rss.xml">一人一句宋词</source>
      <description>Bing 每日壁纸 写来留待日后慢慢欣赏 😜 苏轼 十年生死两茫茫， 不思量，自难忘。 陆游 红酥手，黄藤酒， 满城春色宫墙柳。 李清照 此情无计可消除， 才下眉头，却上心头。</description>
      <pubDate>Mon, 16 Jan 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="https://file.mo7.cc/api/public/bz?idx=1" alt="Bing 每日壁纸" tabindex="0" loading="lazy"><figcaption>Bing 每日壁纸</figcaption></figure>
<blockquote>
<p>写来留待日后慢慢欣赏 😜</p>
</blockquote>
<h3> 苏轼</h3>
<p>十年生死两茫茫，<br>
不思量，自难忘。</p>
<h3> 陆游</h3>
<p>红酥手，黄藤酒，<br>
满城春色宫墙柳。</p>
<h3> 李清照</h3>
<p>此情无计可消除，<br>
才下眉头，却上心头。</p>
<h3> 辛弃疾</h3>
<p>众里寻他千百度。<br>
蓦然回首，那人却在，灯火阑珊处。</p>
<h3> 柳永</h3>
<p>多情自古伤离别，<br>
更那堪冷落清秋节！</p>
<h3> 范仲淹</h3>
<p>羌管悠悠霜满地，<br>
人不寐，将军白发征夫泪。</p>
<h3> 晏殊</h3>
<p>无可奈何花落去，<br>
似曾相识燕归来。</p>
<h3> 岳飞</h3>
<p>三十功名尘与土，八千里路云和月。<br>
莫等闲、白了少年头，空悲切！</p>
<h3> 秦观</h3>
<p>两情若是久长时，<br>
又岂在朝朝暮暮。</p>
<h3> 李之仪</h3>
<p>只愿君心似我心，<br>
定不负相思意。</p>
<h3> 欧阳修</h3>
<p>人生自是有情痴，<br>
此恨不关风与月。</p>
<h3> 唐婉</h3>
<p>世情薄，人情恶，<br>
雨送黄昏花易落。</p>
<h3> 姜夔</h3>
<p>二十四桥仍在，<br>
波心荡、冷月无声。</p>
<h3> 晏几道</h3>
<p>琵琶弦上说相思。<br>
当时明月在，曾照彩云归。</p>
<h3> 李冠</h3>
<p>一寸相思千万绪。<br>
人间没个安排处。</p>
<h3> 宋祁</h3>
<p>绿杨烟外晓寒轻，<br>
红杏枝头春意闹。</p>
<h3> 周彦邦</h3>
<p>执手霜风吹鬓影，<br>
去意徊徨，别语愁难听。</p>
<h3> 万俟咏</h3>
<p>短长亭，古今情。<br>
楼外凉蟾一晕生，雨余秋更清。</p>
<h3> 蒋捷</h3>
<p>流光容易把人抛，<br>
红了樱桃，绿了芭蕉。</p>
<h3> 吴潜</h3>
<p>老去惜花心，相对花无语。</p>
<h3> 刘著</h3>
<p>江南几度梅花发，<br>
人在天涯鬓已斑。</p>
<h3> 贺铸</h3>
<p>试问闲情都几许。<br>
一川烟草，满城风絮。梅子黄时雨。</p>
<h3> 严蕊</h3>
<p>不是爱风尘，似被前缘误。<br>
花落花开自有时，总赖东君主。</p>
<h3> 黄庭坚</h3>
<p>若有人知春去处。<br>
唤取归来同住。</p>
<h3> 张先</h3>
<p>天不老，情难绝。<br>
心似双丝网，中有千千结。</p>
<h3> 晁补之</h3>
<p>人生无奈别离何。<br>
夜长嫌梦短，泪少怕愁多。</p>
<h3> 乐婉</h3>
<p>若是前生未有缘，<br>
待重结、来生愿。</p>
<h3> 朱淑真</h3>
<p>把酒送春春不语。黄昏却下潇潇雨。</p>
<blockquote>
<p>看完了，跪安吧。╮(╯_╰)╭</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://file.mo7.cc/api/public/bz?idx=1" type="image/"/>
    </item>
    <item>
      <title>Unix/Linux 扫盲笔记</title>
      <link>https://oragekk.me/posts/Linux/unix-linux-note.html</link>
      <guid>https://oragekk.me/posts/Linux/unix-linux-note.html</guid>
      <source url="https://oragekk.me/rss.xml">Unix/Linux 扫盲笔记</source>
      <description>This document is not completed and will be updated anytime. Catagory Catagory Unix Unix-like Single UNIX Specification Apple iOS XNU Kernel Linux Linux Kernel GNU Project Android Android Kernel Android ROM Chrome OS Chromium OS</description>
      <category>Linux</category>
      <pubDate>Tue, 14 Apr 2015 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>This document is not completed and will be updated anytime.</p>
</blockquote>
<h2> Catagory</h2>
<ul>
<li><a href="#catagory">Catagory</a></li>
<li><a href="#unix">Unix</a></li>
<li><a href="#unix-like">Unix-like</a>
<ul>
<li><a href="#single-unix-specification">Single UNIX Specification</a></li>
<li><a href="#apple-ios">Apple iOS</a></li>
<li><a href="#xnu-kernel">XNU Kernel</a></li>
</ul>
</li>
<li><a href="#linux">Linux</a>
<ul>
<li><a href="#linux-kernel">Linux Kernel</a></li>
<li><a href="#gnu-project">GNU Project</a></li>
<li><a href="#android">Android</a></li>
<li><a href="#android-kernel">Android Kernel</a></li>
<li><a href="#android-rom">Android ROM</a></li>
<li><a href="#chrome-os">Chrome OS</a></li>
<li><a href="#chromium-os">Chromium OS</a></li>
</ul>
</li>
</ul>
<hr>
<h2> Unix</h2>
<blockquote>
<p>Unix is a <strong>family</strong> of multitasking, multiuser computer OS.</p>
</blockquote>
<p>Derive from the original <strong>AT&amp;T Unix</strong>, Developed in the 1970s at <strong>Bell Labs</strong> (贝尔实验室), initially intended for use inside the <strong>Bell System</strong>.</p>
<ul>
<li>
<h4> Bell Labs</h4>
Bell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。<br>
<strong>C 语言也是 Bell Labs 的产物</strong>，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。</li>
</ul>
<p>AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both <strong>academic</strong> (最有有名的 BSD ) and <strong>commercial</strong> (Microsoft Xenix, IBM AIX, SunOS Solaris)</p>
<ul>
<li>
<h4> Xenix</h4>
<p>微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 <strong>Windows NT</strong>。</p>
</li>
<li>
<h4> BSD</h4>
<p><strong>Barkeley Software Distribution</strong>, also called Berkeley Unix. Today the term "BSD" is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支) - <strong>BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议</strong>，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple's OS X and iOS ） - BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。</p>
</li>
<li>
<h4> FreeBSD &amp; Apple</h4>
<p>FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 <strong>Darwin</strong> ，这个“达尔文”居然还是个开源系统，而且是 the Core of <strong>Mac OS X</strong> and <strong>iOS</strong>.</p>
</li>
<li>
<h4> NeXTSTEP</h4>
<p>An <strong>object-oriented</strong>, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an <strong>OO aplication layer</strong> and including several "kits".<br>
大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 <strong>NeXTSTEP 绝对是证明 Jobs 实力的作品。</strong></p>
</li>
<li>
<h4> Darwin</h4>
<p>[Darwin](<a href="http://en.wikipedia.org/wiki/Darwin_(operating_system%5C)" target="_blank" rel="noopener noreferrer">http://en.wikipedia.org/wiki/Darwin_(operating_system\)</a>), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of <strong>POSIX</strong>. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)<br>
<strong>所以说 Mac OS X 算是很正统 Unix 的了</strong></p>
</li>
<li>
<h4> POSIX</h4>
<p>可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS. - Fully POSIX compliant: - OS X - QNX OS (BlackBerry) - Mostly complicant: - Linux - OpenBSD/FreeBSD - Darwin (Core of <strong>iOS</strong> &amp; OS X) - <strong>Android</strong> - Complicant via compatibility feature （通过兼容功能实现兼容） - Windows NT Kernel - Windows Server 2000, 2003, 2008, 2008 R2, 2012 - Symbian OS (with PIPS) - Symbian was a closed-source OS.</p>
</li>
</ul>
<hr>
<h2> Unix-like</h2>
<blockquote>
<p>A Unix-like (sometimes referred to as UN*X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the <strong>Single UNIX Specification</strong>.</p>
</blockquote>
<p>There is no standard for defining the term.<br>
其实 Unix-like 是个相对模糊的概念：</p>
<ul>
<li>最狭义的 Unix 单指 Bell Labs's Unix</li>
<li>稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X</li>
<li>最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等</li>
</ul>
<h4> Single UNIX Specification</h4>
<p>The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to <strong>qualify for the name "Unix"</strong>, like <strong>POSIX</strong>.</p>
<h4> Apple iOS</h4>
<p>iOS is a <strong>Unix-like OS based on Darwin(BSD)</strong> and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, <strong>making iOS not fully Unix-compatible either.</strong></p>
<p>The iOS kernal is <strong>XNU</strong>, the kernal of Darwin.</p>
<h4> XNU Kernel</h4>
<p>XNU, the acronym(首字母缩写) for <strong><em>X is Not Unix</em></strong>, which is the <strong>Computer OS Kernel</strong> developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.</p>
<hr>
<h2> Linux</h2>
<blockquote>
<p>Linux is a Unix-like and mostly POSIX-compliant computer OS.</p>
</blockquote>
<figure><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png" alt="Unix_timeline" tabindex="0" loading="lazy"><figcaption>Unix_timeline</figcaption></figure>
<h4> Linux Kernel</h4>
<p>严格来讲，术语 Linux 只表示 <a href="http://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="noopener noreferrer">Linux Kernel</a> 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。</p>
<p>但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）</p>
<p>这类操作系统也被称为 <strong>GNU/Linux</strong></p>
<h4> GNU Project</h4>
<p>The GNU Project is a <strong>free software, mass collaboration</strong> project, which based on the following freedom rights:</p>
<ul>
<li>Users are free to run the software, share (copy, distribute), study and modify it.</li>
<li>GNU software guarantees these freedom-rights legally (via its license).</li>
<li>So it is not only FREE but, more important, FREEDOM.</li>
</ul>
<p>In order to ensure that the <em>entire</em> software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, <strong>the operating system</strong>, needed to be written.</p>
<p>This OS is decided to called <strong>GNU (a recursive acronym meaning "GNU is not Unix")</strong>. By 1992, the GNU Project had completed all of the major OS components except for their kernel, <em>GNU Hurd</em>.</p>
<p>With the release of the third-party <strong>Linux Kernel</strong>, started independently by <em>Linus Torvalds</em> in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS <strong>composed completely of free software</strong>.</p>
<p>Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.</p>
<p>Anyway, there eventually comes to the <strong>GNU/Linux</strong></p>
<ul>
<li><strong>GPL</strong>: GNU General Public License</li>
<li><strong>GCC</strong>: GNU Compiler Collection</li>
</ul>
<p>其他与 GPL 相关的自由/开源软件公共许可证：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Mozilla_Public_License" target="_blank" rel="noopener noreferrer">Mozilla Public License</a></li>
<li><a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener noreferrer">MIT License</a></li>
<li><a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener noreferrer">BSD Public License</a>
<ul>
<li>GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭</li>
</ul>
</li>
<li><a href="http://en.wikipedia.org/wiki/Apache_License" target="_blank" rel="noopener noreferrer">Apache License</a></li>
</ul>
<figure><img src="http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png" alt="Public License" tabindex="0" loading="lazy"><figcaption>Public License</figcaption></figure>
<h4> Android</h4>
<p>Android is a mobile OS based on <strong>Linux Kernel</strong>, so it's definitely <strong>Unix-like</strong>.</p>
<p><strong>Linux is under GPL so Android has to be open source</strong>.<br>
Android's source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google <em>(GMS are all proprietary)</em></p>
<h4> Android Kernel</h4>
<p>Android's kernel is based on one of the Linux kernel's long-term support (LTS) branches.</p>
<p><strong>Android's variant of the Linux kernel</strong> has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.</p>
<p>Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。</p>
<h4> Android ROM</h4>
<p>既然提到 Android 就不得不提提 Android ROM</p>
<p>ROM 的本义实际上是只读内存：</p>
<p><strong>Read-only memory</strong> (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is <strong>mainly used to distribute firmware (固件)</strong> (software that is very closely tied to specific hardware, and unlikely to need frequent updates).</p>
<p>ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash</p>
<ul>
<li>PROM (Programmable read-only memory)</li>
<li>EPROM (Erasable programmable read-only memory)</li>
<li>EEPROM (Electrically erasable programmable read-only memory)
<ul>
<li>Flash memory (闪存)</li>
</ul>
</li>
</ul>
<p>Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为 U 盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。</p>
<p>所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。</p>
<p>所以在 wiki 里是没有 Android ROM 这个词条的，只有 <a href="http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares" target="_blank" rel="noopener noreferrer">List of custom Android firmwares</a></p>
<blockquote>
<p>A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.</p>
</blockquote>
<p>各类 Android ROM 在 Android 词类下也都是属于 <strong>Forks and distributions</strong> 一类的。</p>
<p>所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……<strong>其实 ROM 和 Distribution OS 的界限是很模糊的</strong>，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？</p>
<h4> Chrome OS</h4>
<p>Chrome OS is an operating system based on the <strong>Linux kernel</strong> and designed by Google to work with web applications and installed applications.</p>
<p>虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……</p>
<ul>
<li><strong>Chrome Packaged Application</strong> (Support working offline and installed)</li>
<li><strong>Android App Runtime</strong> (run Android applications natively...fxxking awesome)</li>
</ul>
<p>平复一下激动的心情，还是回到正题来：</p>
<h4> Chromium OS</h4>
<p>Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a <strong>Linux distribution</strong> designed by Google.</p>
<p>For Detail, Chromium OS based on <a href="http://en.wikipedia.org/wiki/Gentoo_Linux" target="_blank" rel="noopener noreferrer">Gentoo Linux</a>, emm...</p>
]]></content:encoded>
      <enclosure url="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png" type="image/png"/>
    </item>
    <item>
      <title>CommonJS，RequireJS，SeaJS 归纳笔记</title>
      <link>https://oragekk.me/posts/Web/JavaScript/js-module-loader.html</link>
      <guid>https://oragekk.me/posts/Web/JavaScript/js-module-loader.html</guid>
      <source url="https://oragekk.me/rss.xml">CommonJS，RequireJS，SeaJS 归纳笔记</source>
      <description>Foreword Here comes Module! 随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。 于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。 Catalog</description>
      <category>JavaScript</category>
      <pubDate>Mon, 25 May 2015 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Foreword</h2>
<blockquote>
<p>Here comes Module!</p>
</blockquote>
<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>
<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>
<hr>
<h2> Catalog</h2>
<ul>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#catalog">Catalog</a></li>
<li><a href="#commonjs--node">CommonJS &amp; Node</a></li>
<li><a href="#history">History</a></li>
<li><a href="#requirejs--amd">RequireJS &amp; AMD</a>
<ul>
<li><a href="#1-%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA">1. <strong>执行时机</strong></a></li>
<li><a href="#2-%E4%B9%A6%E5%86%99%E9%A3%8E%E6%A0%BC">2. <strong>书写风格</strong></a></li>
</ul>
</li>
<li><a href="#seajs--cmd">SeaJS &amp; CMD</a></li>
<li><a href="#amd-vs-cmd">AMD vs CMD</a></li>
<li><a href="#webpack">WebPack</a></li>
</ul>
<h2> CommonJS &amp; Node</h2>
<blockquote>
<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>
</blockquote>
<p>前端模块化的事实标准之一，2009 年 8 月，<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="noopener noreferrer">CommonJS</a> 诞生。</p>
<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>
<p>让我们看看 Node 中的实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>
<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>
<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>
<ul>
<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>
<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>
<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>
</ul>
<p>本文接下来要讨论的典例是：</p>
<ul>
<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>
<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>
</ul>
<h2> History</h2>
<!--<h2 id="history"> History </h2>-->
<blockquote>
<p>此段落参考自玉伯的 <a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="noopener noreferrer">前端模块化开发那点历史</a></p>
</blockquote>
<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="noopener noreferrer">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>
<p>09 年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>
<ol>
<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href="http://wiki.commonjs.org/wiki/Modules/Transport" target="_blank" rel="noopener noreferrer">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>
<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="noopener noreferrer">AMD</a> 规范及其实现 <a href="http://requirejs.org/" target="_blank" rel="noopener noreferrer">RequireJS</a>。这个稍后再细说。</li>
<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（<a href="http://flyscript.org" target="_blank" rel="noopener noreferrer">flyscript.org</a>）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>
</ol>
<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>
<h2> RequireJS &amp; AMD</h2>
<p><a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="noopener noreferrer">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
<blockquote>
<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>
</blockquote>
<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>
</blockquote>
<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The AMD loader will parse out the <code>require('')</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>
<p>AMD 和 CommonJS 的核心争议如下：</p>
<h3> 1. <strong>执行时机</strong></h3>
<p>Modules/1.0:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>AMD: （使用 require 的语法糖时）</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>
<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>
<h3> 2. <strong>书写风格</strong></h3>
<p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>
<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> SeaJS &amp; CMD</h2>
<p>CMD (Common Module Definition) 是 <a href="http://seajs.org/docs/" target="_blank" rel="noopener noreferrer">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>
<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>
<ul>
<li>CMD Specification
<ul>
<li><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener noreferrer">English (CMDJS-repo)</a></li>
<li><a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="noopener noreferrer">Chinese (SeaJS-repo)</a></li>
</ul>
</li>
</ul>
<p>CMD 主要有 define, factory, require, export 这么几个东西</p>
<ul>
<li>define <code>define(id?, deps?, factory)</code></li>
<li>factory <code>factory(require, exports, module)</code></li>
<li>require <code>require(id)</code></li>
<li>exports <code>Object</code></li>
</ul>
<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>
<ul>
<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>
<h2> AMD vs CMD</h2>
<p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>
<ol>
<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>
</ol>
<ul>
<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</li>
</ul>
<p>看代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> WebPack</h2>
<blockquote>
<p>working...</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript ES6</title>
      <link>https://oragekk.me/posts/Web/JavaScript/js-version.html</link>
      <guid>https://oragekk.me/posts/Web/JavaScript/js-version.html</guid>
      <source url="https://oragekk.me/rss.xml">JavaScript ES6</source>
      <description>JavaScript 有着很奇怪的命名史。 1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript （当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系） 歪果仁的笑话怎么一点都不好笑 译者注：wikipedia 的 JavaScript 词条 更详细的叙述了这段历史</description>
      <category>JavaScript</category>
      <pubDate>Tue, 22 Sep 2015 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JavaScript 有着很奇怪的命名史。</p>
<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>
<p><small class="img-hint">歪果仁的笑话怎么一点都不好笑</small></p>
<blockquote>
<p>译者注：<a href="https://en.wikipedia.org/wiki/JavaScript#History" target="_blank" rel="noopener noreferrer">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>
</blockquote>
<p>1996 年，网景将 JavaScript 提交给 <a href="http://www.ecma-international.org/" target="_blank" rel="noopener noreferrer">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>
<blockquote>
<p>术语（译者注）：</p>
<ul>
<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>
<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>
</ul>
</blockquote>
<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>
<blockquote>
<p>译者注：<a href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29" target="_blank" rel="noopener noreferrer">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href="https://en.wikipedia.org/wiki/ActionScript" target="_blank" rel="noopener noreferrer">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>
</blockquote>
<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>
<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="noopener noreferrer">decorators（装饰者）</a>，<a href="https://github.com/lukehoban/ecmascript-asyncawait" target="_blank" rel="noopener noreferrer">async-await（async-await 异步编程模型）</a> 和 <a href="https://github.com/jeffmo/es-class-properties" target="_blank" rel="noopener noreferrer">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href="https://babeljs.io/docs/usage/experimental/" target="_blank" rel="noopener noreferrer">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>
<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>
<ul>
<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>
<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>
<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>
<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener noreferrer">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>
<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>
<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>
</ul>
<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>
<h4> 一些资源</h4>
<ul>
<li>TC39 的 <a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener noreferrer">Github 仓库</a>上可以看到所有目前公开的提案</li>
<li>如果你还不熟悉 ES6，Babel 有一个<a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="noopener noreferrer">很不错的特性概览</a></li>
<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href="http://exploringjs.com/" target="_blank" rel="noopener noreferrer">Exploring ES6</a>和 Nicholas Zakas 的 <a href="https://leanpub.com/understandinges6" target="_blank" rel="noopener noreferrer">Understanding ECMAScript 6</a>。Axel 的博客 <a href="http://www.2ality.com/" target="_blank" rel="noopener noreferrer">2ality</a> 也是很不错的 ES6 资源</li>
</ul>
<p><small class="img-hint">来学 JavaScript 吧！</small></p>
<h4> 著作权声明</h4>
<p>本文译自 <a href="http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/" target="_blank" rel="noopener noreferrer">ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?</a><br>
译者 <a href="http://weibo.com/huxpro" target="_blank" rel="noopener noreferrer">黄玄</a>，首次发布于 <a href="http://huangxuan.me" target="_blank" rel="noopener noreferrer">Hux Blog</a>，转载请保留以上链接</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用n命令管理node版本</title>
      <link>https://oragekk.me/posts/Web/node/node-version.html</link>
      <guid>https://oragekk.me/posts/Web/node/node-version.html</guid>
      <source url="https://oragekk.me/rss.xml">使用n命令管理node版本</source>
      <description>鉴于使用 ReactNative 时，会需要不同的 node 版本，提供一种版本切换方式 使用 n command 来进行 node 版本管理 概念 n Node version manager 提供了一个更简单的 CLI，用于在 Node 版本之间进行安装和切换。它仅在 Linux 或 Mac 操作系统上受到支持。 安装 如果你已经安装某个版本的 Node 和 npm ，则可以用 npm install -g n 来安装 n，就像安装其他 NPM 包一样。</description>
      <category>Linux</category>
      <pubDate>Fri, 03 Apr 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>鉴于使用 ReactNative 时，会需要不同的 node 版本，提供一种版本切换方式</p>
</blockquote>
<h2> 使用 n command 来进行 node 版本管理</h2>
<h3> 概念</h3>
<p>n Node version manager 提供了一个更简单的 CLI，用于在 Node 版本之间进行安装和切换。它仅在 Linux 或 Mac 操作系统上受到支持。</p>
<h3> 安装</h3>
<p>如果你已经安装某个版本的 Node 和 npm ，则可以用 npm install -g n 来安装 n，就像安装其他 NPM 包一样。</p>
<p>如果你还没有安装 Node 或 npm，可以用 GitHub 中的 bash 脚本安装 n。这是它的样子：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过从 GitHub 下载并运行 n-install 脚本来安装 n。n 默认安装了一个版本的 Node。</p>
<h3> 安装版本 10.17.0</h3>
<p>如果需要指定版本号，可以这样安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 安装最新版本</h3>
<p>安装最新版本使用如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 切换版本</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>显示如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用上下方向键来选择版本，并回车。如果不想选择可以按<code>q</code>退出</p>
<h2> 直接使用 Node 二进制文件</h2>
<p>n 提供了直接调用特定 Node 二进制文件的功能，而无需显式切换到该版本的 Node。 NVM 则没有类似的功能。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，n use 命令所请求的 Node 版本需要由 n 安装。</p>
<p>在某些情况下，这个功能非常有用。例如，有一个构建服务器，用于构建需要不同 Node 版本的程序。可以用 n use 命令触发每个构建，并能够指定该程序所需的 Node 版本。</p>
<h2> 差异化</h2>
<p>NVM for Windows 和 n 有许多常见功能，也有一些独特的功能，这些功能会影响你使用每个工具的方式和位置。以下是一些主要差异的摘要：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>能力</strong></th>
<th style="text-align:center"><strong>NVM for Windows</strong></th>
<th style="text-align:center"><strong>n</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">安装</td>
<td style="text-align:center">Windows 安装程序或独立安装</td>
<td style="text-align:center">Bash 脚本或 npm 包</td>
</tr>
<tr>
<td style="text-align:center">操作系统支持</td>
<td style="text-align:center">Windows（适用于 Linux/Mac 的不同实现）</td>
<td style="text-align:center">仅限 Linux/Mac</td>
</tr>
<tr>
<td style="text-align:center">列出要安装的 Node 的可用版本？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">列出已安装的 Node 版本？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">在不同的 Node 版本之间安装和切换？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">直接访问 Node 二进制文件？</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">选择要安装的架构（x86，x64）？</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
</tbody>
</table>
<p>如果你使用 Linux/Mac 那么我很推荐你使用 n，因为它安装方便，并且 API 简单。我还是用过 homebrew 安装两个办版本，使用<code>brew link --overwrite --force node</code>命令来更改版本，很不方便，并且容错率很低</p>
<p>或者你可以在 Windows 上选择 NVM for Windows，同时在 Linux 构建服务器上选择 n</p>
<p>无论怎样，这两种工具都能很好地满足能够动态切换 Node 版本的需求。</p>
<blockquote>
<p>就是这么简单了</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>ReactNative介绍</title>
      <link>https://oragekk.me/posts/cross-platform/ReactNative/react1.html</link>
      <guid>https://oragekk.me/posts/cross-platform/ReactNative/react1.html</guid>
      <source url="https://oragekk.me/rss.xml">ReactNative介绍</source>
      <description>前置知识点介绍</description>
      <category>前端跨平台</category>
      <pubDate>Sat, 24 Aug 2019 09:38:39 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>ReactNative 是 Facebook 开发的一套用于开发跨平台 App 的技术框架</p>
<p>相比传统开发方式解决了一些痛点：</p>
<p>1.难以复用</p>
<p>2.多平台多次开发</p>
<p>3.效率低下</p>
<p>效率带来的缺点也可想而知就是一些原生可以实现的复杂操作，RN 做不到</p>
</blockquote>
<h2> 前置知识</h2>
<p>React Native 看起来很像 React，只不过其基础组件是原生组件而非 web 组件。要理解 React Native 应用的基本结构，首先需要了解一些基本的 React 的概念，比如 JSX 语法、组件、<code>state</code>状态以及<code>props</code>属性。如果你已经了解了 React，那么还需要掌握一些 React Native 特有的知识，比如原生组件的使用。</p>
<h2> 语言选择</h2>
<p>typeScript 是<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener noreferrer">JavaScript</a>的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener noreferrer">面向对象编程</a>。</p>
<p>本次开发使用 typeScript 作为 ReactNative 的开发语言，对比 JavaScript 有一些优势</p>
<h4> 一、ts 的静态检查</h4>
<p>参考<a href="https://www.zhihu.com/question/64563945" target="_blank" rel="noopener noreferrer">为什么要使用 TypeScript？有哪些情景请简单介绍一下，或者来个例子?</a><br>
TS 对 JS 的改进主要是静态类型检查，静态类型检查有何意义？标准答案是“静态类型更有利于构建大型应用”。为什么静态类型有利于构建大型应用？我总结，利在两点。</p>
<p>其一，静态类型检查可以做到 early fail，即你编写的代码即使没有被执行到，一旦你编写代码时发生类型不匹配，语言在编译阶段（解释执行也一样，可以在运行前）即可发现。针对大型应用，测试调试分支覆盖困难，很多代码并不一定能够在所有条件下执行到。而假如你的代码简单到任何改动都可以从 UI 体现出来，这确实跟大型应用搭不上关系，那么静态类型检查确实没什么作用。</p>
<p>配合 vscode 的<strong>TSLint</strong>插件可以很好的实现静态语法检查</p>
<h4> 二、 类型就是最好的注释。</h4>
<p>静态类型对阅读代码是友好的，针对大型应用，方法众多，调用关系复杂，不可能每个函数都有人编写细致的文档，所以静态类型就是非常重要的提示和约束。而假如你的代码像 jQuery 这样所有函数基本全是 API，根本没什么内部函数，而且逻辑关系看起来显而易见，这确实跟大型应用搭不上关系，那么静态类型对阅读代码确实也没什么帮助。总的来说，现代编程语言设计，很多特性已经有非常成熟的理论支持了，如果我们重视计算机基础，那么一些语言的适用场景就像是拼积木，可以用几句话概括。像是 TS 对 JS 这样，只是单一特性变化。</p>
<h4> PS:typeScript 本质上还是一个解释执行的脚本语言，和 JavaScript 一样没有编译过程</h4>
<p>同时也不是强类型语言，**是「静态类型检查」的「弱类型」**语言</p>
<p>真正的强类型语言有：java，swift，C#</p>
<h4> 三、 其他语法特性</h4>
<ol>
<li>
<p>TypeScript 工具使重构更变的容易、快捷。</p>
</li>
<li>
<p>TypeScript 引入了 JavaScript 中没有的“类”概念。</p>
</li>
<li>
<p>引入了 public，private，protected 访问控制符代替下划线私有</p>
</li>
<li>
<p>支持泛型和命名空间</p>
</li>
<li>
<p>TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p>
</li>
<li>
<p>支持接口的定义</p>
<p>……</p>
</li>
</ol>
<h2> JSX</h2>
<p><a href="https://facebook.github.io/jsx/" target="_blank" rel="noopener noreferrer">JSX</a>是一种嵌入式的类似 XML 的语法。 它可以被转换成合法的 JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX 因<a href="https://reactjs.org/" target="_blank" rel="noopener noreferrer">React</a>框架而流行，但也存在其它的实现。 TypeScript 支持内嵌，类型检查以及将 JSX 直接编译为 JavaScript。</p>
<p>想要使用 JSX 必须做两件事：</p>
<ol>
<li>给文件一个<code>.tsx</code>扩展名</li>
<li>启用<code>jsx</code>选项</li>
</ol>
<p>TypeScript 具有三种 JSX 模式：<code>preserve</code>，<code>react</code>和<code>react-native</code>。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在<code>preserve</code>模式下生成代码中会保留 JSX 以供后续的转换操作使用（比如：<a href="https://babeljs.io/" target="_blank" rel="noopener noreferrer">Babel</a>）。 另外，输出文件会带有<code>.jsx</code>扩展名。 <code>react</code>模式会生成<code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为<code>.js</code>。 <code>react-native</code>相当于<code>preserve</code>，它也保留了所有的 JSX，但是输出文件的扩展名是<code>.js</code>。</p>
<p>参考资料：</p>
<p><a href="https://reactnative.cn/docs/layout-props/#justifycontent" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">typeScriptg 中文文档</a></p>
<p><a href="https://www.imooc.com/video/14286" target="_blank" rel="noopener noreferrer">ReactNative 入门与进阶</a></p>
<p><a href="%5Bhttps://docs.nativebase.io%5D(https://docs.nativebase.io/)">https://docs.nativebase.io </a></p>
]]></content:encoded>
    </item>
    <item>
      <title>ReactNative开发环境配置，ES6语法介绍</title>
      <link>https://oragekk.me/posts/cross-platform/ReactNative/react2.html</link>
      <guid>https://oragekk.me/posts/cross-platform/ReactNative/react2.html</guid>
      <source url="https://oragekk.me/rss.xml">ReactNative开发环境配置，ES6语法介绍</source>
      <description>ReactNative开发环境配置，ES6语法介绍</description>
      <category>前端跨平台</category>
      <pubDate>Sun, 25 Aug 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>接上篇 <a href="/posts/ReactNative/react1.html" target="blank">ReactNative介绍</a></p>
</blockquote>
<h2> 创建 ReactNative 项目</h2>
<h4> 环境配置</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 配置 rn-cli.config.js</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Create our new project</h4>
<p><code>react-native init AwesomeProject</code></p>
<p><code>cd AwesomeProject react-native run-ios</code></p>
<h4> 项目结构图</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>tsconfig.json</code> 包含我们项目的 TypeScript 特定选项。</li>
<li><code>package.json</code> 包含我们的依赖项，以及我们想要运行的命令的一些快捷方式，用于测试，预览和部署我们的应用程序。</li>
<li><code>public</code>包含静态资产，例如我们计划部署到的 HTML 页面或图像。您可以删除此文件夹中的任何文件<code>index.html</code>。</li>
<li><code>src</code>包含我们的 TypeScript 和 CSS 代码。<code>index.tsx</code>是我们文件的入口点，并且是强制性的。</li>
<li><code>images.d.ts</code>将告诉 TypeScript 可以使用某些类型的图像文件<code>import</code>，create-react-app 支持这些文件。</li>
</ul>
<h4> 添加 TypeScript 配置文件</h4>
<p>我们想将 TypeScript 文件整合到一起 - 这包括我们写的源码和必要的声明文件。</p>
<p>我们需要创建一个<code>tsconfig.json</code>文件，它包含了输入文件列表以及编译选项。 在工程根目录下新建文件<code>tsconfig.json</code>文件，添加以下内容：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以在<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener noreferrer">这里</a>了解更多关于<code>tsconfig.json</code>文件的说明。</p>
<h4> 运行</h4>
<p><code>npm run start</code></p>
<p><code>npm run test</code></p>
<h2> 组件</h2>
<p>示例代码</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例中的这一行<code>&lt;View&gt;&lt;Text&gt;Hello world!&lt;/Text&gt;&lt;/View&gt;</code>恐怕很多人看起来也觉得陌生。这叫做 JSX——是一种在 JavaScript 中嵌入 XML 结构的语法。很多传统的应用框架会设计自有的模板语法，让你在结构标记中嵌入代码。React 反其道而行之，设计的 JSX 语法却是让你在代码中嵌入结构标记。初看起来，这种写法很像 web 上的 HTML，只不过使用的并不是 web 上常见的标签如<code>&lt;div&gt;</code>或是<code>&lt;span&gt;</code>等，这里我们使用的是 React Native 的组件。上面的示例代码中，使用的是内置的<code>&lt;Text&gt;</code>组件，它专门用来显示文本，而<code>&lt;View&gt;</code>就类似 html 中的<code>div</code>或是<code>span</code>这样的容器。</p>
<p>上面的代码定义了一个名为<code>HelloWorldApp</code>的新的<code>组件（Component）</code>。你在编写 React Native 应用时，肯定会写出很多新的组件。而一个 App 的最终界面，其实也就是各式各样的组件的组合。组件本身结构可以非常简单——唯一必须的就是在<code>render</code>方法中返回一些用于渲染结构的 JSX 语句。</p>
<h2> Props（属性）</h2>
<p>大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为<code>props</code>（属性）。</p>
<p>以常见的基础组件<code>Image</code>为例，在创建一个图片时，可以传入一个名为<code>source</code>的 prop 来指定要显示的图片的地址，以及使用名为<code>style</code>的 prop 来控制其尺寸。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意<code>{pic}</code>外围有一层括号，我们需要用括号来把<code>pic</code>这个变量嵌入到 JSX 语句中。括号的意思是括号内部为一个 js 变量或表达式，需要执行后取值。因此我们可以把任意合法的 JavaScript 表达式通过括号嵌入到 JSX 语句中。</p>
<p>使用的时候像这样<code>this.props</code>，请注意一点，在自定义组件内部，由外部传入的 props 的属性均为**readonly（只读）**不可在组件内部修改</p>
<h2> ES6 props 使用解构赋值</h2>
<p>组件内部赋值是这样的</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而使用解构赋值之后是这样的</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> ES6 延展操作符（...）</h2>
<h4> 该运算符主要用于函数调用</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 对象的扩展运算</h4>
<ul>
<li><strong>拷贝对象</strong></li>
</ul>
<p>对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>合并对象</strong></li>
</ul>
<p>扩展运算符可以用于合并两个对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 用于 props，要求参数名一致，此处用法其实是对 copy 对象的一种应用</h4>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<p>参考资料：</p>
<p><a href="https://reactnative.cn/docs/layout-props/#justifycontent" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/ae0a9ec1f8d6?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener noreferrer">ES6 延展操作符（...）</a></p>
<p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">typeScriptg 中文文档</a></p>
<p><a href="https://www.imooc.com/video/14286" target="_blank" rel="noopener noreferrer">ReactNative 入门与进阶</a></p>
<p><a href="%5Bhttps://docs.nativebase.io%5D(https://docs.nativebase.io/)">https://docs.nativebase.io </a></p>
]]></content:encoded>
    </item>
    <item>
      <title>ReactNative State(状态)</title>
      <link>https://oragekk.me/posts/cross-platform/ReactNative/react3.html</link>
      <guid>https://oragekk.me/posts/cross-platform/ReactNative/react3.html</guid>
      <source url="https://oragekk.me/rss.xml">ReactNative State(状态)</source>
      <description>ReactNative State(状态)</description>
      <category>前端跨平台</category>
      <pubDate>Tue, 12 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>接上篇 <a href="/posts/ReactNative/react2.html" target="blank">ReactNative开发环境配置，ES6语法介绍</a></p>
</blockquote>
<h2> ReactNative State(状态)</h2>
<h3> 概念</h3>
<p>通俗来讲，一个组件，或者一个视图，他们都是 Component，Component 用两个最重要的东西，一个<code>props</code></p>
<p>一个<code>state</code></p>
<p>我们使用两种数据来控制一个组件：<code>props</code>和<code>state</code>。<code>props</code>是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。(<code>props</code>就像一个类的初始化属性一样，只有在创建时可以赋值，并且组件内部不可修改，也就是<code>readonly</code>)</p>
<p>对于需要改变的数据，我们需要使用<code>state</code>。也可以把<code>state</code>理解为一个状态机，对于那些需要改变的数据可以使用<code>state</code>来更改，比如网络接口拿回来的数据，可以放在<code>state</code>里，当需要改变的时候只需要调用<code>setState</code>即可</p>
<h3> 使用</h3>
<p>一般来说，你需要在 class 中声明一个<code>state</code>对象，然后在需要修改时调用<code>setState</code>方法。</p>
<p>假如我们有一个弹窗，想要控制弹窗是不是显示，需要一个<code>modalVisible</code>属性，当更改它的值时从而使界面 UI 产生相应的变化</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一种声明方式，声明在类内部，声明的同时，进行初始化</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>this.state.modalVisible</code>来控制组件是否显示</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更新组件状态使用</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 注意点</h3>
<p>实际开发中，我们一般不会在定时器函数（setInterval、setTimeout 等）中来操作 state。典型的场景是在接收到服务器返回的新数据，或者在用户输入数据之后。你也可以使用一些“状态容器”比如<a href="http://redux.js.org/index.html" target="_blank" rel="noopener noreferrer">Redux</a>来统一管理数据流。</p>
<p>每次调用<code>setState</code>时，BlinkApp 都会重新执行 render 方法重新渲染。</p>
<ul>
<li>render（）中 UI 的变化只有当绑定的 state 中的某个属性变化后，才会变化</li>
<li>一切界面变化都是<code>状态state变化</code></li>
<li><code>state</code>的修改必须通过<code>setState()</code>方法
<ul>
<li>this.state.likes = 100; // 这样的<code>直接赋值修改无效！</code></li>
<li>setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性</li>
<li>setState 是<code>异步</code>操作，修改<code>不会马上生效</code></li>
</ul>
</li>
</ul>
<p>我们可以看到<code>setState</code>内部的声明</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要同步使用，我们可以使用第二个参数 callback?它是可选的</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<p>参考资料：</p>
<p><a href="https://reactnative.cn/docs/layout-props/#justifycontent" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://www.jianshu.com/p/ae0a9ec1f8d6?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener noreferrer">ES6 延展操作符（...）</a></p>
<p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">typeScriptg 中文文档</a></p>
<p><a href="https://www.imooc.com/video/14286" target="_blank" rel="noopener noreferrer">ReactNative 入门与进阶</a></p>
<p><a href="%5Bhttps://docs.nativebase.io%5D(https://docs.nativebase.io/)">https://docs.nativebase.io </a></p>
]]></content:encoded>
    </item>
    <item>
      <title>WebViewJavascriptBridge</title>
      <link>https://oragekk.me/posts/iOS/other/JavaScriptBridge.html</link>
      <guid>https://oragekk.me/posts/iOS/other/JavaScriptBridge.html</guid>
      <source url="https://oragekk.me/rss.xml">WebViewJavascriptBridge</source>
      <description>最近一直在忙，今天抽空写一下 H5 和 Native 的交互 一、选择 项目本身 webview 使用的是 WKWebview，其实 WKWebview 自带的 messageHandle 也可以满足此需求 JSContext,源自于 JavaScriptCore 框架中的东西，最后不使用此方案源于一下几点 但是其中繁杂的字符串使用，让我觉的可能会由于粗心出现不可预知的错误 加载时机的问题，当你重新 loadrequest 的时候，会导致 js 注入失败 回调方法略复杂 JavaScriptBridge，最后选择此库源于以下几点 使用简单，注册完毕之后设置完代理，只需要负责注册方法和调用方法 回调简单，两端回调 responsecallback 包含在注册的方法中。使用 block 三端通用，JavaScript 和 iOS、Android 都可以（Android 版本库） Ps :关于 Android 版本库，其中很多是按照 iOS 版的 JavaScriptBridge 改写的。但是其中有很多问题，尤其是各种调用时机问题，上面的链接是经过我旁边的 Android 小哥试了四五个版本之后发现的，修复了各种改写版的问题</description>
      <category>iOS</category>
      <pubDate>Sun, 05 Aug 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>最近一直在忙，今天抽空写一下 H5 和 Native 的交互</p>
</blockquote>
<h2> 一、选择</h2>
<ul>
<li>项目本身 webview 使用的是 WKWebview，其实 WKWebview 自带的 messageHandle 也可以满足此需求</li>
<li>JSContext,源自于 JavaScriptCore 框架中的东西，最后不使用此方案源于一下几点
<ul>
<li>但是其中繁杂的字符串使用，让我觉的可能会由于粗心出现不可预知的错误</li>
<li>加载时机的问题，当你重新 loadrequest 的时候，会导致 js 注入失败</li>
<li>回调方法略复杂</li>
</ul>
</li>
<li>JavaScriptBridge，最后选择此库源于以下几点
<ul>
<li>使用简单，注册完毕之后设置完代理，只需要负责注册方法和调用方法</li>
<li>回调简单，两端回调 responsecallback 包含在注册的方法中。使用 block</li>
<li>三端通用，JavaScript 和 iOS、Android 都可以（<a href="https://github.com/wendux/WebViewJavascriptBridge" target="_blank" rel="noopener noreferrer">Android 版本库</a>）</li>
<li>Ps :关于 Android 版本库，其中很多是按照 iOS 版的 JavaScriptBridge 改写的。但是其中有很多问题，尤其是各种调用时机问题，上面的链接是经过我旁边的 Android 小哥试了四五个版本之后发现的，修复了各种改写版的问题</li>
</ul>
</li>
</ul>
<h2> 二、使用</h2>
<ul>
<li>首先需要引入 WebViewJavascriptBridge 库</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>初始化，此处为了方便子类使用，所以在基类中注册 bridge，并 return bridge 对象，方便子类调用</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>注册方法供 JavaScript 调用</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>调用 JavaScript 方法</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 三、方法名定义</h2>
<ul>
<li>因为方法名的定义是字符串，所以建议采用常量字符串，防止拼写错误</li>
<li>其次不建议采用宏定义</li>
<li>我采用以下方法</li>
<li>桥接管理类的.h</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>桥接管理类的.m</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用时直接使用常量字符串即可</li>
<li>注意点：如类似我使用在基类传入控制器和 webview 到管理类中，在类中使用 controller 要注意循环引用，否则会导致控制器无法释放</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 四、数据传输</h2>
<ul>
<li>iOS 端直接返回字典即可</li>
<li>我代码中是返回 json 字符串，为了与 Android 统一，方便 H5 解析数据</li>
</ul>
<h2> 五、JavaScript 代码</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 六、注意事项</h2>
<ul>
<li>如果产生调用不通的问题，多为 JavaScript 调用时机问题</li>
<li>注意桥接的代理</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>初探机器学习框架CoreML</title>
      <link>https://oragekk.me/posts/iOS/other/coreML.html</link>
      <guid>https://oragekk.me/posts/iOS/other/coreML.html</guid>
      <source url="https://oragekk.me/rss.xml">初探机器学习框架CoreML</source>
      <description>CoreML 是 iOS 11 新推出的机器学习框架，是人工智能的核心内容，他可以在训练好的机器学习模型应用到 APP 中</description>
      <category>iOS</category>
      <pubDate>Tue, 21 Nov 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>CoreML 是 iOS 11 新推出的机器学习框架，是人工智能的核心内容，他可以在训练好的机器学习模型应用到 APP 中</p>
</blockquote>
<figure><img src="http://upload-images.jianshu.io/upload_images/74454-4726f1eccb39b18c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>所谓已训练模型 (trained model)指的是对一组训练数据应用了某个机器学习算法后，所生成的一组结果 Core ML 是领域特定 (domain-specific) 框架和功能的基础所在。Core ML 为 Vision 提供了图像处理的支持，为 Foundation 提供了自然语言处理的支持（例如 NSLinguisticTagger 类），为 <a href="https://developer.apple.com/documentation/gameplaykit" target="_blank" rel="noopener noreferrer">GameplayKit</a> 提供了对学习决策树 (learned decision tree) 进行分析的支持。Core ML 本身是基于底层基本类型而建立的，包括 Accelerate、BNNS 以及 Metal Performance Shaders 等。</p>
<h2> 获取模型</h2>
<p>Core ML 支持多种机器学习模型，其中包括了神经网络 (Neural Network)、组合树 (Tree Ensemble)、支持向量机 (Support Vector Machine) 以及广义线性模型 (Generalized Linear Model)。Core ML 的运行需要使用 Core ML 模型格式（也就是以 .mlmodel 扩展名结尾的模型）。</p>
<p>Apple 提供了一些常见的<a href="https://developer.apple.com/machine-learning/" target="_blank" rel="noopener noreferrer">开源模型</a>供大家使用，这些模型已经使用了 Core ML 模型格式。您可以自行下载这些模型，然后就可以开始在应用中使用它们了。</p>
<h2> 工程实例</h2>
<p>首先因为 CoreML 和 Vision 都是 iOS 11 才有的功能，你要确保 Xcode9 和 iOS 11 的设备，当然模拟器也可以。开发语言使用 Swift4</p>
<ol>
<li>
<p>将模型添加到 Xcode 中<br>
创建工程并引入模型文件<br>
<img src="https://storage1.cuntuku.com/2017/11/21/Snip20171121_6.png" alt="Snip20171121_6.png" loading="lazy"><br>
单击这个文件就可以看到这个模型的详细信息<br>
<a href="https://cuntuku.com/image/KNKHr" target="_blank" rel="noopener noreferrer"><img src="https://storage2.cuntuku.com/2017/11/21/Snip20171121_7.md.png" alt="Snip20171121_7.md.png" loading="lazy"></a><br>
下面是这个模型的官方介绍</p>
<blockquote>
<p>Detects the dominant objects present in an image from a set of 1000 categories such as trees, animals, food, vehicles, people, and more.大意为可以从 1000 个类别中筛选传树木、动物、食品、汽车、人等等。</p>
</blockquote>
</li>
<li>
<p>模型解读<br>
inputs 中写了需要一个 image 大小 299*299；outputs 里会有两个参数 classLabelProbs 和 classLabel<br>
，classLabelProbs 是一个[string:Double]的字典数组，数组里每一个字典就是这个输入图片分析得出可能的一个结果 string 就是对图片类型的描述，而 double 就是可能性百分比。另一个 classLabel 就是最有可能的一个一个结果描述</p>

</li>
<li>
<p>编写代码<br>
定义一个 imageView，一个 Label，一个 button<br>
点击按钮打开相册选取图片，选取完成执行下面的方法，然后再 label 显示分析结果</p>
</li>
</ol>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 运行效果</h2>
<p><a href="https://cuntuku.com/image/KNToV" target="_blank" rel="noopener noreferrer"><img src="https://storage2.cuntuku.com/2017/11/21/Snip20171121_3.md.png" alt="Snip20171121_3.md.png" loading="lazy"></a><br>
<a href="https://cuntuku.com/image/KNvFW" target="_blank" rel="noopener noreferrer"><img src="https://storage1.cuntuku.com/2017/11/21/Snip20171121_4.md.png" alt="Snip20171121_4.md.png" loading="lazy"></a><br>
<a href="https://cuntuku.com/image/KNNdd" target="_blank" rel="noopener noreferrer"><img src="https://storage2.cuntuku.com/2017/11/21/Snip20171121_5.md.png" alt="Snip20171121_5.md.png" loading="lazy"></a></p>
<h2> Demo</h2>
<p><a href="https://github.com/OrageKK/coreML-Examples" target="_blank" rel="noopener noreferrer">👉Demo 下载</a><br>
<strong>如果有帮助烦请点 star</strong></p>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/74454-4726f1eccb39b18c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>Test Three ways to call</title>
      <link>https://oragekk.me/posts/iOS/other/test-Three-ways-to-%20call.html</link>
      <guid>https://oragekk.me/posts/iOS/other/test-Three-ways-to-%20call.html</guid>
      <source url="https://oragekk.me/rss.xml">Test Three ways to call</source>
      <description>LabelPhoneNum 使用 YYtext 实现 label 中的某些文字点击拨打电话---Github 真机测试结果 设备型号：iphone6s 系统:10.1.1 Xcode 版本：8.1 三种打电话的方法 方法一:网上说使用此方法，电话结束后进入联系人列表，测试结果为：正常，电话结束后返回程序</description>
      <category>iOS</category>
      <pubDate>Sat, 12 Nov 2016 12:31:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LabelPhoneNum</h1>
<p>使用 YYtext 实现 label 中的某些文字点击拨打电话---<a href="https://github.com/OrageKK/LabelPhoneNum" target="_blank" rel="noopener noreferrer">Github</a></p>
<h2> 真机测试结果</h2>
<h4> 设备型号：iphone6s</h4>
<h4> 系统:10.1.1</h4>
<h4> Xcode 版本：8.1</h4>
<h3> 三种打电话的方法</h3>
<blockquote>
<p>方法一:网上说使用此方法，电话结束后进入联系人列表，测试结果为：正常，电话结束后返回程序</p>
</blockquote>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>方法二：测试结果为先弹窗后拨打，呼叫结束后返回程序，是否可以通过审核无法确认</p>
</blockquote>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>方法三：调用 UIWebView 进行呼叫功能，测试结果为：弹窗速度稍慢，电话挂掉之后返回程序</p>
</blockquote>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>总结来说除了第二种不知是否可以通过审核，其余方法均可实现呼叫并返回程序功能。</p>
</li>
<li>
<p>只是第一种方法爱需要手动弹出 AlertViewController；</p>
</li>
<li>
<p>第三种方法优势在于可以自动识别电话格式并弹窗，如号码为:01088867777 弹窗为 010-88867777。并且代码相对于第一种来说极为精简，少了自定义 AlertViewController 的步骤</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>神经网络模型训练</title>
      <link>https://oragekk.me/posts/iOS/other/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83.html</link>
      <guid>https://oragekk.me/posts/iOS/other/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83.html</guid>
      <source url="https://oragekk.me/rss.xml">神经网络模型训练</source>
      <description>神经网络模型训练 经过之前 coreML 的介绍，自己训练一个模型 使用 xcodeplayground 训练简单神经网络模型 详细： 去年，苹果(Apple)推出了 Core ML:这是一种快速的方法，可以让你用尽可能少的代码将预先培训好的机器学习模型导入应用程序中!今年，有了 Create ML，苹果给了我们开发人员创建我们自己的机器学习模型直接进入 Xcode 的平台的能力!我们只需要一些数据就行了!目前，Create ML 允许文本、图像和表作为数据。然而，由于这是大多数 ML 应用程序的组成部分，这应该很好地服务于您的目的!我将向您展示如何使用这三种类型的数据创建一个 ML 模型.</description>
      <category>iOS</category>
      <pubDate>Tue, 23 Jul 2019 16:08:25 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 神经网络模型训练</h1>
<blockquote>
<p>经过之前 coreML 的介绍，自己训练一个模型</p>
<p><em>使用 xcodeplayground 训练简单神经网络模型</em></p>
</blockquote>
<h2> 详细：</h2>
<p>去年，苹果(Apple)推出了 Core ML:这是一种快速的方法，可以让你用尽可能少的代码将预先培训好的机器学习模型导入应用程序中!今年，有了 Create ML，苹果给了我们开发人员创建我们自己的机器学习模型直接进入 Xcode 的平台的能力!我们只需要一些数据就行了!目前，Create ML 允许文本、图像和表作为数据。然而，由于这是大多数 ML 应用程序的组成部分，这应该很好地服务于您的目的!我将向您展示如何使用这三种类型的数据创建一个 ML 模型.</p>
<figure><img src="https://upload-images.jianshu.io/upload_images/3343369-38993f3fc4b87558.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1000/format/webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>注意：本教程构建在 Xcode 10 和 macOS Mojave 之上。请确保您升级了 Xcode 和 macOS，以便遵循本教程.</strong></p>
<p>之前的文章介绍过如何使用 ML，今天主要讲一下使用 xocde 的 playground 来训练一个简单神经网络模型，顺便可以熟悉 swift</p>
<h2> 准备工作</h2>
<p>1.本文想做一个图像分类器的模型，区分简单图像</p>
<p>2.打开文件夹时，您将注意到另外两个文件夹:训练数据和测试数据。每个文件夹都有苹果和香蕉的混合图片。有大约 20 张苹果图片和 20 张香蕉图片，分别被称为测试数据和 80 张苹果图片和 80 张香蕉图片。我们将在训练数据中使用图像来训练分类器，然后使用测试数据来确定其准确性。</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/sw1Tn6SBESjcjvMyVvu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>3.如果您想构建自己的图像分类器，那么将数据集进行 2-8 分割是很重要的。大约 80%的图像用于训练数据，其余部分用于测试数据。这样，您的分类器就有更多的数据需要训练。在每个文件夹中，将图像放在各自的文件夹中。根据图像的类别标签命名这些文件夹。</p>
<p>4.新建 playground，注意这里一定要选 macos 而不是 iOS，因为训练模型需要引入的头文件<strong>CreateMLUI</strong>是 macos 的</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/RaJzQO6Nm9Wjuvw3nCh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>5.接下来，给你的 playground 的起个名字，把他保存起来。</p>
<p>开始 coding</p>
<h2> 开始</h2>
<p>确保在 Xcode playground 中启用 Live View 特性，您将能够看到可视化界面!<br>
需要引入 CreateMLUI，CreateMLUI 是一个与 CreateML 类似的框架，但它有一个 UI。到目前为止，CreateMLUI 只能用于图像分类.<br>
然后在 playground 中输入以下代码</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/FqBcXuSwRDOxpw8UBTF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>运行之后是这个样子的</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/LxHV4JoUeBdaUGfodqb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面向其中拖入训练数据，它会自动开始训练并显示当前进度</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/gWYNXlrru03F8sMYlIR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>控制台也会显示一些信息</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/TUgR2XH0hovyEuJv7hP.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>训练完成之后我们可以看到上面有三个标签:培训、验证和评估。培训是指 Xcode 成功培训的培训数据的百分比。这应该是 100%</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/9JrqyfzXxNCjuDxSJMO.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>评估是空的因为我们还没有给 xcode 任何测试数据，xcode 会在剩余的 20%上验证分类器，接着拖入测试数据</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/PjupzGNXjHBhQixucpb.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当一切都完成后，我们的评估分数应该也是在 100%</p>
<p>如果你对你的结果满意，剩下的就是保存文件了!单击图像分类器标题旁边的箭头。应该出现一个下拉菜单，显示所有的元数据。将元数据更改为您想要的方式，并将其保存到您想要的位置!</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/9XYJjpWXhZSdRjZWLze.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>他长这个样子</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/8cNWX8eidTARekAmU3J.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来可以打开 CoreML 模型并查看元数据。它有你填的所有东西!恭喜你!您是您自己的图像分类器模型的作者，它非常强大，并且只需要 17 KB!</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/gAS7BWestsJDUJChOch.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 文本分类器模型</h2>
<p>接下来，我们将使用 Create ML 构建一个垃圾邮件检测器模型。<br>
废话不多说，上代码</p>
<figure><img src="http://www.demodashi.com/contentImages/image/20190724/Zb3xW53OWSeEt2pw1k7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>首先，我们创建一个名为 data 的常量，它是垃圾邮件的一种 MLDataTable。json 文件。MLDataTable 是一个全新的对象，用于创建一个决定训练或评估 ML 模型的表。我们将数据分为 trainingData 和 testingData。和以前一样，比率是 80-20，种子是 5。种子是指分类器的起点。然后我们用我们的训练数据定义一个叫做 spamClassifier 的 MLTextClassifier，定义数据的值是文本，什么值是标签。</li>
<li>创建了两个变量，名为 trainingAccuracy 和 validationAccuracy，用于确定分类器的准确程度。在侧窗格中，您可以看到百分比。</li>
<li>我们还检查评估的执行情况。(请记住，评价是分类器以前没有看到的文本上使用的结果，以及它们的准确性。</li>
<li>最后，我们为 ML 模型创建一些元数据，如作者、描述和版本。我们使用 write()函数将模型保存到我们选择的位置!在下面的图片中，你会看到我选择了桌面!</li>
</ul>
<figure><img src="https://upload-images.jianshu.io/upload_images/3343369-ce98597754508f93.png?imageMogr2/auto-orient/strip|imageView2/2/w/970/format/webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>运行。您可以在控制台中看到迭代，在右边栏中看到精度! 完成所有操作后，将保存核心 ML 模型!您可以查看模型并查看元数据!</p>
<figure><img src="https://upload-images.jianshu.io/upload_images/3343369-d8deb59d132c958c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1000/format/webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://upload-images.jianshu.io/upload_images/3343369-38993f3fc4b87558.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" type="image/"/>
    </item>
    <item>
      <title>AFNetworking A memory leak</title>
      <link>https://oragekk.me/posts/iOS/source/AFNETworking-A-memory-leak.html</link>
      <guid>https://oragekk.me/posts/iOS/source/AFNETworking-A-memory-leak.html</guid>
      <source url="https://oragekk.me/rss.xml">AFNetworking A memory leak</source>
      <description>细心的你是否也发现了 AFN 的内存泄漏的问题了呢. 解决方法 + (AFHTTPSessionManager *)sharedHTTPSession{ static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ manager = [AFHTTPSessionManager manager]; manager.requestSerializer.timeoutInterval = 30; [manager.requestSerializer setValue:@&amp;quot;XMLHttpRequest&amp;quot; forHTTPHeaderField:@&amp;quot;X-Requested-With&amp;quot;]; }); return manager; } + (AFURLSessionManager *)sharedURLSession{ static dispatch_once_t onceToken2; dispatch_once(&amp;amp;onceToken2, ^{ urlsession = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; }); return urlsession; }</description>
      <category>iOS</category>
      <pubDate>Thu, 19 Jan 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>细心的你是否也发现了 AFN 的内存泄漏的问题了呢.</p>
</blockquote>
<h3> 解决方法</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>将有问题的语句全部替换成单例后，再用 instruments 检查，再也没有出现泄漏的红叉了。O(∩_∩)O 哈哈~</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>WCDB漫谈</title>
      <link>https://oragekk.me/posts/iOS/source/WCDB.html</link>
      <guid>https://oragekk.me/posts/iOS/source/WCDB.html</guid>
      <source url="https://oragekk.me/rss.xml">WCDB漫谈</source>
      <description>前言 移动端的数据库选型一直是一个难题，直到前段时间看到了 WeMobileDev(微信前端团队)放出了第三个开源组件-WCDB WCDB(WeChat DataBase)是微信官方的移动端数据库组件，致力于提供一个高效、易用、完整的移动端存储方案 微信团队怎么说 基于 SQLCipher WCDB-iOS/Mac WCDB-Android 数据库损坏修复工具 WDBRepair</description>
      <category>iOS</category>
      <pubDate>Thu, 18 Jan 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>前言</p>
</blockquote>
<blockquote>
<p>移动端的数据库选型一直是一个难题，直到前段时间看到了 WeMobileDev(微信前端团队)放出了第三个开源组件-WCDB</p>
</blockquote>
<blockquote>
<p>WCDB(WeChat DataBase)是微信官方的移动端数据库组件，致力于提供一个高效、易用、完整的移动端存储方案</p>
</blockquote>
<h2> 微信团队怎么说</h2>
<ul>
<li>
<p>基于 SQLCipher</p>
</li>
<li>
<p>WCDB-iOS/Mac</p>
</li>
<li>
<p>WCDB-Android</p>
</li>
<li>
<p>数据库损坏修复工具 WDBRepair</p>
</li>
</ul>
<h3> 背景</h3>
<p>WCDB 的出现可以说解决了目前移动端数据库的几个难点</p>
<ul>
<li>
<p>首先在选型上，<strong>FMDB</strong>的 SQL 拼接、难以防止的 SQL 注入；<strong>CoreData</strong>虽然可以方便 ORM，但学习成本高，稳定性堪忧，而且多线程鸡肋；另外基于 C 语言的<strong>sqlite</strong>我想用的人也应该不多；除了上述关系型数据库之外然后还有一些其他的 Key-Value 型数据库，如我用过的 Realm，对于 ObjC 开发者来说，上手倒是没什么难度，但缺点显而易见，需要继承，入侵性强，对于单继承的 OC 来说这并不理想，而且对于集合类型不完全支持，复杂查询也比较无力。</p>
</li>
<li>
<p><strong>高效</strong></p>
<ul>
<li>
<p>多线程高并发：WCDB 支持多线程读与读、读与写并发执行，写与写串行执行。</p>
</li>
<li>
<p>批量写操作性能测试：</p>
<table>
<thead>
<tr>
<th>批量写</th>
<th style="text-align:center">ops/sec</th>
</tr>
</thead>
<tbody>
<tr>
<td>WCDB</td>
<td style="text-align:center">458000</td>
</tr>
<tr>
<td>FMDB</td>
<td style="text-align:center">161000</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p><strong>易用</strong> WCDB 支持一句代码即可将数据取出并组合为 object</p>
<ul>
<li>
<p>WINQ(WCDB 语言集成查询)：通过 WINQ，开发者无须为了拼接 SQL 的字符串而写一大坨胶水代码。</p>
</li>
<li>
<p>ORM(Object Relational Mapping)：WCDB 支持灵活、易用的 ORM。开发者可以很便捷地定义表、索引、约束，并进行增删改查操作。</p>
</li>
<li>
<p>像这样</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p><strong>完整</strong></p>
<ul>
<li>加密：WCDB 提供基于 SQLCipher 的数据库加密。</li>
<li>损坏修复：WCDB 内建了 Repair Kit 用于修复损坏的数据库。</li>
<li>WCDB 提供接口直接获取 SQL 的执行耗时，可用于监控性能。</li>
<li>反注入：WCDB 内建了对 SQL 注入的保护</li>
</ul>
</li>
</ul>
<h2> ORM</h2>
<p>在 WCDB 内，ORM（Object Relational Mapping）是指</p>
<ul>
<li>
<p>将一个 ObjC 的类，映射到数据库的表和索引；</p>
</li>
<li>
<p>将类的 property，映射到数据库表的字段；</p>
</li>
</ul>
<p>这一过程。通过 ORM，可以达到直接通过 Object 进行数据库操作，省去拼装过程的目的。</p>
<p>WCDB 通过内建的宏实现 ORM 的功能。如下</p>
<figure><img src="https://s2.ax1x.com/2019/11/15/Ma6EBF.png" alt="Ma6EBF.png" tabindex="0" loading="lazy"><figcaption>Ma6EBF.png</figcaption></figure>
<figure><img src="https://s2.ax1x.com/2019/11/15/Ma6FXT.png" alt="Ma6FXT.png" tabindex="0" loading="lazy"><figcaption>Ma6FXT.png</figcaption></figure>
<p><strong>PS</strong>:但我不建议这么做，首先要避免在.h 文件中引用&lt;WCDB/WCDB.h&gt;,因为你一旦引用，就需要改变.m <a href="http://xn--siqsr627c.mm" target="_blank" rel="noopener noreferrer">文件为.mm</a> 文件，因为 WCDB 是基于 objectiveC++；你可以使用 Category 特性将其隔离，在 category 中引用&lt;WCDB/WCDB.h&gt;，并遵守<strong>WCTTableCoding</strong>协议，使用<strong>WCDB_PROPERTY</strong>将声明绑定到数据库表的字段。然后在模型类中引用 category。达到不印象 Controller 和 View 的目的。这点官方 wiki 中也有提到，使用文件模板来创建。具体请见 Demo</p>
<p>对于一个已有的 ObjC 类，</p>
<ul>
<li>
<p>引用 WCDB 框架头文件#import &lt;WCDB/WCDB.h&gt;，并定义类遵循 WCTTableCoding 协议</p>
</li>
<li>
<p><strong>WCDB_PROPERTY</strong>用于在头文件中声明绑定到数据库表的字段。</p>
</li>
<li>
<p><strong>WCDB_IMPLEMENTATION</strong>，用于在类文件中定义绑定到数据库表的类。同时，该宏内实现了 WCTTableCoding。因此，开发者无须添加更多的代码来完成 WCTTableCoding 的接口</p>
</li>
<li>
<p><strong>WCDB_SYNTHESIZE</strong>，用于在类文件中定义绑定到数据库表的字段。</p>
</li>
<li>
<p><strong>WCDB_PRIMARY</strong>用于定义主键</p>
</li>
<li>
<p><strong>WCDB_PRIMARY_AUTO_INCREMENT</strong> 用于定义自增主键</p>
</li>
<li>
<p><strong>WCDB_INDEX</strong>用于定义索引</p>
</li>
<li>
<p><strong>WCDB_UNIQUE</strong>用于定义唯一约束</p>
</li>
<li>
<p><strong>WCDB_NOT_NULL</strong>用于定义非空约束</p>
</li>
</ul>
<h2> CRUD</h2>
<p>得益于 ORM 的定义，WCDB 可以直接进行通过 object 进行增删改查（CRUD）操作。</p>
<ul>
<li>
<p><strong>增</strong></p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>删</strong></p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>改</strong></p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>查</strong></p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h2> Transaction</h2>
<p>WCDB 内可通过两种方式执行 Transaction（事务），一是 runTransaction:接口</p>
<figure><a href="https://imgchr.com/i/Ma6AnU" target="_blank" rel="noopener noreferrer"><img src="https://s2.ax1x.com/2019/11/15/Ma6AnU.md.png" alt="Ma6AnU.md.png" tabindex="0" loading="lazy"></a><figcaption>Ma6AnU.md.png</figcaption></figure>
<p>这种方式要求数据库操作在一个 BLOCK 内完成，简单易用。</p>
<p>另一种方式则是获取 WCTTransaction 对象</p>
<figure><a href="https://imgchr.com/i/Ma6eAJ" target="_blank" rel="noopener noreferrer"><img src="https://s2.ax1x.com/2019/11/15/Ma6eAJ.md.png" alt="Ma6eAJ.md.png" tabindex="0" loading="lazy"></a><figcaption>Ma6eAJ.md.png</figcaption></figure>
<p>WCTTransaction 对象可以在类或函数间传递，因此这种方式也更具灵活性。</p>
<h2> WINQ</h2>
<p>WINQ（WCDB Integrated Query，音'wink'），即 WCDB 集成查询，是将自然查询的 SQL 集成到 WCDB 框架中的技术，基于 C++实现。</p>
<ul>
<li>免去拼接 SQL 字符串、防注入</li>
<li>借助 IDE 代码提示和编译器语法检查</li>
<li>对于一个已绑定 ORM 的类，可以通过 className.propertyName 的方式，获得数据库内字段的映射</li>
<li>WINQ 的接口包括但不限于：
<ul>
<li>一元操作符：+、-、!等</li>
<li>二元操作符：||、&amp;&amp;、+、-、*、/、|、&amp;、&lt;&lt;、&gt;&gt;、&lt;、&lt;=、==、!=、&gt;、&gt;=等</li>
<li>范围比较：IN、BETWEEN 等</li>
<li>字符串匹配：LIKE、GLOB、MATCH、REGEXP 等</li>
<li>聚合函数：AVG、COUNT、MAX、MIN、SUM 等</li>
<li>...</li>
</ul>
</li>
</ul>
<h3> 原理</h3>
<ul>
<li>初衷，适应 WCDB+ORM 解决 SQL 字符串的代码冗余和难以被编译器进行语法检查而造成的错误和时间浪费。SQL 字符串太容易被注入</li>
<li>SQL 抽象</li>
<li>封装常用操作，覆盖 80%的使用场景</li>
<li>暴露底层接口，适配剩余 20%的特殊情况</li>
<li>定义常用操作</li>
<li>特殊场景所暴露的底层接口，应该以什么形式存在？</li>
<li>SELECT、DISTINCT、ALL 等等大写字母是 keyword，属于 SQL 的保留字。</li>
<li>result-column、``table-or-subquery、expr 等等小写字母是 token。token 可以再进一步地展开其构成的语法规则。</li>
<li>将固定的 keyword，封装为函数名，作为连接。</li>
<li>将可以展开的 token，封装为类，并在类内实现其不同的组合。</li>
<li>在语法规则中，WHERE、LIMIT 等都接受 expr 作为参数。因此，不管 SQL 多么复杂，StatementSelect 也只接受 Expr 的参数。而其组合的能力，则在 Expr 类内实现。</li>
</ul>
<h3> 高级用法</h3>
<p><strong>as 重定向</strong></p>
<p>基于 ORM 的支持，我们可以从数据库直接取出一个 Object。然而，有时候需要取出并非是某个字段，而是有一些组合。例如：</p>
<figure><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9MctkzbxEw7JwfIhYBtueEWc1wT04kHF8su04FELDiaTjw6vmh0DmDibNqsQZZp61Dr1lAfPuyqYDgv2w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>这段代码从数据库中取出了消息的最新的修改时间，并以此将此时间作为消息的创建时间，新建了一个 message。这种情况下，就可以使用 as 重定向。</p>
<p>as 重定向，它可以将一个查询结果重定向到某一个字段，如下：</p>
<figure><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9MctkzbxEw7JwfIhYBtueEWc1ibXvcR7J18em4DydIzyQ2EVjcLCTcN9njspEph85UMnlGwzw9dSeZ3A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>通过 as(Message.createTime)的语法，将查询结果重新指向了 createTime。因此只需一行代码便可完成原来的任务。</p>
<p><strong>链式调用</strong></p>
<p>链式调用是指对象的接口返回一个对象，从而允许在单个语句中将调用链接在一起，而不需要变量来存储中间结果。</p>
<p>WCDB 对于增删改查操作，都提供了对应的类以实现链式调用</p>
<ul>
<li>WCTInsert</li>
<li>WCTDelete</li>
<li>WCTUpdate</li>
<li>WCTSelect</li>
<li>WCTRowSelect</li>
<li>WCTMultiSelect</li>
</ul>
<figure><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9MctkzbxEw7JwfIhYBtueEWc172epk1WSTvV3A8toxkjs2h23NLn5PgrVunTVVnahR15R0aEdLia0oPQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>where、orderBy、limit 等接口的返回值均为 self，因此可以通过链式调用，更自然更灵活的写出对应的查询。</p>
<p>传统的接口方便快捷，可以直接获得操作结果；链式接口则更具灵活性，开发者可以获取数据库操作的耗时、错误信息；也可以通过遍历逐个生成 object。</p>
<figure><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9MctkzbxEw7JwfIhYBtueEWc1LO9iaRVNx1YsIlZX6Xhy7ichve0CcsvBNibGaKaPgbZN9BvpticjBWVicqw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>WCDB 内同时支持这两种接口，优势互补，开发者可以根据需求，选择使用。</p>
<p><strong>多表查询</strong></p>
<p>SQLite 支持联表查询，在某些特定的场景下，可以起到优化性能、简化表结构的作用。</p>
<p>WCDB 同样提供了对应的接口，并在 ORM 的支持下，通过 WCTMultiSelect 的链式接口，可以同时从表中取出多个类的对象。</p>
<figure><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9MctkzbxEw7JwfIhYBtueEWc1OAQQtZ36iaibr6Oric1XNA9E9ribfJefdjrHTjy0e62LS1XxHialzibWOeJw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p><strong>类字段绑定</strong></p>
<p>在 ORM 中，我们通过宏，将 ObjC 类的 property 绑定为数据库的一个字段。但并非所有 property 的类型都能绑定到字段。</p>
<p>WCDB 内置支持的类型有：</p>
<ul>
<li>const char*的 C 字符串类型</li>
<li>包括但不限于 int、unsigned、long、unsigned long、long long、unsigned long long 等所有基于整型的 C 基本类型</li>
<li>包括但不限于 float、double、long double 等所有基于浮点型的 C 基本类型</li>
<li>enum 及所有基于枚举型的 C 基本类型</li>
<li>NSString、NSMutableString</li>
<li>NSData、NSMutableData</li>
<li>NSArray、NSMutableArray</li>
<li>NSDictionary、NSMutableDictionary</li>
<li>NSSet、NSMutableSet</li>
<li>NSValue</li>
<li>NSDate</li>
<li>NSNumber</li>
<li>NSURL</li>
</ul>
<p>然而，内置支持得再多，也不可能完全覆盖开发者所有的需求。因此 WCDB 支持开发者自定义类字段绑定。</p>
<p>类只需实现 WCTColumnCoding 协议，即可支持绑定。</p>
<figure><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9MctkzbxEw7JwfIhYBtueEWc1Nl0xSkc8HpEKr5ynDEEUver6lhNGBgtAAR9UicicqdsREmGnicOLfbniag/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<ul>
<li>columnTypeForWCDB 接口定义类对应数据库中的类型</li>
<li>unarchiveWithWCTValue:接口定义从数据库类型反序列化到类的转换方式</li>
<li>archivedWCTValue 接口定义从类序列化到数据库类型的转换方式</li>
</ul>
<h2> 数据库修复</h2>
<ul>
<li>官方的 Dump 恢复方案 - 遍历 sqlite_master 表，将未损坏的表和已损坏的前半部分读取出来将 dump 出来的 SQL 语句逐行执行，最终可以得到一个等效的新 DB<br>
功率约为 30%。 - 第一页就损坏后续无法读取</li>
<li>备份恢复方案
<ul>
<li>COPY</li>
<li>在 DB 完好的时候执行.dump</li>
<li>Backup API： SQLite 自身提供的一套备份机制，按 Page 为单位复制到新 DB， 支持热备份。</li>
<li>最终选择 Dump + 压缩，恢复成功率达到 72%</li>
</ul>
</li>
<li>解析 B-tree 恢复方案（RepairKit）
<ul>
<li>成功率约为 78%</li>
</ul>
</li>
<li>不同方案的组合
<ul>
<li>RepairKit 尝试恢复最新数据</li>
<li>备份恢复 遇到错误填补漏缺</li>
<li>Dump 最后的尝试</li>
</ul>
</li>
</ul>
<h2> For Android</h2>
<ul>
<li>
<p>基本功能</p>
<ul>
<li>基于 SQLCipher 的数据库加密</li>
<li>使用连接池实现并发读写</li>
<li>内建 Repair Kit 可用于修复损坏数据</li>
<li>针对占用空间大小优化的数据库备份/恢复功能</li>
<li>日志输出重定向以及性能跟踪接口</li>
<li>内建用于全文搜索的 mmicu FTS3/4 分词器</li>
</ul>
</li>
<li>
<p>接入与迁移</p>
<ul>
<li>WCDB for Android 可通过 Maven 或 AAR 包引用，API 接口与 Android SDK 非常相近， 所以将已有的 App 迁移到 WCDB 是相当容易的。</li>
<li><a href="https://github.com/Tencent/wcdb/wiki/Android%E6%8E%A5%E5%85%A5%E4%B8%8E%E8%BF%81%E7%A7%BB" target="_blank" rel="noopener noreferrer">Android 接入与迁移</a></li>
</ul>
</li>
<li>
<p>数据库修复</p>
<ul>
<li><a href="https://github.com/Tencent/wcdb/wiki/Android%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%AE%E5%A4%8D" target="_blank" rel="noopener noreferrer">Android 数据库修复</a></li>
</ul>
</li>
<li>
<p>从源码编译</p>
<ul>
<li>你可以使用预编译的依赖库（OpenSSL crypto 和 SQLCipher）来编译 WCDB for Android， 使用 Gradle 或 Android Studio 皆可。Android Studio 请导入 android 目录作为 Root Project。</li>
<li>编译 WCDB 需要安装 Android NDK r11c 或以上，并在 android/local.properties 上配置好 SDK 与 NDK 路径。Android Studio 一般会帮你配置好。</li>
<li>如果你需要自己编译 OpenSSL 等依赖项，你需要一个 Bash 环境（Windows 可以安装 Cygwin 或 MSys）、target 为本机的 C 编译器（如 GCC）、Perl 5 以及 Tcl。之后执行下面命令即可编译依赖项。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考资料</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/OrageKK/WCDB_DEMO" target="_blank" rel="noopener noreferrer">Demo</a></p>
</blockquote>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/1XxcrsR2HKam9ytNk8vmGw" target="_blank" rel="noopener noreferrer">微信移动端数据库组件 WCDB 系列（一）-iOS 基础篇</a></p>
</blockquote>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/Ln7kNOn3zx589ACmn5ESQA" target="_blank" rel="noopener noreferrer">微信移动端数据库组件 WCDB 系列（二） — 数据库修复三板斧</a></p>
</blockquote>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/FY2Y9x1_8TcXHDgTRXcTDA" target="_blank" rel="noopener noreferrer">微信移动端数据库组件 WCDB 系列（三） — WINQ 原理篇</a></p>
</blockquote>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/NFnYEXSxAaHBqpi7WofSPQ" target="_blank" rel="noopener noreferrer">微信移动数据库组件 WCDB（四） — Android 特性篇</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://s2.ax1x.com/2019/11/15/Ma6EBF.png" type="image/png"/>
    </item>
    <item>
      <title>YYMemoryCache 源码分析</title>
      <link>https://oragekk.me/posts/iOS/source/YYMemoryCache.html</link>
      <guid>https://oragekk.me/posts/iOS/source/YYMemoryCache.html</guid>
      <source url="https://oragekk.me/rss.xml">YYMemoryCache 源码分析</source>
      <description>YYMemoryCache 源码分析 提示 YYMemoryCache 是内存缓存，所以存取速度非常快，主要用到两种数据结构的 LRU 淘汰算法 LRU 淘汰算法 LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 最常见的实现是使用一个链表保存缓存数据 【命中率】 当存在热点数据时，LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧下降，缓存污染情况比较严重。 Cache 的容量是有限的，当 Cache 的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。LRU 法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律</description>
      <category>iOS</category>
      <pubDate>Fri, 26 Apr 2019 16:08:25 GMT</pubDate>
      <content:encoded><![CDATA[<h1> YYMemoryCache 源码分析</h1>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>YYMemoryCache 是内存缓存，所以存取速度非常快，主要用到两种数据结构的 LRU 淘汰算法</p>
</div>
<ol>
<li>
<p>LRU 淘汰算法</p>
<blockquote>
<p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>最常见的实现是使用一个链表保存缓存数据</p>
<p>【命中率】</p>
<p>当存在热点数据时，LRU 的效率很好，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧下降，缓存污染情况比较严重。</p>
<p>Cache 的容量是有限的，当 Cache 的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。LRU 法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律</p>
</blockquote>
</li>
</ol>
<!-- more -->
<ol start="2">
<li>
<p>数据结构</p>
<ul>
<li>双向链表 (Doubly Linked List)</li>
<li>哈希表 (Dictionary)</li>
</ul>
</li>
<li>
<p>缓存操作</p>
<ul>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
</li>
<li>
<p>分析图</p>
<figure><a href="https://cuntuku.com/image/bpM38" target="_blank" rel="noopener noreferrer"><img src="https://storage6.cuntuku.com/2019/04/27/bpM38.png" alt="bpM38.png" tabindex="0" loading="lazy"></a><figcaption>bpM38.png</figcaption></figure>
</li>
<li>
<p>YYMemoryCache.m 里的两个分类</p>
<ol>
<li>
<p>链表节点 <code>_YYLinkedMapNode</code></p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>链表 <code>_YYLinkedMap</code></p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
</li>
<li>
<p>链表插入、查找、替换操作实现</p>
<ul>
<li>
<p>添加节点到链表头节点</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://upload-images.jianshu.io/upload_images/295346-1cb03d629ecbf2fa.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>移动当前节点到链表头节点</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://upload-images.jianshu.io/upload_images/295346-682e8396c2d9e092.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>移除节点</p>
<ul>
<li>
<p>移除指定节点</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>移除尾节点</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>移除所有缓存</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>图片引用自<a href="https://www.jianshu.com/p/492c3c3a0485" target="_blank" rel="noopener noreferrer">YYCache 源码分析(二)</a> 感谢作者</p>
<p>ps 未完待续……</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://storage6.cuntuku.com/2019/04/27/bpM38.png" type="image/png"/>
    </item>
    <item>
      <title>深入理解swift中闭包的捕捉语义</title>
      <link>https://oragekk.me/posts/iOS/swift/swift%E6%8D%95%E8%8E%B7%E8%AF%AD%E4%B9%89.html</link>
      <guid>https://oragekk.me/posts/iOS/swift/swift%E6%8D%95%E8%8E%B7%E8%AF%AD%E4%B9%89.html</guid>
      <source url="https://oragekk.me/rss.xml">深入理解swift中闭包的捕捉语义</source>
      <description>参考链接：losures Capture Semantics, Part 1: Catch them all! 概述 原文中先定义一个 Pokemon 类 class Pokemon: CustomDebugStringConvertible { let name: String init(name: String) { self.name = name } var debugDescription: String { return &amp;quot;\(name)&amp;gt;&amp;quot; } deinit { print(&amp;quot;\(self) escaped!&amp;quot;) } }</description>
      <category>Swift</category>
      <pubDate>Thu, 19 Oct 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>参考链接：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgold.xitu.io%2Fentry%2F5796308479bc440066443c8e" target="_blank" rel="noopener noreferrer">losures Capture Semantics, Part 1: Catch them all!</a></p>
</blockquote>
<h2> 概述</h2>
<p>原文中先定义一个 Pokemon 类</p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>延时执行的闭包</p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 默认捕捉语法</h2>
<p>在 swift 中默认的捕捉语法是:<strong>被捕获的变量在闭包被执行的时候才被定值</strong><a href="https://link.juejin.im/?target=http%3A%2F%2Falisoftware.github.io%2Fswift%2Fclosures%2F2016%2F07%2F25%2Fclosure-capture-1%2F%23fn%3Ablock-modifier" target="_blank" rel="noopener noreferrer">1</a><br>
. 我们能说它捕获到了这个变量的<em>引用</em>(或者 &nbsp;<em>指针</em>)。</p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个闭包会在 demo1() 方法函数执行完成后 1 秒后被执行，并且我们已退出了方法函数的作用域… 当然 Pokemon 仍然是存在的，当这个代码块在下一个 1 秒后再次被执行的时候！</p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，当这个闭包被 GCD 执行后，这个闭包自行释放，就是 Pokemon 内部的 init 方法执行的时候。<br>
此处 Swift 自动捕获到这个 pokemon 变量，当 demo1 方法执行完成并且释放掉的时候，1s 之后闭包被执行的时候还是捕获到了 pokemon</p>
<h2> 被捕获到的变量都被执行的时候定值</h2>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此处在创建了 test1 闭包之后，我们改变了 name 的值，打印结果是 Aby。说明此处 Swift 捕获到的是 name 这个变量的引用(指针)</p>
<p>原文中的例子使用了方法，并做了延时，大意在说明，函数被释放之后的延时闭包中，闭包依然捕获了变量的新值，而不是旧值，说明此处它捕获的是变量的引用，而非变量本身的值</p>
<p>这个在值类型中也可行例如 Int</p>
<h2> 修改变量的值</h2>
<p>如果捕获的值是一个 &nbsp;var 并不是一个 &nbsp;let，你还是可以修改这个值 &nbsp;<strong>在闭包内部</strong><a href="https://link.juejin.im/?target=http%3A%2F%2Falisoftware.github.io%2Fswift%2Fclosures%2F2016%2F07%2F25%2Fclosure-capture-1%2F%23fn%3Aobjc_block_modify" target="_blank" rel="noopener noreferrer">2</a></p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此处打印结果为 Jack，再一次印证，闭包内捕获的是变量 name 的引用，因为它可以被改变，而不是一个静态的拷贝</p>
<h2> 捕获一个作为静态 copy 的变量</h2>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想要在闭包<strong>创建</strong>的时候捕获变量的值，而不是仅仅当闭包执行的时候去获取它的定值，你能使用一个<strong>捕获列表</strong>。<br>
<strong>捕获列表</strong>可以被编码在方括号的中间，在闭包开括号的右边（并且在闭包的参数 / 或者有返回值之前）<a href="https://link.juejin.im/?target=http%3A%2F%2Falisoftware.github.io%2Fswift%2Fclosures%2F2016%2F07%2F25%2Fclosure-capture-1%2F%23fn%3Ain-keyword" target="_blank" rel="noopener noreferrer">3</a><br>
。<br>
为了在闭包创建的时候，捕获变量的值（而不是这个变量本身的引用），你可以使用 &nbsp;[形参 = 实参]</p>
<p>你也可以这样写，不过我觉得不够清晰</p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的捕获列表大概相当于文中的如下代码</p>
<div class="language-swift line-numbers-mode" data-ext="swift"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就好像，如果我们创建一个中间变量去指向同一个 pokemon，并且捕获这个变量<br>
事实上，使用这个捕获列表和上面的代码一样… 除了这个 pokemonCopy 的中间变量是闭包的局部变量，并且将只能在闭包内被访问。</p>
<h2> 总结</h2>
<ul>
<li>Swift 闭包捕获了一个对外部变量需要在闭包内部使用的一个引用。</li>
<li>那个引用在闭包<strong>被执行</strong>的时候获得定值。</li>
<li>作为对这个变量的引用的捕捉（并且不是这个变量自身），你能从闭包内部修改这个变量的值（当然，如果这个变量被声明为 var 并且不是 let）</li>
<li>相反，你能告诉 Swfit 在闭包创建的时候对这个变量定值 并且把这个值保存在本地的一个静态变量中，而不是捕获变量本身。你可以通过使用捕获列表(中括号)，在括号内表达。</li>
</ul>
<p>注意：因为捕获列表是一个列表你还可以放多个参数，用逗号隔开，像数组一样</p>
<blockquote>
<p>最后感谢原文作者</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>NSError</title>
      <link>https://oragekk.me/posts/iOS/system/NSError.html</link>
      <guid>https://oragekk.me/posts/iOS/system/NSError.html</guid>
      <source url="https://oragekk.me/rss.xml">NSError</source>
      <description>前言 整理一下在iOS开发中NSError的错误代码 NSError NSError是系统错误信息类 初始化方法两个 // domain 不能为空 dict可以为空 - (instancetype)initWithDomain:(NSErrorDomain)domain code:(NSInteger)code userInfo:(nullable NSDictionary *)dict; + (instancetype)errorWithDomain:(NSErrorDomain)domain code:(NSInteger)code userInfo:(nullable NSDictionary *)dict;</description>
      <category>iOS</category>
      <pubDate>Thu, 31 May 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>前言</p>
<p>整理一下在iOS开发中NSError的错误代码</p>
</blockquote>
<h2> NSError</h2>
<p>NSError是系统错误信息类</p>
<p>初始化方法两个</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 属性</h3>
<ul>
<li>
<p>@property (readonly) NSInteger code;//错误代码</p>
</li>
<li>
<p>@property (readonly, copy) NSDictionary *userInfo;//错误信息</p>
</li>
<li>
<p>@property (readonly, copy) NSString *localizedDescription;//获取本地化描述</p>
</li>
<li>
<p>@property (nullable, readonly, copy) NSString *localizedFailureReason;//获取失败原因</p>
</li>
<li>
<p>@property (nullable, readonly, copy) NSString *localizedRecoverySuggestion;//获取恢复建议</p>
</li>
<li>
<p>@property (nullable, readonly, copy) NSArray&lt;NSString *&gt; *localizedRecoveryOptions;本地恢复建议</p>
</li>
<li>
<p>@property (nullable, readonly, strong) id recoveryAttempter;</p>
</li>
<li>
<p>@property (nullable, readonly, copy) NSString *helpAnchor;</p>
</li>
</ul>
<h3> NSError错误code对照表</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 有关网络请求失败的解释</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>NSOperatioin</title>
      <link>https://oragekk.me/posts/iOS/system/NSOperation%E5%92%8CNSOPerationQueue.html</link>
      <guid>https://oragekk.me/posts/iOS/system/NSOperation%E5%92%8CNSOPerationQueue.html</guid>
      <source url="https://oragekk.me/rss.xml">NSOperatioin</source>
      <description>一. NSOperatioin 1.目的 开启线程 提供一些 GCD 不具备的功能 OC 框架,内部封装的是 GCD 2.区别 GCD 执行效率高于 NSOperation NSOperation 提供了一些 GCD 中不具备的功能(暂停/恢复/取消)---管理操作-NSOperation 的高级用法 3.NSOperation 本身是一个抽象类不可以直接使用,实际开发中使用其子类</description>
      <category>iOS</category>
      <pubDate>Mon, 26 Dec 2016 13:39:59 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<h1> 一. NSOperatioin</h1>
</blockquote>
<h4> 1.目的</h4>
<ul>
<li>开启线程</li>
<li>提供一些 GCD 不具备的功能</li>
<li>OC 框架,内部封装的是 GCD</li>
</ul>
<h4> 2.区别</h4>
<ul>
<li>GCD 执行效率高于 NSOperation</li>
<li>NSOperation 提供了一些 GCD 中不具备的功能(暂停/恢复/取消)---管理操作-NSOperation 的高级用法</li>
</ul>
<h4> 3.NSOperation 本身是一个抽象类不可以直接使用,实际开发中使用其子类</h4>
<ul>
<li>
<p>苹果提供了两个原生子类</p>
<ul>
<li>NSInvocationOperation<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>NSBlockOperation 将操作封装在 block 中<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>缺点:</p>
<ul>
<li>有过在主队列执行操作,有一个操作在主线程执行(随机),其他操作在子线程执行 - 如果直接调用 start 方法执行操作,无法确定每一个操作在哪条线程执行</li>
<li>一般不要追加操作,除非就是在非主队列执行</li>
</ul>
</li>
<li>
<p>操作依赖 (串行/线程同步技术)添加数量不要太多</p>
<ul>
<li>对于不同的操作队列中的操作依然有效</li>
<li>添加操作依赖要在添加操作队列之前</li>
<li>只能对添加在操作队列的操作添加依赖</li>
<li>一定不要添加循环依赖</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<h1> 一. NSOperatioinQueue</h1>
</blockquote>
<h4> 1.主队列</h4>
<ul>
<li>放在主队列中的操作,都在主线程执行</li>
</ul>

<h4> 2.非主队列</h4>
<ul>
<li>放在非主队列中的操作,都在子线程执行</li>
</ul>

<h4> 3.一般定义成全局属性</h4>
<hr>
<h4> 4.每一个操作都有一个 start 方法,用来在当前线程执行</h4>
<ul>
<li>
<p>本质:将操作添加到操作队列之后,内部会自动调用内部 start 方法,操作就会自动执行</p>
</li>
<li>
<p>主队列和非主队列决定操作在哪条线程执行(在哪条线程启动操作的 start 方法)</p>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"></div></div>]]></content:encoded>
    </item>
    <item>
      <title>减小iOS-App或者静态库体积</title>
      <link>https://oragekk.me/posts/iOS/system/Reduced-App-%20volume.html</link>
      <guid>https://oragekk.me/posts/iOS/system/Reduced-App-%20volume.html</guid>
      <source url="https://oragekk.me/rss.xml">减小iOS-App或者静态库体积</source>
      <description>把打包好的.ipa 文件的后缀改为.zip 并解压。右键.appbundle 选择显示包内容。有些情况下，大一点的文件压缩后反而比小一点的文件压缩后的体积小，而我们真正关心的时候解压后的真实体积，所以一定要解压里面的资源文件，看解压后的 size。从 APP Store 下载的.ipa 文件要比自己本地打包的要大，因为 APP Store 对 ipa 包又做了加密处理。Xcode 的 Organizer window 的 Estimate Size 功能能估计本地打包文件从 APP Store 下载时的大小。根据优化的 28 定律和常识，首先当然是多媒体资源的体积啦。</description>
      <category>iOS</category>
      <pubDate>Fri, 04 Nov 2016 18:11:56 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="https://zero-space.s3.amazonaws.com/photos/2e6cc210-e9a6-4a0f-9c05-2c4056a982acx840.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>把打包好的.ipa 文件的后缀改为.zip 并解压。右键.appbundle 选择显示包内容。有些情况下，大一点的文件压缩后反而比小一点的文件压缩后的体积小，而我们真正关心的时候解压后的真实体积，所以一定要解压里面的资源文件，看解压后的 size。从 APP Store 下载的.ipa 文件要比自己本地打包的要大，因为 APP Store 对 ipa 包又做了加密处理。Xcode 的 Organizer window 的 Estimate Size 功能能估计本地打包文件从 APP Store 下载时的大小。根据优化的 28 定律和常识，首先当然是多媒体资源的体积啦。</p>
</blockquote>
<h2> 图片</h2>
<p>压缩图片 不重要的图片可适当采用 8bit PNG 图片 1.什么是矢量图 矢量图是由计算机的算法产生的，可以无限放大或缩小，不会有任何损失，通常由矢量软件制作。 2.什么是位图 位图是由一个一个的小色块组成，放大后会看到那些小色块，同一面积内小色块越多，分辨率就越高。 3.矢量图的优缺点 可以无限放大或缩小，不会影响图像素质，文件体积较小，编辑灵活。缺点是表达的色彩层次不清，整体观感效果不如位图 4.位图的优缺点 不能放太大，减少文件分辨率后会影响图片质量，图片战胜空间较大，优点是能很细腻地表达图片的效果，图片表达效果非常好 5.什么情况下用位图，什么情况下用矢量图 一些对图片要求高的用位图，例如照片。其他的尽量用矢量图。例如文字、表格、卡通图片等</p>
<ul>
<li>
<p>去掉无用的图片</p>
</li>
<li>
<p>用代码绘制简单的纯色图片 &nbsp;<a href="http://www.jianshu.com/p/d01110c80495" target="_blank" rel="noopener noreferrer">用 Sketch 和 PaintCode 快速得到绘制代码</a></p>
</li>
<li>
<p>如果不需要使用透明，可以用 jpeg 代替 PNG。jpeg 减少了些效率但更加小。需权衡性能，大小。</p>
</li>
<li>
<p>对 32 位的图片，尽肯能的使用高压缩率，使用 PS 的“Save For Web”功能，可以有效的减小 JPEG 和 PNG 图片的尺寸。 默认情况下，在 build 时，PNG 图像就被<a href="https://developer.apple.com/library/ios/qa/qa1681/_index.html" target="_blank" rel="noopener noreferrer">pngcrush</a>压缩。</p>
</li>
</ul>
<h2> 音频</h2>
<ul>
<li>压缩音频，<a href="https://developer.apple.com/videos/wwdc/2011/?id=404" target="_blank" rel="noopener noreferrer">尽可能使用 AAC 或者 MP3 格式，并且使用一个较低的码率。通常 44.1khz 的码率有点浪费，降低一定的码率也不会丢失多少音质</a></li>
</ul>
<h2> 视频</h2>
<ul>
<li>视频也可以使用类似于音频的处理方法，音视频的压缩可以很大程度的压缩，但是要注意压缩的格式，是不是会增加编解码的负担，这要权衡考虑。</li>
</ul>
<h2> Assets</h2>
<ul>
<li>检查 bundle 中的无用文件，不要打包到 app 或者静态库中。可以点击文件，在右侧的 file inspector 里面的 target membership 中取消勾选；或者在 build phase 里面的 Copy Bundle Resources 中去掉。</li>
<li>确定 dead code（代码被定义但从未被调用）被剥离，build setting 里 DEAD_CODE_STRIPPING = YES。 去掉冗余的代码，即使一点冗余代码，编译后体积也是很可观的。</li>
</ul>
<h2> 编译设置</h2>
<ul>
<li>
<p><code>Optimization Level</code>设置为<code>Fastest, Smallest [-Os]</code>，<code>Strip Debug</code><br>
<code>Symbols During Copy</code>设置为<code>YES (COPY_PHASE_STRIP = YES)</code><br>
这样会减小接近一半的体积，但是在 release 版本，这些貌似是默认的配置，但是不妨也检查一下。 此外在 debug 版本最好在完成开发测试后，设置成这种模式，重新测试一遍，因为不同的编译设置可能会掩盖一些 bug。</p>
</li>
<li>
<p>设置<code>IOS_DEPLOYMENT_TARGET</code> 为想要运行系统的最低版本</p>
</li>
<li>
<p>设置需要的 arm&nbsp;<a href="http://lib.csdn.net/base/16" target="_blank" rel="noopener noreferrer">架构</a>，设置 <code>ARCHS = arm64</code>可以消除 armv6 架构，潜在的减少近一半的容量。<br>
<a href="https://www.innerfence.com/howto/apple-ios-devices-dates-versions-instruction-sets" target="_blank" rel="noopener noreferrer">iOS Devices: ARM，尺寸，像素一览表</a><br>
1，如果想自己的 app 在各个机器都能够最高效率的运行，则需要将 Build Active Architecture Only 改为 NO,Valid architectures 选择对应的指令集：armv7 armv7s arm64。这个会为各个指令集编译对应的代码，因此最后的 ipa 体积基本翻了 3 倍,Release 版本必须 NO。<br>
2，如果想让 app 体积保持最小，则现阶段应该选择 Valid architectures 为 armv7,这样 Build Active Architecture Only 选 YES 或 NO 就无所谓了</p>
</li>
</ul>
<h2> 其他</h2>
<ul>
<li>将应用的中一些数据，如长字符串、表格等移到外部文件中，不要放在代码里面，这样能减小一些体积，因为外部文件的压缩率要比应用中的数据压缩率高。</li>
</ul>
<h2> 编译选项</h2>
<ol>
<li>编译器优化级别<br>
Build Settings-&gt;Optimization Level 有几个编译优化选项，release 版应该选择 Fastest, Smalllest，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。</li>
<li>去除符号信息<br>
Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在 release 版本应该设为 yes，可以去除不必要的调试符号。Symbols Hidden by Default 会把所有符号都定义成”private extern”，详细信息见<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829-97021-TPXREF121" target="_blank" rel="noopener noreferrer">官方文档</a>。<br>
这些选项目前都是 XCode 里 release 的默认选项，但旧版 XCode 生成的项目可能不是，可以检查一下。其他优化还可以参考官方文档—<a href="https://developer.apple.com/legacy/library/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.pdf" target="_blank" rel="noopener noreferrer">CodeFootprint.pdf</a></li>
</ol>
<h3> 第三方库统计</h3>
<p>项目里会引入很多第三方静态库，如果能知道这些第三方库在可执行文件里占用的大小，就可以评估是否值得去找替代方案去掉这个第三方库。我们可以从 linkmap 中统计出这个信息，对此写了个 node.js 脚本，可以通过 linkmap 统计每个.o 目标文件占用的体积和每个.a 静态库占用的体积，<a href="https://gist.github.com/bang590/8f3e9704f1c2661836cd" target="_blank" rel="noopener noreferrer">详见这里</a>(需翻墙)。</p>
<h3> ARC-&gt;MRC</h3>
<p>有人提出用 ARC 写的代码编译出来的可执行文件是会比用 MRC 大的，原因大致是 ARC 代码会在某些情况多出一些 retain 和 release 的指令，例如调用一个方法，它返回的对象会被 retain，退出作用域后会被 release，MRC 就不需要，汇编指令变多，机器码变多，可执行文件就变大了。还有其他细节实现的区别，先不纠结了。<br>
那用 ARC 究竟会增大多少体积？我觉得从汇编指令的增多减少去算是很难算准确的，这东西涉及细节太多，还是得从统计的角度计算。做了几个对比试验，统计了几个同时支持 ARC/MRC 的开源项目在开启/关闭 ARC 的情况下<strong>TEXT 代码段的大小对比。只对比</strong>TEXT 代码段是因为：<br>
ARC 对可执行文件大小的影响几乎都是在代码段<br>
可执行文件会进行某种对齐，例如有些段在不足 32K 的时候填充 0 直到对齐 32K，若用可执行文件大小对比结果可能是对齐后的，不准确。</p>
<p>实验数据：</p>
<table>
<thead>
<tr>
<th>-------</th>
<th style="text-align:center">MBProgressHUD</th>
<th style="text-align:center">SDWebImage</th>
<th style="text-align:center">FMDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>开启 ARC</td>
<td style="text-align:center">19532</td>
<td style="text-align:center">24424</td>
<td style="text-align:center">29056</td>
</tr>
<tr>
<td>关闭 ARC</td>
<td style="text-align:center">17648</td>
<td style="text-align:center">22575</td>
<td style="text-align:center">25848</td>
</tr>
<tr>
<td>对比</td>
<td style="text-align:center">↓9.6%</td>
<td style="text-align:center">↓7.5%</td>
<td style="text-align:center">↓11%</td>
</tr>
</tbody>
</table>
<p>结果是 ARC 大概会使代码段增加 10%的 size，考虑代码段占可执行文件大约有 80%，估计对整个可执行文件的影响会是 8%。<br>
可以评估一下 8%的体积下降是不是值得把项目里某些模块改成 MRC，这样程序的维护成本上升了，一般不到特殊情况不建议这么做。</p>
<h3> 无用代码</h3>
<p>在项目里新建一个类，给它添加几个方法，但不要在任何地方 import 它，build 完项目后观察 linkmap，你会发现这个类还是被编译进可执行文件了。<br>
按 C++的经验，没有被使用到的类和方法编译器都会优化掉，不会编进最终的可执行文件，但 object-c 不一样，因为 object-c 的动态特性，它可以通过类和方法名反射获得这个类和方法进行调用，所以就算在代码里某个类没被使用到，编译器也没法保证这个类不会在运行时通过反射去调用，所以只要是在项目里的文件，无论是否又被使用到都会被编译进可执行文件。<br>
对此我们可以通过脚本，遍历整个项目的文件，找出所有没有被引用的类文件和没有被调用的方法，在保证没有其他地方动态调用的情况下把它们去掉。如果整个项目历时很长，历时代码遗留较多，这个清理对可执行文件省出的空间还是挺可观的。</p>
<h3> 类/方法名长度</h3>
<p>观察 linkmap 可以发现每个类和方法名都在__cstring 段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的，原因还是 object-c 的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c 对象模型会把类/方法名字符串都保存下来。<br>
对此我们可以考虑在编译前把所有类和方法名进行混淆，跟压缩 js 一样，把长名字替换成短名字，这样做的好处除了缩小体积外，还对安全性有很大提升，别人拿到可执行文件对它 class-dump 出来的结果都是混淆后的类和方法名，就无法从类和方法名中猜出某个方法是做什么的，就难以挂钩子进行 hack。不过这样做有个缺点，就是 crash 堆栈反解出来的堆栈方法名会是混淆后的，需要再加一层混淆-&gt;原名的转换，实现和使用成本有点高。<br>
实际上这部分占用的长度比较小，中型项目也就几百 K，对安全性要求高的情况可以试试。</p>
<h3> 冗余字符串</h3>
<p>代码上定义的所有静态字符串都会记录在在可执行文件的__cstring 段，如果项目里 Log 非常多，这个空间占用也是可观的，也有几百 K 的大小，可以考虑清理所有冗余的字符串。另外如果有特别长的字符串，建议抽离保存成静态文件，因为 AppStore 对可执行文件加密导致压缩率低，特别长的字符串抽离成静态资源文件后压缩率会比在可执行文件里高很多。</p>
<h3> CheckList</h3>
<p>最后把缩减<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener noreferrer">iOS</a>安装包大小的各种方法列出来做了张 CheckList 图：<br>
<img src="http://upload-images.jianshu.io/upload_images/2076247-dde8e96bdd40396b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<p>参考文献：<a href="http://blog.cnbang.net/tech/2296/" target="_blank" rel="noopener noreferrer">http://blog.cnbang.net/tech/2296/</a></p>
]]></content:encoded>
      <enclosure url="https://zero-space.s3.amazonaws.com/photos/2e6cc210-e9a6-4a0f-9c05-2c4056a982acx840.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>WKWebView拦截URL</title>
      <link>https://oragekk.me/posts/iOS/system/WKWebView-URL.html</link>
      <guid>https://oragekk.me/posts/iOS/system/WKWebView-URL.html</guid>
      <source url="https://oragekk.me/rss.xml">WKWebView拦截URL</source>
      <description>本文介绍使用 WKWebView 拦截 url 进行原生界面跳转 3.gif 使用代理方法 decidePolicyForNavigationAction - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { // 获取完整url并进行UTF-8转码 NSString *strRequest = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding]; if ([strRequest hasPrefix:@&amp;quot;app://&amp;quot;]) { // 拦截点击链接 [self handleCustomAction:strRequest]; // 不允许跳转 	decisionHandler(WKNavigationActionPolicyCancel); }else { 	// 允许跳转 decisionHandler(WKNavigationActionPolicyAllow); } }</description>
      <category>iOS</category>
      <pubDate>Sat, 27 May 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文介绍使用 WKWebView 拦截 url 进行原生界面跳转</p>
</blockquote>
<figure><img src="https://storage1.cuntuku.com/2017/05/27/3.gif" alt="3.gif" tabindex="0" loading="lazy"><figcaption>3.gif</figcaption></figure>
<ul>
<li>使用代理方法 decidePolicyForNavigationAction</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>自定义方法传过来 url 进行判断，需要 html 元素本身就有跳转链接，才可以拦截，如没有，拦截不到。下文 app://xxx 链接为自定义链接</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://storage1.cuntuku.com/2017/05/27/3.gif" type="image/gif"/>
    </item>
    <item>
      <title>WKWebView使用及自适应高度</title>
      <link>https://oragekk.me/posts/iOS/system/WKWebView.html</link>
      <guid>https://oragekk.me/posts/iOS/system/WKWebView.html</guid>
      <source url="https://oragekk.me/rss.xml">WKWebView使用及自适应高度</source>
      <description>记录一下 iOS8 之后的新控件 WKWebView，用以替代之前的 UIWebView，因为需求是在 TableView 的 Cell 中放一个 WebView。就产生了滑动手势冲突，为了解决这个问题就需要让 webView 高度自适应 一、新特性 在性能、稳定性、功能方面有很大的提升，最明显的就是内存占用降低了很多。 允许 JavaScript 的 Nitro 库加载并使用（UIWebView 中限制） 支持了更多的 HTML5 特性； 高达 60fps 的滚动刷新率以及内置手势（支持右滑返回）； 将 UIWebViewDelegate 与 UIWebView 重构成了 14 类与 3 个协议（查看苹果官方文档）；</description>
      <category>iOS</category>
      <pubDate>Fri, 26 May 2017 15:47:40 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>记录一下 iOS8 之后的新控件 WKWebView，用以替代之前的 UIWebView，因为需求是在 TableView 的 Cell 中放一个 WebView。就产生了滑动手势冲突，为了解决这个问题就需要让 webView 高度自适应</p>
</blockquote>
<h2> 一、新特性</h2>
<ul>
<li>在性能、稳定性、功能方面有很大的提升，最明显的就是内存占用降低了很多。</li>
<li>允许 JavaScript 的 Nitro 库加载并使用（UIWebView 中限制）</li>
<li>支持了更多的 HTML5 特性；</li>
<li>高达 60fps 的滚动刷新率以及内置手势（支持右滑返回）；</li>
<li>将 UIWebViewDelegate 与 UIWebView 重构成了 14 类与 3 个协议（<a href="https://developer.apple.com/reference/webkit" target="_blank" rel="noopener noreferrer">查看苹果官方文档</a>）；</li>
</ul>
<h2> 二、初始化</h2>
<ul>
<li>首先需要引入 WebKit 库</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>采用 configuration 的方式初始化（可选）</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>加载网页</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、WKWebView 代理方法</h2>
<p>1.WKNavigationDelegate</p>
<p>该代理提供的方法，可以用来追踪加载过程（页面开始加载、加载完成、加载失败）、决定是否执行跳转。</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>页面跳转的代理方法有三种，分为（收到跳转与决定是否跳转两种）</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.WKUIDelegate</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>剩下三个代理方法全都是与界面弹出提示框相关的，针对于 web 界面的三种提示框（警告框、确认框、输入框）分别对应三种代理方法。下面只举了警告框的例子</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.WKScriptMessageHandler</p>
<p>这个协议中包含一个必须实现的方法，这个方法是提高 App 与 web 端交互的关键，它可以直接将接收到的 JS 脚本转为 OC 或 Swift 对象</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 四、WKWebView 加载 JS</h2>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、作为 cell 自适应行高</h2>
<figure><img src="https://storage2.cuntuku.com/2017/05/27/2.gif" alt="2.gif" tabindex="0" loading="lazy"><figcaption>2.gif</figcaption></figure>
<ul>
<li>在 didFinishNavigation 方法中获取行高，然后刷新表格，网上资料所说的获取 webview.scrollview.contentsize.height 本人测试不可行，此处采用调用 js 通过 ajax 获取高度</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>此处完成之后需要在 heightforrow 方法中设置 cell 的高为 webview 的高，但是会出现一个问题就是内容显示不全。还需要调用下面这个方法进行重布局</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 六、小结</h2>
<blockquote>
<p>自适应行高是本文的重点，是我自己试验了多种方法之后确定可行的方法</p>
</blockquote>
<blockquote>
<p>下篇文章将介绍拦截 url 进行原生跳转</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://storage2.cuntuku.com/2017/05/27/2.gif" type="image/gif"/>
    </item>
    <item>
      <title>Runloop</title>
      <link>https://oragekk.me/posts/iOS/system/iOS%E4%B8%AD%E7%9A%84Runloop.html</link>
      <guid>https://oragekk.me/posts/iOS/system/iOS%E4%B8%AD%E7%9A%84Runloop.html</guid>
      <source url="https://oragekk.me/rss.xml">Runloop</source>
      <description>Runloop Runloop 是什么 Runloop 是事件接收和分发机制的一个实现。 Runloop 提供了一种异步执行代码的机制，不能并行执行任务。 在主队列中，Main RunLoop 直接配合任务的执行，负责处理 UI 事件、定时器以及其他内核相关事件。 ###Runloop 的主要目的 保证执行程序的线程不会被终止 ###什么时候使用 Runloop 当需要和该线程进行交互的时候才会使用 Runloop 每一个线程都有其对应的 RunLoop，但是默认非主线程的 RunLoop 是没有运行的，需要为 RunLoop 添加至少一个事件源，然后去 run 它。 一般情况下我们是没有必要去启用线程的 RunLoop 的，除非你在一个单独的线程中需要长久的检测某个事件。 主线程 默认有 Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务时，就得让线程一直不退出，runloop 就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</description>
      <category>iOS</category>
      <pubDate>Mon, 26 Dec 2016 13:39:59 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Runloop</h1>
<h3> Runloop 是什么</h3>
<ul>
<li>Runloop 是事件接收和分发机制的一个实现。
<ul>
<li>Runloop 提供了一种异步执行代码的机制，不能并行执行任务。</li>
<li>在主队列中，Main RunLoop 直接配合任务的执行，负责处理 UI 事件、定时器以及其他内核相关事件。</li>
</ul>
</li>
</ul>
<p>###Runloop 的主要目的</p>
<ul>
<li>保证执行程序的线程不会被终止</li>
</ul>
<p>###什么时候使用 Runloop</p>
<ul>
<li>
<p>当需要和该线程进行交互的时候才会使用 Runloop</p>
</li>
<li>
<p>每一个线程都有其对应的 RunLoop，但是默认非主线程的 RunLoop 是没有运行的，需要为 RunLoop 添加至少一个事件源，然后去 run 它。</p>
</li>
<li>
<p>一般情况下我们是没有必要去启用线程的 RunLoop 的，除非你在一个单独的线程中需要长久的检测某个事件。</p>
</li>
<li>
<p>主线程 默认有 Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务时，就得让线程一直不退出，runloop 就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</p>
</li>
</ul>
<hr>
<blockquote>
<p><em>Runloop，正如其名所示，是线程进入和被线程用来响应事件以及调用事件处理函数的地方。需要在代码中使用控制语句实现 run loop 的循环，也就是说，需要代码提供 while 或者 for 循环来驱动 run loop。</em></p>
</blockquote>
<p>在这个循环中使用一个 Runloop 对象<code>[NSRunloop currentRunloop]</code>执行接收消息，调用对应的处理函数。</p>
<ul>
<li>
<p>Runloop 接收两种源事件:<code>input sources</code>和<code>timer sources</code>。</p>
</li>
<li>
<p>input sources&nbsp; 传递异步事件，通常是来自其他线程和不同的程序中的消息；</p>
</li>
<li>
<p>timer sources(定时器)&nbsp; 传递同步事件（重复执行或者在特定时间上触发）。</p>
</li>
<li>
<p>除了处理<code>input sources</code>，Runloop 也会产生一些关于本身行为的<code>notificaiton</code>。注册成为 Runloop 的<code>observer</code>，可以接收到这些 notification，做一些额外的处理。（使用<code>CoreFoundation</code>来成为 runloop 的 observer）。</p>
</li>
</ul>
<p>###Runloop 特性</p>
<ul>
<li>
<p>当有事件发生时，Runloop 会根据具体的事件类型通知应用程序作出响应；</p>
</li>
<li>
<p>当没有事件发生时，Runloop 会进入休眠状态，从而达到省电的目的；</p>
</li>
<li>
<p>当事件再次发生时，Runloop 会被重新唤醒，处理事件。</p>
</li>
<li>
<p>iOS 中所有的事件监听全部由运行循环负责</p>
</li>
<li>
<p>主线程的 &nbsp;RunLoop 在应用启动的时候就会自动创建</p>
</li>
<li>
<p>其他线程则需要在该线程下自己启动</p>
</li>
<li>
<p>不能自己创建 &nbsp;RunLoop</p>
</li>
<li>
<p>RunLoop 并不是线程安全的，所以需要避免在其他线程上调用当前线程的 RunLoop</p>
</li>
<li>
<p>RunLoop 负责管理 &nbsp;<code>autorelease pools</code></p>
</li>
<li>
<p>RunLoop 负责处理消息事件，即输入源事件、计时器事件和网络请求事情</p>
</li>
</ul>
<p>###应用场景</p>
<ul>
<li>
<p>创建常驻线程，执行一些会一直存在的任务。该线程的生命周期跟 &nbsp;App<br>
&nbsp; 相同<br>
@autoreleasepool {<br>
NSLog(@"%@", [NSThread currentThread]);<br>
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>
// 只有添加端口后，才能能够保证运行循环持续运行<br>
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>
[runLoop run];</p>

</li>
<li>
<p>维护线程的生命周期，让线程不自动退出，<code>isFinished</code><br>
&nbsp; 为 &nbsp;<code>Yes</code>时退出</p>
</li>
<li>
<p>在一定时间内监听某种事件，或执行某种任务的线程</p>
</li>
</ul>
<hr>
<blockquote>
<p>####提示：一般在开发中很少会主动创建 Runloop，而通常会把事件添加到 Runloop 中。</p>
</blockquote>
<p>###参考文章<br>
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener noreferrer">官方文档</a><br>
<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener noreferrer">深入理解 Runloop</a><br>
<a href="http://www.cnblogs.com/zy1987/p/4582466.html" target="_blank" rel="noopener noreferrer">Runloop 原理和核心机制</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>OC 中的枚举类型</title>
      <link>https://oragekk.me/posts/iOS/system/iOS%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum%EF%BC%8CNS_ENUM%EF%BC%8CNS_OPTIONS.html</link>
      <guid>https://oragekk.me/posts/iOS/system/iOS%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum%EF%BC%8CNS_ENUM%EF%BC%8CNS_OPTIONS.html</guid>
      <source url="https://oragekk.me/rss.xml">OC 中的枚举类型</source>
      <description>进入正题，今天介绍一下objective-c中的枚举 提要 首先要知道的是,枚举值 它是一个整形(int) 并且,它不参加内存的占用和释放 枚举定义变量即可直接使用,不用初始化 三种类型的枚举 enum 在iOS6之前一般我们采用C风格的enum关键字可以定义枚举类型 在iOS6之后引入两个宏来定义枚举实际上是将enum定义和typedef合二为一，并且采用不同的宏来从代码角度来区分。 NS_ENUM 普通枚举定义可参见UIKit.Framework中 NS_OPTIONS 位运算及特殊枚举的定义。什么时候要用到这种方式呢? 那就是一个枚举变量可能要代表多个枚举值的时候. 其实给一个枚举变量赋予多个枚举值的时候,原理只是把各个枚举值加起来罢了. 当加起来以后,就获取了一个新的值,那么为了保证这个值的唯一性,这个时候就体现了位运算的重要作用. 位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,也就是说,枚举值里面存取的是 计算后的十进制值. 打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论你如何组合在一起,也不会产生两个同样的数字. 这两个宏的定义在Foundation.framework的NSObjCRuntime.h中：</description>
      <category>iOS</category>
      <pubDate>Fri, 06 Jan 2017 11:19:16 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>进入正题，今天介绍一下objective-c中的枚举</p>
</blockquote>
<h3> 提要</h3>
<ul>
<li>
<p>首先要知道的是,枚举值 它是一个整形(int) 并且,它不参加内存的占用和释放 枚举定义变量即可直接使用,不用初始化</p>
</li>
<li>
<p>三种类型的枚举</p>
<ul>
<li><strong>enum</strong> 在iOS6之前一般我们采用C风格的enum关键字可以定义枚举类型</li>
</ul>
<p>在iOS6之后引入两个宏来定义枚举实际上是将enum定义和typedef合二为一，并且采用不同的宏来从代码角度来区分。</p>
<ul>
<li>
<p><strong>NS_ENUM</strong>  普通枚举定义可参见UIKit.Framework中</p>
</li>
<li>
<p><strong>NS_OPTIONS</strong>  位运算及特殊枚举的定义。什么时候要用到这种方式呢? 那就是一个枚举变量可能要代表多个枚举值的时候. 其实给一个枚举变量赋予多个枚举值的时候,原理只是把各个枚举值加起来罢了. 当加起来以后,就获取了一个新的值,那么为了保证这个值的唯一性,这个时候就体现了位运算的重要作用. 位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,也就是说,枚举值里面存取的是 计算后的十进制值. 打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论你如何组合在一起,也不会产生两个同样的数字.</p>
</li>
</ul>
<p>这两个宏的定义在Foundation.framework的NSObjCRuntime.h中：</p>
</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 举个🌰</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>共同学习共同进步，加油。fighting😆</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>iOS Cookie的配置及使用</title>
      <link>https://oragekk.me/posts/iOS/system/iOS%E7%9A%84Cookie%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://oragekk.me/posts/iOS/system/iOS%E7%9A%84Cookie%E4%BD%BF%E7%94%A8.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS Cookie的配置及使用</source>
      <description>本文介绍 iOS 中 cookie 的使用包含 AFNetWorking 3.0 中的使用，常用于登录状态信息保存 什么是 Cookies？ Cookie 是由服务器保存在用户浏览器（客户端）上的一块数据，它可以包含有关用户的信息,比如果登陆的状态，用户标识等。 Cookie 有什么作用？ 主要用在以下三个方面: 会话状态管理（如用户登录状态、购物车） 个性化设置（如用户自定义设置） 浏览器行为跟踪（如跟踪分析用户行为）</description>
      <category>iOS</category>
      <pubDate>Wed, 05 Jul 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文介绍 iOS 中 cookie 的使用包含 AFNetWorking 3.0 中的使用，常用于登录状态信息保存</p>
</blockquote>
<h2> 什么是 Cookies？</h2>
<p>Cookie 是由服务器保存在用户浏览器（客户端）上的一块数据，它可以包含有关用户的信息,比如果登陆的状态，用户标识等。<br>
Cookie 有什么作用？</p>
<p>主要用在以下三个方面:</p>
<ul>
<li>
<p>会话状态管理（如用户登录状态、购物车）</p>
</li>
<li>
<p>个性化设置（如用户自定义设置）</p>
</li>
<li>
<p>浏览器行为跟踪（如跟踪分析用户行为）</p>
</li>
</ul>
<h2> cookie 的处理步骤</h2>
<ul>
<li>服务器向客户端发送 cookie</li>
<li>通常使用 HTTP 协议规定的 Set-Cookie 头操作。</li>
<li>规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。</li>
<li>浏览器将 cookie 保存</li>
<li>每次请求浏览器都会将 cookie 发向服务器</li>
</ul>
<p>其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：</p>
<table>
<thead>
<tr>
<th>key</th>
<th style="text-align:center">是否可选</th>
<th style="text-align:right">value</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td style="text-align:center">T</td>
<td style="text-align:right">xxx</td>
</tr>
<tr>
<td>value</td>
<td style="text-align:center">T</td>
<td style="text-align:right">xxx</td>
</tr>
<tr>
<td>path</td>
<td style="text-align:center">F</td>
<td style="text-align:right">路径</td>
</tr>
<tr>
<td>expires</td>
<td style="text-align:center">F</td>
<td style="text-align:right">UTC 格式时间</td>
</tr>
<tr>
<td>maxAge</td>
<td style="text-align:center">F</td>
<td style="text-align:right">是 cookie 多久后过期的相对时间</td>
</tr>
<tr>
<td>secure</td>
<td style="text-align:center">F</td>
<td style="text-align:right">为 true 时 cookie 在 HTTP 中是无效 在 HTTPS 中才有效</td>
</tr>
<tr>
<td>httpOnly</td>
<td style="text-align:center">F</td>
<td style="text-align:right">浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。</td>
</tr>
</tbody>
</table>
<h2> Cookies 长什么样子？</h2>
<p>当服务器收到 HTTP 请求时，可以在响应头里面增加一个 Set-Cookie 头部。浏览器收到响应之后会取出 Cookie 信息并保存，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。大概都长的都是这个格式：</p>
<p><code>Set-Cookie: &lt;cookie名称&gt;=&lt;cookie值&gt;</code></p>
<p>所以一个简单的 Cookie 像这样：</p>
<p><code>language=zh_CN; expires=Sat, 05-Aug-2017 08:21:16 GMT; Max-Age=2592000; path=/; domain=192.75.17.211:6603</code></p>
<h2> 在 iOS 中使用 Cookies</h2>
<ul>
<li>
<p>NSHTTPCookieStorage 这个类就是一个单例，它的主要任务就是管理 Cookies, 增删改查等各种</p>
</li>
<li>
<p>NSURLRequest NSURLRequest 是 HTTP 请求协议 URL 资源的消息对象 Request</p>
</li>
<li>
<p>NSHTTPURLResponse</p>
<p>NSHTTPURLResponse 是 HTTP 协议请求 URL 资源的响应消息对象。这个对象将 HTTP 协议的序列化了，可以很方便的获得的状态码(statusCode)，消息报头(allHeaderFields)等信息</p>
</li>
</ul>
<h2> 开始手动管理 Cookies</h2>
<ul>
<li>从 NSHTTPURLResponse 获取服务器发给我们的 Cookie,<strong>此种方式获取的是 Headers 中的</strong></li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://storage1.cuntuku.com/2017/07/06/cookie12x.png" alt="cookie12x.png" tabindex="0" loading="lazy"><figcaption>cookie12x.png</figcaption></figure>
<ul>
<li>从 NSHTTPCookieStorage 获取想要 Cookie，<strong>此种获取方式是获取的 cookies 中的</strong></li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://storage2.cuntuku.com/2017/07/06/cookie22x.png" alt="cookie22x.png" tabindex="0" loading="lazy"><figcaption>cookie22x.png</figcaption></figure>
<ul>
<li>清除 Cookie</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用 AFNetworking 时，对 Cookies 管理的示例</h2>
<ul>
<li>AFNetworking 3.0 默认是保存 cookies 的。</li>
<li>模拟登录，保存 cookie 以及设置 cookie:</li>
<li></li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://storage1.cuntuku.com/2017/07/06/cookie12x.png" type="image/png"/>
    </item>
    <item>
      <title>iOS程序启动原理（上）</title>
      <link>https://oragekk.me/posts/iOS/system/iOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89.html</link>
      <guid>https://oragekk.me/posts/iOS/system/iOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS程序启动原理（上）</source>
      <description>本文介绍 iOS 程序中的 Info.plist,pch 文件,UIApplication,openURL 以及 UIWindow 的常用属性及方法; info.plist 常见设置 建立一个工程后,会在 Supporting files 文件夹下看到一个&amp;quot;工程名-Info.plist&amp;quot;的文件,该文件对工程做一些运行期的配置,非常重要,不能删除. 在旧版 Xcode 创建的工程中,这个配置文件的名字叫做&amp;quot;Info.plist&amp;quot;. 项目中的其他 plist 文件不能带有&amp;quot;Info&amp;quot;这个字眼,不然会被错认为是传说中非常重要的&amp;quot;Info.plist&amp;quot;. 项目中还有一个&amp;quot;InfoPlist.strings&amp;quot;的文件(Xcode6 之后需手动添加),跟 Info.plist 文件的本地化相关.</description>
      <category>iOS</category>
      <pubDate>Fri, 30 Dec 2016 15:59:12 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文介绍 iOS 程序中的 Info.plist,pch 文件,UIApplication,openURL 以及 UIWindow 的常用属性及方法;</p>
</blockquote>
<h3> info.plist</h3>
<h4> 常见设置</h4>
<p>建立一个工程后,会在 Supporting files 文件夹下看到一个"<em>工程名-Info.plist</em>"的文件,该文件对工程做一些运行期的配置,非常重要,不能删除.<br>
在旧版 Xcode 创建的工程中,这个配置文件的名字叫做"Info.plist".<br>
项目中的其他 plist 文件不能带有"Info"这个字眼,不然会被错认为是传说中非常重要的"Info.plist".<br>
项目中还有一个"InfoPlist.strings"的文件(Xcode6 之后需手动添加),跟 Info.plist 文件的本地化相关.</p>
<h4> Info.plist 常见属性:</h4>
<ol>
<li>Localiztion native development region (CFBundleDevelopmentRegion)-本地化相关;</li>
<li>Bundle display name(CFBundleDisplayName)-程序安装后显示的名称,限制在 10-12 个字符,如果超出,将被显示缩写名称;</li>
<li>Icon file(CFBundleIconFile)-app 图标名称,一般为 Icon.png;</li>
<li>Bundle version(CFBundleVersion)-应用程序的版本号,每次往 App Store 上发布一个新版本时,需要增加这个版本号;</li>
<li>Main storyboard file base name(NSMainStoryboardFile)-主 storyboard 文件名称;</li>
<li>Bundle identifier(CFBundleIdentifier)-项目的唯一标识,部署到真机时用到;</li>
<li>额外说一下从 iOS9 开始，所有的 http 请求都改成了 https，采用 TLS 1.2 协议，目的是增强数据安全。如果不更新的话，暂时可以在 Info.plist 中声明，使用不安全的网络请求。<br>
可以在 info.plist 中添加一下字段
即如：![](http://upload-images.jianshu.io/upload_images/2076247-22165721d20be6ab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</li>
</ol>
<h3> pch 文件</h3>
<p>项目的 Supporting files 文件夹下面有个"工程名-Prefix.pch"文件,也是一个头文件;</p>

<h3> UIApplication</h3>
<p>UIApplication 对象是应用程序的象征;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 每一个应用都有自己的 UIApplication 对象,而且是单例的;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 通过[UIApplication sharedApplication]可以获得这个单例对象;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 一个 iOS 程序启动后创建的第一个对象就是 UIApplication 对象;<br>
&nbsp;&nbsp;&nbsp;&nbsp; 利用 UIApplication 对象,能进行一些应用级别的操作.</p>
<h4> UIApplication 的常用属性</h4>
<p>设置应用程序图标右上角的红色提醒数字:<br>
@property(nonatomic)&nbsp;NSInteger&nbsp;applicationIconBadgeNumber;<br>
设置联网指示器(菊花)的可见性<br>
@property(nonatomic,getter=isNetworkActivityIndicatorVisible)&nbsp;BOOL&nbsp;networkActivityIndicatorVisible;</p>
<h3> 状态栏</h3>
<h5> 从 iOS7 开始,系统提供了两种管理状态栏的方式:</h5>
<p>1.&gt;通过 UIViewController 管理(在 iOS 中,默认情况下,状态栏都是由 UIViewController 管理的):<br>
状态栏的样式:<br>
-&nbsp;(UIStatusBarStyle)preferredStatusBarStyle;<br>
&nbsp; 状态栏的可见性<br>
-&nbsp;(BOOL)prefersStatusBarHidden;<br>
2.&gt;通过 UIApplication 管理(一个应用程序的状态栏都由它统一管理)<br>
application.statusBarHidden&nbsp;=&nbsp;NO;</p>
<h4> openURL:</h4>
<p>UIApplication 有个功能十分强大的 openURL 方法:<br>
-&nbsp;(BOOL)openURL:(NSURL*)url;<br>
openURL:方法的部分功能有</p>
<ul>
<li>打电话<br>
UIApplication&nbsp;*app&nbsp;=&nbsp;[UIApplication&nbsp;sharedApplication];<br>
[app&nbsp;openURL:[NSURL&nbsp;URLWithString:@"tel://10086"]];</li>
<li>发短信<br>
[app&nbsp;openURL:[NSURL&nbsp;URLWithString:@"sms://10086"]];</li>
<li>发邮件<br>
[app&nbsp;openURL[NSURL&nbsp;URLWithString:@"mailto://605453790@qq.com"]];</li>
<li>打开一个网页资源<br>
[app&nbsp;openURL:[NSURL&nbsp;URLWithString:@"<a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">http://www.baidu.com</a>"]];</li>
<li>打开其他 app 程序<br>
NSString *urlString = [NSString stringWithFormat:@"AppJumpSecond://%@",textField.text];<br>
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];</li>
</ul>
<h3> UIApplication 和 delegate</h3>
<p>所有的移动操作系统都有个致命的缺点:app 很容易受到打扰.比如一个来电或者锁屏会导致 app 进入后台甚至被终止;</p>
<p>还有很多其他类似的情况会导致 app 受到干扰,在 app 受到干扰时,会产生一些系统事件,这时 UIApplication 会通知它的 delegate 对象,让 delegate 来处理这些系统事件.</p>
<p>delegate 可处理的事件包括:</p>

<h4> UIApplicationDelegate 协议</h4>

<p>每次新建完项目,都有个带有"AppDelegate"字眼的类,它就是 UIApplication 的代理,<em>AppDelegate</em>默认已经遵守了<code>UIApplicationDelegate</code>协议,已经是 UIApplication 的代理;</p>
<h3> UIWindow</h3>
<p>UIWindow 是一种特殊的 UIView,通常在一个 App 中只会有一个 UIWindow;<br>
&nbsp;&nbsp;&nbsp;&nbsp;iOS 程序启动完毕后,创建的第一个视图控件就是 UIWindow,接着创建控制器的 View,最后将控制器的 view 添加到 UIWindow 上,于是控制器的 view 就显示在屏幕上了.<br>
&nbsp;&nbsp;&nbsp;&nbsp; 一个程序之所以能显示在屏幕上,完全是因为它有 UIWindow,没有 UIWindow,就看不见任何 UI 界面;<br>
添加 UIView 到 UIWindow 中的两种常见方式:<br>
&nbsp;&nbsp;&nbsp;&nbsp;1&gt; 直接将 view 添加到 UIWindow 中,但并不会理会 view 对应的 UIViewController<br>
-&nbsp;(void)addSubview:(UIView&nbsp;*)view;</p>
<p>2&gt; 自动将 rootViewController 的 view 添加到 UIWindow 中,负责管理 rootViewController 的生命周期;</p>

<p>常用方法:<br>
&nbsp; -&nbsp;(void)makeKeyWindow;&nbsp;&nbsp;//让当前 UIWindow 变成 keyWindow(主窗口)&nbsp;<br>
-&nbsp;(void)makeKeyAndVisible;&nbsp;&nbsp;//让当前 UIWindow 变成 keyWindow，并显示出来</p>
<h4> UIWindow 的获得:</h4>

<p>在本应用中打开的 UIWindow 列表,这样就可以接触应用中的任何一个 UIView 对象(平时输入文字弹出的键盘,就处在一个新的 UIWindow 中).</p>

<p>用来接收键盘以及非触摸类的消息事件的 UIWindow,而且程序中每时每刻只能有一个 UIWindow 是 keyWindow.如果某个 UIWindow 内部的文本框不能输入文字,可能是因为这个 UIWindow 不是 keyWindow.</p>

<p>获得某个 UIView 所在的 UIWindow.</p>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/2076247-22165721d20be6ab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>iOS程序启动原理（下）</title>
      <link>https://oragekk.me/posts/iOS/system/iOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89.html</link>
      <guid>https://oragekk.me/posts/iOS/system/iOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS程序启动原理（下）</source>
      <description>接上篇 iOS 程序启动原理（上） 下图是一个 iOS 程序启动的完整过程</description>
      <category>iOS</category>
      <pubDate>Fri, 30 Dec 2016 16:02:25 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>接上篇</p>
</blockquote>
<p><a href="/posts/iOS/iOS%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89.html" target="blank">iOS 程序启动原理（上）</a></p>
<p>下图是一个 iOS 程序启动的完整过程</p>
<!-- ![图](https://upload-images.jianshu.io/upload_images/2076247-1f1b30ddcfcd7ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) -->
<img src="https://upload-images.jianshu.io/upload_images/2076247-1f1b30ddcfcd7ef3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" referrerpolicy="no-referrer" alt="图">
<p>main 函数中执行了一个 UIApplicationMain 这个函数.</p>

<p>argc, argv:直接传递给 UIApplicationMain 进行相关处理即可;</p>
<p>principalClassName:指定应用程序类名(app 象征),该类必须是 UIApplication(或子类).如果为 nil,则用 UIApplication 类作为默认值.</p>
<p>delegateClassName:指定应用程序的代理类,该类必须遵守 UIApplicationDelegate 协议.</p>
<p>UIApplicationMain 函数会根据 principalClassName 创建 UIApplication 对象,根据 delegateClassName 创建一个 delegate 对象,并将该 delegate 对象赋值给 UIApplication 对象中的 delegate 属性.</p>
<p>接着会建立应用程序的 Main Runloop(事件循环),进行事件的处理(首先会在程序启动完毕后调用 delegate 对象的 application:didFinishLaunchingWithOptions:方法)</p>
<p>程序正常退出时 UIApplicationMain 函数才返回.</p>
]]></content:encoded>
      <enclosure url="https://upload-images.jianshu.io/upload_images/2076247-1f1b30ddcfcd7ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>iOS 10.3 keychain 重大更新</title>
      <link>https://oragekk.me/posts/iOS/system/keychain%E6%9B%B4%E6%96%B0.html</link>
      <guid>https://oragekk.me/posts/iOS/system/keychain%E6%9B%B4%E6%96%B0.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS 10.3 keychain 重大更新</source>
      <description>转载自微信公众号《Mrpeak 杂货铺》 Paste_Image.png iOS 10.3 还未正式发布，beta 版中一个关于 keychain 特性的小修改，就已经引起了广泛的关注。</description>
      <category>iOS</category>
      <pubDate>Tue, 14 Mar 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>转载自微信公众号《Mrpeak 杂货铺》</p>
</blockquote>
<figure><img src="http://upload-images.jianshu.io/upload_images/2076247-1b07e63d35825ce7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="Paste_Image.png" tabindex="0" loading="lazy"><figcaption>Paste_Image.png</figcaption></figure>
<p>iOS 10.3 还未正式发布，beta 版中一个关于 keychain 特性的小修改，就已经引起了广泛的关注。</p>
<p>改动如下</p>
<ul>
<li>如果 App 被删除，之前存储于 keychain 中的数据也会一同被清除。</li>
<li>如果使用了 keychain group，只要当 group 所有相关的 App 被删除时，keychain 中的数据才会被删除。</li>
</ul>
<p>这一改动，虽未经官方公布。但已在论坛帖子里得到了 Apple 员工的确认，原文如下：</p>
<blockquote>
<p>This is an intentional change in iOS 10.3 to protect user privacy. Information that can identify a user should not be left on the device after the app that created it has been removed.</p>
</blockquote>
<blockquote>
<p>It has never been a part of the API contract that keychain items created by an app would survive when the app is removed. This has always been an implementation detail.</p>
</blockquote>
<blockquote>
<p>If a keychain item is shared with other apps, it won’t be deleted until those other apps have been deleted as well.</p>
</blockquote>
<p>心存侥幸的人可能会觉得这只是正常的 API 调整，会有新的存储机制做替补。在我看来，这种可能性极低。正如上面这段英文所述，Apple 这一改动是基于用户隐私的考虑，改动之后，开发者将没法再根据设备号来追踪设备的唯一性。结合最近 JSPatch 这类热更新机制被禁来看，Apple 近期似乎在用户隐私和安全方面有相当的规划和动作。</p>
<p>Apple 对于开发者的每次动作都有让人无法反驳的立场，用户隐私当然很重要。谈论其合理性其实并没有什么意义，因为这不会影响最终结果，我们只能拥抱变化，早作准备。</p>
<p>这次改动影响究竟有多大呢？没用到 keychain 特性还好，如有涉及，其影响可能比大部分人想象的要大，以下是我所能预知的一部分：</p>
<h3> 重装需登录</h3>
<p>无法追踪设备，用户删掉一个 App，之后再重装就只能手动登录一次了。</p>
<p>很多 App 都有类似的功能，重装的时候不需要再次登录，比如 WhatsApp，知乎等，这对用户体验更好一些。这种用户场景下，App 的本意虽然不是追踪用户设备，但很不幸，开发者已经不能判断是否为同一设备的再次登录了。</p>
<h3> 基于设备的免费试用功能无法实现了</h3>
<p>有不少 App 的试用功能都是基于账户或者基于设备的，基于设备的会更多一些，因为如果是基于账户，在同一个设备上更换账户还不算太麻烦，而用户更换设备的成本更高。但新版本 keychain 更改之后，用户如果删掉 App 重装，开发者无法判断试用功能是否已经试用过了。</p>
<p>这种基于设备的免费试用场景也不少，比如一些可以免费试用 7 天的 VPN App。</p>
<h3> 短信费用上升</h3>
<p>这方面的影响就是直接和真金白银挂钩了。</p>
<p>现在不少基于熟人社交的 App 都是以用户的手机号为 ID 注册的，每次注册都要花费一条平台的短信费用。不少 App 为了节省费用，在用户删除重装之后登录的场景，都是直接从 keychain 读出以前的登录信息，绕过短信验证直接登进去的。iOS 10.3 之后，就无法再绕过了，必须在重装时再花一条短信的钱来验证用户。</p>
<p>不要小看了这一条短信的费用，对于财大气粗的大公司来说还好，但对于锱铢必较的创业团队来说，这些额外的开销就是一笔冤枉钱了。</p>
<h3> 总结</h3>
<p>对于跟踪用户和设备，Apple 的管控越来越严，从最初的设备 ID，到 Mac 地址，到今天 keychain 的调整。每一次看似一个小的更改，影响面却很广。不知道大家是否有使用 keychain 来做持久化存储方案，是否会因为这次调整受到影响，如果不能跨越 App 的生命周期，真不知道 keychain 还有什么存在的意义，各位要早作准备了。</p>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/2076247-1b07e63d35825ce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>利用Runtime进行快速归档</title>
      <link>https://oragekk.me/posts/iOS/system/runtime%E5%BF%AB%E9%80%9F%E5%BD%92%E6%A1%A3.html</link>
      <guid>https://oragekk.me/posts/iOS/system/runtime%E5%BF%AB%E9%80%9F%E5%BD%92%E6%A1%A3.html</guid>
      <source url="https://oragekk.me/rss.xml">利用Runtime进行快速归档</source>
      <description>使用 runtime 进行归档，对我们的最大遍历就是高效，快速。尤其适用于 model 中属性非常多的时候 Person.h person.m</description>
      <category>iOS</category>
      <pubDate>Thu, 13 Apr 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>使用 runtime 进行归档，对我们的最大遍历就是高效，快速。尤其适用于 model 中属性非常多的时候</p>
</blockquote>
<h2> Person.h</h2>
<figure><img src="http://i2.muimg.com/567571/e2afe593e10c0c78.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> person.m</h2>
<figure><img src="http://i4.buimg.com/567571/713e554a5fd04e13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> viewController.m</h2>
<figure><img src="http://i1.piimg.com/567571/0333be9f5d16fd96.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> printResult</h2>
<figure><img src="http://i4.buimg.com/567571/5b12de7ec090769f.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="http://i2.muimg.com/567571/e2afe593e10c0c78.png" type="image/png"/>
    </item>
    <item>
      <title>Update Cocoapods 1.1.1</title>
      <link>https://oragekk.me/posts/iOS/tool/Update-Cocoapods.html</link>
      <guid>https://oragekk.me/posts/iOS/tool/Update-Cocoapods.html</guid>
      <source url="https://oragekk.me/rss.xml">Update Cocoapods 1.1.1</source>
      <description>之前采用正常的 sudo gem install cocoapods更新 cocoapods 版本一直不成功，下面为和我遇到同样问题的兄弟们提供一个解决办法 先切换 gem 源 gem sources --remove https://rubygems.org/ gem source -a https://gems.ruby-china.org 查看是否切换成功 gem source -l 如果出现下图这样的就说明切换成功了, 如果还是官方的源, 请手动重启电脑尝试</description>
      <category>iOS</category>
      <pubDate>Wed, 09 Nov 2016 11:34:47 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>之前采用正常的 <code>sudo gem install cocoapods</code>更新 cocoapods 版本一直不成功，下面为和我遇到同样问题的兄弟们提供一个解决办法</p>
</blockquote>
<h4> 先切换 gem 源</h4>
<ul>
<li><code>gem sources --remove https://rubygems.org/</code></li>
<li><code>gem source -a https://gems.ruby-china.org</code></li>
<li>查看是否切换成功 <code>gem source -l</code><br>
如果出现下图这样的就说明切换成功了, 如果还是官方的源, 请手动重启电脑尝试<br>
<img src="http://upload-images.jianshu.io/upload_images/2076247-365912ab78be4906.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></li>
</ul>
<h4> 接下来就可以开始升级了 cocoapods 了</h4>
<ul>
<li><code>sudo gem install -n /usr/local/bin cocoapods --pre</code></li>
<li>是的, 你没看错是这个命令, 然后终端会出现一大推东西, 别管他, 最后停下来是这样的就差不多了<br>
<img src="http://upload-images.jianshu.io/upload_images/2076247-81b6046594fe772b.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></li>
<li>然后查看版本<code>pod --version</code><br>
出现 1.1.1，恭喜你已经安装成功了</li>
<li>接下来设置 pod 仓库 <code>pod setup</code></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2076247-cafa12def948db48.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="Paste_Image.png" loading="lazy"><br>
此处需要耐心等待，根据网络情况完成时间长短不一。<br>
可以在终端中 CD 到<code>~/.cocoapods</code>目录中输入 <code>du -sh *</code>查看下载进度</p>
<h3> 至此, 已经升级到 cocoapods1.1.1 了, 可以愉快的把玩 Swift3.0 的一些三方库了</h3>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/2076247-365912ab78be4906.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>ijkPlayer 集成</title>
      <link>https://oragekk.me/posts/iOS/tool/ijkplayer.html</link>
      <guid>https://oragekk.me/posts/iOS/tool/ijkplayer.html</guid>
      <source url="https://oragekk.me/rss.xml">ijkPlayer 集成</source>
      <description>参考地址 ijkplayer 是一款做视频直播的框架，基于 FFmpeg，支持 Android 和 iOS。这里介绍一下 iOS 中集成 ijkplayer 一、FFmpeg FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了领先的音/视频编码库 libavcodec 等。</description>
      <category>iOS</category>
      <pubDate>Wed, 30 Aug 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><a href="http://www.jianshu.com/p/b7a646a6c80e" target="_blank" rel="noopener noreferrer">参考地址</a><br>
ijkplayer 是一款做视频直播的框架，基于 FFmpeg，支持 Android 和 iOS。这里介绍一下 iOS 中集成 ijkplayer</p>
</blockquote>
<h2> 一、FFmpeg</h2>
<p>FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了领先的音/视频编码库 libavcodec 等。</p>
<p><strong>libavformat</strong>：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构<br>
和读取音视频帧等功能；</p>
<p><strong>libavcodec</strong>：用于各种类型声音/图像编解码；</p>
<p><strong>libavutil</strong>：包含一些公共的工具函数；</p>
<p><strong>libswscale</strong>：用于视频场景比例缩放、色彩映射转换；</p>
<p><strong>libpostproc</strong>：用于后期效果处理；</p>
<p><strong>ffmpeg</strong>：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；</p>
<p><strong>ffsever</strong>：一个 HTTP 多媒体即时广播串流服务器；</p>
<p><strong>ffplay</strong>：是一个简单的播放器，使用 ffmpeg 库解析和解码，通过 SDL 显示；</p>
<h3> 支持的编码</h3>
<p>源自 FFmpeg 项目组的两个视频编码：</p>
<p>Snow</p>
<p>FFV1</p>
<h3> 支持的格式</h3>
<p>ASF</p>
<p>AVI</p>
<p>BFI[7]</p>
<p>IFF[8]</p>
<p>RL2[9]</p>
<p>FLV</p>
<p>MXF, Material eXchange Format, SMPTE 377M</p>
<p>Matroska</p>
<p>Maxis XA[10]</p>
<p>MSN Webcam stream[11]</p>
<p>MPEG transport stream</p>
<p>TXD[6]</p>
<p>OMA[12]</p>
<p>GXF, General eXchange Format, SMPTE 360M</p>
<p>mov,mp4,m4a,3gp,</p>
<h3> 支持的协议</h3>
<p>HTTP</p>
<p>RTP</p>
<p>RTSP</p>
<p>RealMedia RTSP/RDT</p>
<p>TCP</p>
<p>UDP</p>
<p>Gopher</p>
<p>RTMP</p>
<p>RTMPT, RTMPE, RTMPTE, RTMPS (via librtmp)</p>
<p>SDP</p>
<p>MMS over TCP</p>
<h2> 二、下载 ijkplayer</h2>
<p>ijkplayer 下载地址:<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener noreferrer">https://github.com/Bilibili/ijkplayer</a></p>
<p>下载完成后解压, 解压后文件夹内部目录如下图:<br>
<img src="https://storage2.cuntuku.com/2017/08/31/ijkplayer.png" alt="ijkplayer.png" loading="lazy"></p>
<h2> 三、编译</h2>
<p>其实这里主要是编译 FFmpeg，因为他是一个 C 语言的跨平台库，需要 sh 脚本来进行编译</p>
<ol>
<li>打开终端, cd 到 jkplayer-master 文件夹中, 也就是下载完解压后的文件夹, 如下图:<img src="https://storage1.cuntuku.com/2017/08/31/1.png" alt="1.png" loading="lazy"></li>
<li>执行命令行**./init-ios.sh**, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图:<img src="https://storage2.cuntuku.com/2017/08/31/2.png" alt="2.png" loading="lazy"></li>
<li>cd 到 ios 目录中</li>
<li>执行**./compile-ffmpeg.sh clean**<img src="https://storage1.cuntuku.com/2017/08/31/3.png" alt="3.png" loading="lazy"></li>
<li>执行**./compile-ffmpeg.sh all**进行 FFmpeg 的编译，时间较久<img src="https://storage2.cuntuku.com/2017/08/31/4.png" alt="4.png" loading="lazy"></li>
</ol>
<h2> 四、打包 IJKMediaFramework.framework 框架</h2>
<p>其实集成 ijkplayer 有两种方法，一种是按照 Demo 中的导入 IJKMediaPlayer.xcodeproj，此方法不是很推荐</p>
<p>下面主要说另一种把 ijkplayer 打包成 framework 导入工程中使用.<br>
首先打开工程 IJKMediaPlayer.xcodeproj,<img src="http://upload-images.jianshu.io/upload_images/1803339-607cc84c212faf90.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="IJKMediaPlayer.xcodeproj" loading="lazy"></p>
<p>选择 IJKMediaFramework 点击 EditScheme<img src="http://upload-images.jianshu.io/upload_images/1803339-bbc0adc479cebb69.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<p>选择 release<img src="http://upload-images.jianshu.io/upload_images/1803339-daa4498f7e0746d0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<p>设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder,<img src="http://upload-images.jianshu.io/upload_images/1803339-344cda905745ff39.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<p>下面开始合并真机和模拟器版本的 framework, 注意不要合并错了, 合并的是这个文件, 如下图:<img src="http://upload-images.jianshu.io/upload_images/1803339-ec00ef4cb15c66d1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<p>打开终端, 进行合并, 命令行具体格式为:<br>
lipo -create 真机版本路径 模拟器版本路径 -output 合并后的文件路径</p>
<p>合并后如下图<img src="http://upload-images.jianshu.io/upload_images/1803339-d025e12bf804ee05.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<p>用合并后的 IJKMediaFramework 把原来的 IJKMediaFramework 替换掉<img src="http://upload-images.jianshu.io/upload_images/1803339-8d228ab56eb77f43.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="" loading="lazy"></p>
<h2> 五、在 iOS 项目中集成 ijkplayer</h2>
<p>新建工程, 导入合并后的 IJKMediaFramework.framework 以及相关依赖框架以及相关依赖框架,如下图:<br>
<img src="https://storage1.cuntuku.com/2017/08/31/5.png" alt="5.png" loading="lazy"></p>
<p>导入框架后在 ViewController.m 中进行 buid，如果成功，说明集成成功。然后可以在控制器中写一个 Demo 测试<img src="https://storage1.cuntuku.com/2017/08/31/Snip20170831_10.png" alt="Snip20170831_10.png" loading="lazy"><br>
可以是 mp4 格式，也可以是 m3u8,rtmp,hls 等流媒体</p>
<blockquote>
<p><a href="https://github.com/OrageKK/ijkPlayerDemo" target="_blank" rel="noopener noreferrer">demo 地址</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://storage2.cuntuku.com/2017/08/31/ijkplayer.png" type="image/png"/>
    </item>
    <item>
      <title>iOS - Image compression algorithm</title>
      <link>https://oragekk.me/posts/iOS/tool/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html</link>
      <guid>https://oragekk.me/posts/iOS/tool/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS - Image compression algorithm</source>
      <description>由于最近公司在做图片相册选择上传的功能，对于图片的压缩算法这里我借鉴了 ochina 的 ios 端 App。其中有涉及到图片压缩的算法，这里贴出来留待后用; GACompressionPicHandle.h</description>
      <category>iOS</category>
      <pubDate>Fri, 30 Dec 2016 16:09:45 GMT</pubDate>
      <content:encoded><![CDATA[<figure><img src="https://zero-space.s3.amazonaws.com/photos/bf30834c-a9de-41f4-9f39-4f44c2f2ff13x840.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>由于最近公司在做图片相册选择上传的功能，对于图片的压缩算法这里我借鉴了 ochina 的 ios 端 App。其中有涉及到图片压缩的算法，这里贴出来留待后用;</p>
</blockquote>
<h3> GACompressionPicHandle.h</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> GACompressionPicHandle.m</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://zero-space.s3.amazonaws.com/photos/bf30834c-a9de-41f4-9f39-4f44c2f2ff13x840.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>iOS 配置https</title>
      <link>https://oragekk.me/posts/iOS/tool/%E9%85%8D%E7%BD%AEhttps.html</link>
      <guid>https://oragekk.me/posts/iOS/tool/%E9%85%8D%E7%BD%AEhttps.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS 配置https</source>
      <description>昨天试验了 iOS 11 beta6 发现原有的 https 自建证书不能使用，可能是新版本要对 ATS 加强验证，之前一直说的要全面 https 估计在不久的将来就要来临，未接入的可能要像 Apple 说的不允许上架。所以把配置过程记录在此 要求 启用 ATS 必须符合以下标准，不满足条件的 HTTPS 证书，ATS 都会拒绝链接： 服务器所有的链接使用 TLS1.2 以上版本 HTTPS 证书必须使用 SHA 256 以上哈希算法签名 HTTPS 证书必须使用 RAS 2048 位或 ECC 356 位以上公钥算法 使用前向加密技术</description>
      <category>iOS</category>
      <pubDate>Wed, 16 Aug 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>昨天试验了 iOS 11 beta6 发现原有的 https 自建证书不能使用，可能是新版本要对 ATS 加强验证，之前一直说的要全面 https 估计在不久的将来就要来临，未接入的可能要像 Apple 说的不允许上架。所以把配置过程记录在此</p>
</blockquote>
<h2> 要求</h2>
<p>启用 ATS 必须符合以下标准，不满足条件的 HTTPS 证书，ATS 都会拒绝链接：</p>
<ul>
<li>服务器所有的链接使用 TLS1.2 以上版本</li>
<li>HTTPS 证书必须使用 SHA 256 以上哈希算法签名</li>
<li>HTTPS 证书必须使用 RAS 2048 位或 ECC 356 位以上公钥算法</li>
<li>使用前向加密技术</li>
</ul>
<h2> AFSecurityPolicy 相关的配置</h2>
<ul>
<li>
<p>SSLPinningMode<br>
SSLPinningMode 定义了 https 连接时，如何校验服务器端给予的证书</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AFSSLPinningModeNone: 代表客户端无条件地信任服务器端返回的证书。</p>
<p>AFSSLPinningModePublicKey: 代表客户端会将服务器端返回的证书与本地保存的证书中，PublicKey 的部分进行校验；如果正确，才继续进行。</p>
<p>AFSSLPinningModeCertificate: 代表客户端会将服务器端返回的证书和本地保存的证书中的所有内容，包括 PublicKey 和证书部分，全部进行校验；如果正确，才继续进行。</p>
</li>
<li>
<p>allowInvalidCertificates 是否支持自建证书默认 NO 改为 YES</p>
</li>
<li>
<p>validatesDomainName 是否进行域名验证 默认 YES 改为 NO</p>
</li>
</ul>
<h2> 客户端配置</h2>
<ul>
<li>
<p>首先导入证书到项目<br>
<a href="https://cuntuku.com/image/4xc6p" target="_blank" rel="noopener noreferrer"><img src="https://storage1.cuntuku.com/2017/08/16/daoru.md.png" alt="daoru.md.png" loading="lazy"></a><br>
<a href="https://cuntuku.com/image/4xyN0" target="_blank" rel="noopener noreferrer"><img src="https://storage2.cuntuku.com/2017/08/16/phases.md.png" alt="phases.md.png" loading="lazy"></a></p>
</li>
<li>
<p>配置 info.plist 文件<br>
<a href="https://cuntuku.com/image/4xA2z" target="_blank" rel="noopener noreferrer"><img src="https://storage1.cuntuku.com/2017/08/16/infoplist.md.png" alt="infoplist.md.png" loading="lazy"></a></p>
</li>
<li>
<p>网络请求配置(AFN)</p>
</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://storage1.cuntuku.com/2017/08/16/daoru.md.png" type="image/png"/>
    </item>
    <item>
      <title>Cell的accessoryType属性标记单元格之后，出现的重用问题</title>
      <link>https://oragekk.me/posts/iOS/ui/cell%E5%A4%8D%E7%94%A8-accessoryType%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</link>
      <guid>https://oragekk.me/posts/iOS/ui/cell%E5%A4%8D%E7%94%A8-accessoryType%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</guid>
      <source url="https://oragekk.me/rss.xml">Cell的accessoryType属性标记单元格之后，出现的重用问题</source>
      <description>今天项目里出现一个问题，就是做一个列表选择，然后点击导航栏的确定按钮返回上级界面，并把选择的 cell 数据传递到上级界面。再使用 accessoryType 属性标记单元格之后会出现重用问题。 解决办法 把 tableView 的 allowsMultipleSelection 属性设为了 YES； _tableView.allowsMultipleSelection = YES; 在 didSelectRowAtIndexPath 和 didDeselectRowAtIndexPath 方法里面使用了如下方法实现了点击单元格然后用 check mark 标记的方式。</description>
      <category>iOS</category>
      <pubDate>Mon, 13 Feb 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>今天项目里出现一个问题，就是做一个列表选择，然后点击导航栏的确定按钮返回上级界面，并把选择的 cell 数据传递到上级界面。再使用 accessoryType 属性标记单元格之后会出现重用问题。</p>
</blockquote>
<h2> 解决办法</h2>
<ul>
<li>
<p>把 tableView 的 allowsMultipleSelection 属性设为了 YES；</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在 didSelectRowAtIndexPath 和 didDeselectRowAtIndexPath 方法里面使用了如下方法实现了点击单元格然后用 check mark 标记的方式。</p>
</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 重点来了 两种思路</h3>
<ul>
<li>记录选择的 indexpath</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>利用 cell 的 selected 属性</p>
<ul>
<li>继承 UITableViewCell，在 setSeleted:animated:方法里面，根据选择状态，修改 accessoryType</li>
</ul>
</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 至此已完美解决因为复用所导致的问题</h3>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>TableView性能优化</title>
      <link>https://oragekk.me/posts/iOS/ui/tableview-radius.html</link>
      <guid>https://oragekk.me/posts/iOS/ui/tableview-radius.html</guid>
      <source url="https://oragekk.me/rss.xml">TableView性能优化</source>
      <description>本文介绍内容主要是 tableView 的性能优化之不使用 cornerRadius 设置图片圆角 有人问我为什么 tableView 滑动不流畅，甚至闪退，其实和 cell 中的圆角头像使用了 cornerRadius 有关</description>
      <category>iOS</category>
      <pubDate>Mon, 26 Dec 2016 13:39:59 GMT</pubDate>
      <content:encoded><![CDATA[<h2> <img src="http://upload-images.jianshu.io/upload_images/2076247-98a0c6450c69fa62.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="此子必成大器" loading="lazy"></h2>
<blockquote>
<p>本文介绍内容主要是 tableView 的性能优化之不使用 cornerRadius 设置图片圆角</p>
</blockquote>
<p>有人问我为什么 tableView 滑动不流畅，甚至闪退，其实和 cell 中的圆角头像使用了 cornerRadius 有关</p>
<h3> 优化点</h3>
<ul>
<li>
<p>行高一定要缓存</p>
</li>
<li>
<p>不要动态创建子视图</p>
</li>
<li>
<p>所有子视图都要预先创建</p>
</li>
<li>
<p>如果不需要显示可以设置 hidden</p>
</li>
<li>
<p>所有的子视图都应该添加到 &nbsp;<code>contentView</code>上</p>
</li>
<li>
<p>所有的子视图都必须要指定颜色</p>
</li>
<li>
<p>不要动态的修改 cornerRadius 之类的图层渲染相关属性</p>
</li>
<li>
<p>使用颜色不要带透明度，此处我们可以使用模拟器中的混合模式去检测，如果如下图所示出现红色，除了 UILabel 之外，其他的我们都应该尽量去处理</p>
</li>
<li>
<p>cell 栅格化</p>

</li>
<li>
<p>异步绘制<br>
<code>// 异步绘制   layer.drawsAsynchronously = YES;</code></p>
</li>
</ul>
<figure><img src="http://upload-images.jianshu.io/upload_images/2076247-b9d269a0daab047f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="Color Blended Layers模式下" tabindex="0" loading="lazy"><figcaption>Color Blended Layers模式下</figcaption></figure>
<p>下图是使用了 CornerRadius 设置圆角之后 Color Misaligned Images 检测效果<br>
<img src="http://upload-images.jianshu.io/upload_images/2076247-a60b840cceed974b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="Color Misaligned Images模式下" loading="lazy"></p>
<p>此处使用了一张 800*** 800 的图片设置在一个 200*200 的 ImageView 上，没有做任何特殊处理</p>
<hr>
<h3> 优化步骤</h3>
<ol>
<li>
<p>新建一个 UIImage 分类</p>
</li>
<li>
<p>定义方法<br>
- (void)oa_cornerImageWithSize:(CGSize)size fillColor: (UIColor *)fillColor</p>

</li>
</ol>
<p>3.控制器中代码如下</p>

<p>4.模拟器<code>Color Blended Layers</code> 和<code>Color Misaligned Images</code>检测结果如下图</p>
<figure><img src="http://upload-images.jianshu.io/upload_images/2076247-d35c6e1664f0601e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="优化之后" tabindex="0" loading="lazy"><figcaption>优化之后</figcaption></figure>
<p>5.Color Misaligned Images 如果是黄色说明图像做过拉伸处理，如果在 tableView 快速滚动中，附加操作越多，性能越差<br>
使用如上方法不仅可以裁切圆角头像，同时解决了 800***800 设置在 200*200 的 ImageView 上会拉伸的问题<br>
此举可以帮助 tableView 提升一部分性能</p>
]]></content:encoded>
      <enclosure url="http://upload-images.jianshu.io/upload_images/2076247-98a0c6450c69fa62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" type="image/"/>
    </item>
    <item>
      <title>textfield限制输入字符</title>
      <link>https://oragekk.me/posts/iOS/ui/textfiled%E9%99%90%E5%88%B6%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6.html</link>
      <guid>https://oragekk.me/posts/iOS/ui/textfiled%E9%99%90%E5%88%B6%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6.html</guid>
      <source url="https://oragekk.me/rss.xml">textfield限制输入字符</source>
      <description>记录一下限制输入字符的判断。不仅局限于中文或英文 首先在 ViewDidLoad 中注册通知 [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(textFieldEditChanged:) 	name:@&amp;quot;UITextFieldTextDidChangeNotification&amp;quot; object:self.userTF];</description>
      <category>iOS</category>
      <pubDate>Sun, 21 May 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>记录一下限制输入字符的判断。不仅局限于中文或英文</p>
</blockquote>
<ul>
<li>首先在 ViewDidLoad 中注册通知</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>下面是判断逻辑 由于需求有中文键盘下的字母数字输入，所以其中那部分判断如不需要可以去除</li>
</ul>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>iOS timelineLogistics</title>
      <link>https://oragekk.me/posts/iOS/ui/timelineLogistics.html</link>
      <guid>https://oragekk.me/posts/iOS/ui/timelineLogistics.html</guid>
      <source url="https://oragekk.me/rss.xml">iOS timelineLogistics</source>
      <description>timelineLogistics 是模仿淘宝物流信息时间轴界面的自定义 View 效果 Markdown 使用正则表达式判断字符是否为电话号码，用 YYLable 进行富文本电话拨打</description>
      <category>iOS</category>
      <pubDate>Wed, 12 Jul 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><strong>timelineLogistics</strong> 是模仿淘宝物流信息时间轴界面的自定义 View</p>
</blockquote>
<h2> 效果</h2>
<figure><img src="http://i4.piimg.com/1949/af2a87e889d29664.png" alt="Markdown" tabindex="0" loading="lazy"><figcaption>Markdown</figcaption></figure>
<blockquote>
<p>使用正则表达式判断字符是否为电话号码，用 YYLable 进行富文本电话拨打</p>
</blockquote>
<h2> 使用</h2>
<ul>
<li>
<p>引入 Masonry,YYkit 库</p>
<ul>
<li>使用了 MAsonry 进行布局</li>
<li>使用了 YYkit 中的 YYLable 进行富文本电话号码点击拨打电话</li>
</ul>
</li>
<li>
<p>初始化数组</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<ul>
<li>
<p>转为模型</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>初始化控制器</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<blockquote>
<p><a href="https://github.com/OrageKK/timelineLogistics" target="_blank" rel="noopener noreferrer">Demo下载</a>,如果对你有帮助麻烦点个Star</p>
</blockquote>
]]></content:encoded>
      <enclosure url="http://i4.piimg.com/1949/af2a87e889d29664.png" type="image/png"/>
    </item>
    <item>
      <title>优雅的实现TableViewCell单选</title>
      <link>https://oragekk.me/posts/iOS/ui/%E4%BC%98%E9%9B%85%E7%9A%84cell%E5%8D%95%E9%80%89.html</link>
      <guid>https://oragekk.me/posts/iOS/ui/%E4%BC%98%E9%9B%85%E7%9A%84cell%E5%8D%95%E9%80%89.html</guid>
      <source url="https://oragekk.me/rss.xml">优雅的实现TableViewCell单选</source>
      <description>最近有些忙，好久没有写博客了。 分享一个 cell 做单选的思路 可行的思路 在 tableview 的控制器中设立一个变量记录选择的 indexPath，点击 cell 之后刷新表格来和现有 indexPath 对比 和第一种大同小异，做一个和 dataArr 同样的数组，记录 indexPath，循环确定当前 cell 是否为选中 cell 利用 cell 的- (void)setSelected:(BOOL)selected animated:(BOOL)animated方法</description>
      <category>iOS</category>
      <pubDate>Fri, 12 Jan 2018 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>最近有些忙，好久没有写博客了。<br>
分享一个 cell 做单选的思路</p>
</blockquote>
<h2> 可行的思路</h2>
<ol>
<li>在 tableview 的控制器中设立一个变量记录选择的 indexPath，点击 cell 之后刷新表格来和现有 indexPath 对比</li>
<li>和第一种大同小异，做一个和 dataArr 同样的数组，记录 indexPath，循环确定当前 cell 是否为选中 cell</li>
<li>利用 cell 的<code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated</code>方法</li>
</ol>
<h2> 利弊分析</h2>
<ol>
<li>前两种，都需要在<code>didSelectRowAtIndexPath</code>方法中来刷新表格，可能会造成不必要的滑动，而且需要单独的外在属性来记录这个选择</li>
<li>第三种方法是我要介绍的，不用任何外在属性，不用变量，不用数组。实现 cell、或 cell 中 Button 的单选。并且不会因为复用而造成位置错乱，如果要实现 cell 的多选可以参考我之前的文章<a href="http://oragekk.me/02-13-2017/cell%E5%A4%8D%E7%94%A8-accessoryType%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html" target="_blank" rel="noopener noreferrer">Cell 的 accessoryType 属性标记单元格之后，出现的重用问题</a></li>
</ol>
<h2> 实现方式</h2>
<ol>
<li>
<p>如果要有默认选择在初始化 tableView 完成后写</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>然后在 cell 中实现<code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated</code>方法</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>在<code>didSelectRowAtIndexPath</code>方法中给点击的 cell 手动选中，并不需要刷新表格</p>
<div class="language-objc line-numbers-mode" data-ext="objc"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
<blockquote>
<p>至此结束，可以看一下效果<br>
<img src="https://storage4.cuntuku.com/2018/01/13/dvITJ.gif" alt="效果图.md.gif" loading="lazy"></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://storage4.cuntuku.com/2018/01/13/dvITJ.gif" type="image/gif"/>
    </item>
    <item>
      <title>更优雅强大的终端ZSH</title>
      <link>https://oragekk.me/posts/Linux/zsh.html</link>
      <guid>https://oragekk.me/posts/Linux/zsh.html</guid>
      <source url="https://oragekk.me/rss.xml">更优雅强大的终端ZSH</source>
      <description>MacOS 自带的 bash 作为几乎所有 Linux 发行版的默认终端，正常使用时没什么问题的 这里介绍一个更强大的终端神器 目录 背景介绍 在 unix 内核的操作系统中,当然现在衍生出好多分支,linux ,OS X 都算. shell 就算和上面这些系统内核指令打交道的一座桥梁,我们通过键盘输入一种自己容易记忆识别的符号标识(shell 命令) 然后 shell 解析这种命令再反馈给内核去执行一系列操作. zsh 和 shell 有什么关系呢?</description>
      <category>Linux</category>
      <pubDate>Wed, 24 Jul 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>MacOS 自带的 bash 作为几乎所有 Linux 发行版的默认终端，正常使用时没什么问题的</p>
<p>这里介绍一个更强大的终端神器</p>
</blockquote>
<h2> 目录</h2>

<h2> 背景介绍</h2>
<p>在 unix 内核的操作系统中,当然现在衍生出好多分支,linux ,OS X 都算.</p>
<p>shell 就算和上面这些系统内核指令打交道的一座桥梁,我们通过键盘输入一种自己容易记忆识别的符号标识(shell 命令)</p>
<p>然后 shell 解析这种命令再反馈给内核去执行一系列操作.</p>
<p>zsh 和 shell 有什么关系呢?</p>
<p>其实 zsh 也是一种 shell ,但是并不是我们系统默认的 shell ,unix 衍生系统的默认 shell 都是 bash。</p>
<p>查看已安装 shell<br>
查看 Mac 上已有的 shell,一共有 6 种</p>
<hr>
<p><code>cat /etc/shells</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 安装 <strong>oh my zsh</strong></h2>

<p>安装成功：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装完成以后，默认<code>Shell</code>的<code>~/.bashrc</code>文件默认不再加载了，替代的是<code>~/.zlogin</code>和<code>~/.zshrc</code>。所以如果你在<code>~/.bashrc</code>里配置了某些设置，需要把她们复制到<code>~/.zshrc</code>中。</p>
<p>在<code>~/.zshrc</code> 中添加以下行</p>
<p><code>source ~/.bash_profile</code></p>
<h4> 切换终端为 zsh</h4>
<p><code>chsh -s /bin/zsh</code></p>
<h4> oh my zsh 目录结构</h4>
<p>进入<code>~/.oh-my-zsh</code>目录后，看看该目录的结构</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>lib 提供了核心功能的脚本库</li>
<li>tools 提供安装、升级等功能的快捷工具</li>
<li>plugins 自带插件的存在放位置</li>
<li>templates 自带模板的存在放位置</li>
<li>themes 自带主题文件的存在放位置</li>
<li>custom 个性化配置目录，自安装的插件和主题可放这里</li>
</ul>
<h3> 配置</h3>
<p><code>zsh</code> 的配置主要集中在<code>~/.zshrc</code>里，用 <code>vim</code> 或你喜欢的其他编辑器打开<code>.zshrc</code>。</p>
<p>可以在此处定义自己的环境变量和别名，当然，<code>oh my zsh</code> 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</p>
<h4> 别名设置：</h4>
<p><code>zsh</code>不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</p>
<ul>
<li><code>alias -s html=vi</code>，意思就是你在命令行输入 <code>hello.html</code>，<code>zsh</code>会为你自动打开<code>vim</code>并读取<code>hello.html</code>；</li>
<li><code>alias -s gz='tar -xzvf'</code>，表示自动解压后缀为<code>gz</code>的压缩包。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【其他】</p>
<ul>
<li><a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener noreferrer">github zsh 主题参考</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_71539d240101fh8s.html" target="_blank" rel="noopener noreferrer">自定义 zsh 提示符</a></li>
</ul>
<h4> 主题设置：</h4>
<p><code>oh my zsh</code> 提供了数十种主题，相关文件在<code>~/.oh-my-zsh/themes</code>目录下，你可以自己选择，也可以自己编写主题。</p>
<p>在<code>.zshrc</code>里找到<code>ZSH_THEME</code>，就可以设置主题了，默认主题是：<code>ZSH_THEME=”robbyrussell”</code></p>
<p><code>ZSH_THEME="random"</code>，主题设置为随机，这样我们每打开一个窗口，都会随机在默认主题中选择一个。</p>
<h4> 插件设置：</h4>
<p><code>oh my zsh</code>项目提供了完善的插件体系，相关的文件在<code>~/.oh-my-zsh/plugins</code>目录下，默认提供了 100 多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 <code>zsh</code> 文件看一下就知道了。插件也是在<code>.zshrc</code>里配置，找到<code>plugins</code>关键字，你就可以加载自己的插件了，系统默认加载<code>git</code>，你可以在后面追加内容，如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> 安装 <code>zsh-autosuggestions</code></h5>
<p>autosuggestions 它是 Oh-myszh 的一个插件，作用基本上是根据历史输入指令的记录即时的提示，能够很大的提高效率</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加至 <code>plugins</code></p>
<h5> 安装 <code>zsh-syntax-highlighting</code></h5>
<p>代码高亮插件可以让终端颜色更加绚丽</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>添加至 <code>plugins</code></p>
<p><code>plugins=(zsh-autosuggestions git zsh-syntax-highlighting)</code></p>
<h2> 效果图</h2>
<figure><a href="https://imgchr.com/i/MarNhq" target="_blank" rel="noopener noreferrer"><img src="https://s2.ax1x.com/2019/11/15/MarNhq.md.png" alt="MarNhq.md.png" tabindex="0" loading="lazy"></a><figcaption>MarNhq.md.png</figcaption></figure>
<h3> 卸载 oh my zsh</h3>
<p>直接在终端中，运行<code>uninstall_oh_my_zsh</code>既可以卸载。</p>
]]></content:encoded>
      <enclosure url="https://s2.ax1x.com/2019/11/15/MarNhq.md.png" type="image/png"/>
    </item>
    <item>
      <title>关于本站</title>
      <link>https://oragekk.me/about.html</link>
      <guid>https://oragekk.me/about.html</guid>
      <source url="https://oragekk.me/rss.xml">关于本站</source>
      <description>关于本站 ✨📒 详细记录一下此次建站过程 开始 之前的博客是基于jekyll打造的，要添加和定制化的东西都只能基于html+js+css完成，有些麻烦，所以一直有想更换引擎的想法 直到偶然间发现vuepress，首先是被vue3+typescript+vite吸引，然后看到默认主题属实有点不合符我的期待，自己动手成本又太高，也没有太急着去折腾，直到无意中发现了 vuepress-theme-hope，漂亮的外观一下子就吸引到我了，然后去官网深入研究了一番，发现二次开发的成本并不高，对于我来说比较友好，基本都是基于选项的配置型，和一小部分的定制开发，也可以基于vue来写，这让我觉得很合适。所以，一步步折腾了起来……</description>
      <category>Blog</category>
      <pubDate>Tue, 14 Mar 2023 21:45:45 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 关于本站</h1>
<div class="hint-container info">
<p class="hint-container-title">✨📒</p>
<p>详细记录一下此次建站过程</p>
</div>
<h2> 开始</h2>
<p>之前的博客是基于jekyll打造的，要添加和定制化的东西都只能基于html+js+css完成，有些麻烦，所以一直有想更换引擎的想法<br>
直到偶然间发现vuepress，首先是被<code>vue3</code>+<code>typescript</code>+<code>vite</code>吸引，然后看到默认主题属实有点不合符我的期待，自己动手成本又太高，也没有太急着去折腾，直到无意中发现了<br>
<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>，漂亮的外观一下子就吸引到我了，然后去官网深入研究了一番，发现二次开发的成本并不高，对于我来说比较友好，基本都是基于选项的配置型，和一小部分的定制开发，也可以基于vue来写，这让我觉得很合适。所以，一步步折腾了起来……</p>
<h2> Markdown增强</h2>
<p>hope主题的markdown效果是出乎意料的好，而且支持了很多普通markdown不支持的东西，如自定义容器、带tab的代码块，最方便的是可以直接写流程图了，可选高亮主题（本站代码高亮基于shikiPlugin,虽不如默认的prismjs轻量高效，但能提供更准确的语法高亮）具体效果看这里☞<a href="/demo/markdown.html" target="blank">Markdown展示</a></p>
<h2> 目录结构</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 框架支持</h2>
<p><a href="https://v2.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">vuepress2.x</a></p>
<h2> 主题支持</h2>
<p><a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a></p>
<h2> 自定义内容</h2>
<p>基于原主题进行了继承，个性化内容如下，主要自定义内容分为</p>
<ol>
<li>
<p><strong>自定义布局</strong></p>
<ul>
<li>NotFound.vue</li>
<li>Layout.vue(增加打赏组件)</li>
<li>News.vue(说说列表布局)</li>
</ul>
</li>
<li>
<p><strong>自定义组件</strong></p>
<ul>
<li>BlogHero.vue</li>
<li>PageFooter.vue</li>
<li>Sponsor.vue（打赏组件）</li>
<li>NewsList.vue （说说列表）</li>
<li>NewsItem.vue （说说item）</li>
</ul>
</li>
<li>
<p><strong>本地插件开发</strong></p>
<ul>
<li>vuepress-plugin-canvas（支持彩虹背景和动态几何图形两种）</li>
<li>vuepress-plugin-gradient-cover （遮罩背景）</li>
<li>vuepress-plugin-hitokoto （一言插件）</li>
<li>vuepress-plugin-live2DAssist （看板娘辅助，由于子页有sidebar，看板娘会挡住，所以写了一个子页隐藏的小东西）</li>
<li>vuepress-plugin-popper （鼠标特效，基于<a href="https://github.com/moefyit/moefy-canvas" target="_blank" rel="noopener noreferrer">@moefy-canvas/theme-popper</a>）</li>
</ul>
</li>
<li>
<p><strong>引用外部内容</strong></p>
<ul>
<li>
<p><a href="https://github.com/oh-my-live2d/vuepress-plugin-oh-my-live2d" target="_blank" rel="noopener noreferrer">vuepress-plugin-oh-my-live2d</a> 看板娘插件</p>
</li>
<li>
<p>不蒜子统计</p>
</li>
<li>
<p><a href="https://github.com/moefyit/moefy-canvas" target="_blank" rel="noopener noreferrer">@moefy-canvas/theme-popper</a>原有插件只支持vuepress1.x，自己基于moefy-canvas进行了支持vuepress2.x的本地化插件开发</p>
</li>
<li>
<p><a href="https://v2.vuepress.vuejs.org/zh/reference/plugin/google-analytics.html" target="_blank" rel="noopener noreferrer">@vuepress/plugin-google-analytics</a> 支持Google Analytics 4 正好看到通知原来的UA也要被强制转换了，所以更换了G4</p>
</li>
</ul>
</li>
<li>
<p><strong>配置内容</strong></p>
<ul>
<li>navbar</li>
<li>sidebar</li>
<li>评论基于 <a href="https://waline.js.org/" target="_blank" rel="noopener noreferrer">Waline</a></li>
<li>搜索基于<a href="https://www.algolia.com/developers/?utm_content=powered_by&amp;utm_source=localhost&amp;utm_medium=referral&amp;utm_campaign=docsearch" target="_blank" rel="noopener noreferrer">algolia</a></li>
<li>启用 copyright 版权信息插件</li>
<li>feed rss插件</li>
<li>增加文章类型-说说，为说说markdown图片添加预览选择器</li>
</ul>
</li>
<li>
<p><strong>零碎</strong></p>
<ul>
<li>运行时间统计</li>
<li>CSS 样式美化</li>
<li>引入字体，品如手写体，夏行楷体</li>
<li>wanlie 增加自定义emoji，并修改展示样式</li>
<li>个性log</li>
<li>自动推送新文章url到搜索引擎（百度、Bing、Google）👉<a href="/platform/github/github-action">详细配置</a></li>
</ul>
</li>
</ol>
<h2> 总结</h2>
<blockquote>
<p>未完待续，持续优化中</p>
</blockquote>
<p>本地插件，喜欢自取，源码公开，点击右上角，github图标即可，当然不要忘记点个✨哦</p>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://oragekk.me/intro.html</link>
      <guid>https://oragekk.me/intro.html</guid>
      <source url="https://oragekk.me/rss.xml">关于我</source>
      <description>关于我 Profile Exploration &amp;amp; geek enthusiast, full-stack front-end engineer, UX Designer | Currently focusing on cross-platform development with main directions in iOS, ReactNative, Flutter, and Vue | Discovering a bigger world together with you. Profile 探索 &amp;amp; 极客 爱好者，大前端工程师，用户体验设计师 |目前主要研究方向在跨平台开发上，iOS、ReactNative、Flutter、Vue是主要方向| 期待与你一起发现更大的世界</description>
      <category>About</category>
      <pubDate>Sun, 12 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 关于我</h1>

<h2> Profile</h2>
<p><em>Exploration &amp; geek enthusiast, full-stack front-end engineer, UX Designer | Currently focusing on cross-platform development with main directions in iOS, ReactNative, Flutter, and Vue | Discovering a bigger world together with you.</em></p>
<div class="hint-container tip">
<p class="hint-container-title">Profile</p>
<p>探索 &amp; 极客 爱好者，大前端工程师，用户体验设计师 |目前主要研究方向在跨平台开发上，iOS、ReactNative、Flutter、Vue是主要方向| 期待与你一起发现更大的世界</p>
</div>
<h2> Skills</h2>
<h3> Languages</h3>
<img src="https://skillicons.dev/icons?i=c,cs,swift,javascript,ts,dart,python,html,css,java,regex,md,sass,bash&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Frameworks</h3>
<img src="https://skillicons.dev/icons?i=flutter,vue,nodejs,react,reactivex,redux,dotnet&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Databases</h3>
<img src="https://skillicons.dev/icons?i=sqlite,mysql,redis&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Hardwares</h3>
<img src="https://skillicons.dev/icons?i=raspberrypi&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h3> Others</h3>
<img src="https://skillicons.dev/icons?i=vim,visualstudio,vscode,androidstudio,aws,figma,gradle,gcp,git,github,gitlab,idea,jenkins,linux,postman,powershell,linkedin,stackoverflow,svg,tensorflow,twitter&amp;theme=dark&amp;&amp;perline=10" alt="Skills">
<h2> Github Summary</h2>
<img src="https://github-trophies.vercel.app/?username=oragekk&amp;theme=radical&amp;margin-w=25" alt="Github Summary">
<img src="https://github-readme-stats.vercel.app/api/top-langs/?username=oragekk&amp;theme=radical&amp;layout=compact&amp;bg_color=30,ef475d,904e95&amp;title_color=fff&amp;text_color=fff">
<img src="https://github-readme-stats.vercel.app/api?username=oragekk&amp;count_private=true&amp;show_icons=true&amp;theme=radical&amp;bg_color=30,ef475d,904e95&amp;title_color=fff&amp;text_color=fff">
<h2> Preview</h2>
<figure><img src="https://count.getloli.com/get/@:oragekk?theme=gelbooru-h" alt=":Augenestern-creator" tabindex="0" loading="lazy"><figcaption>:Augenestern-creator</figcaption></figure>
<h2> Activity Graph</h2>
<figure><a href="https://github.com/OrageKK/github-readme-activity-graph" target="_blank" rel="noopener noreferrer"><img src="https://github-readme-activity-graph-sandy.vercel.app/graph?username=oragekk&amp;theme=dracula" alt="Ashutosh's github activity graph" tabindex="0" loading="lazy"></a><figcaption>Ashutosh's github activity graph</figcaption></figure>
<h2> 关于本站</h2>
<p><a href="/about">传送门</a></p>
]]></content:encoded>
      <enclosure url="https://count.getloli.com/get/@:oragekk?theme=gelbooru-h" type="image/"/>
    </item>
    <item>
      <title>Markdown 展示</title>
      <link>https://oragekk.me/demo/markdown.html</link>
      <guid>https://oragekk.me/demo/markdown.html</guid>
      <source url="https://oragekk.me/rss.xml">Markdown 展示</source>
      <description>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。 你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</description>
      <category>使用指南</category>
      <pubDate>Sat, 11 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。</p>
<p>你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</p>
<!-- more -->
<h2> Markdown 介绍</h2>
<p>如果你是一个新手，还不会编写 Markdown，请先阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/" target="_blank" rel="noopener noreferrer">Markdown 介绍</a> 和 <a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/demo.html" target="_blank" rel="noopener noreferrer">Markdown 演示</a>。</p>
<h2> Markdown 配置</h2>
<p>VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/page.html#front-matter" target="_blank" rel="noopener noreferrer">Frontmatter 介绍</a>。</p>
</div>
<h2> Markdown 扩展</h2>
<p>VuePress 会使用 <a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener noreferrer">markdown-it</a> 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 <a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener noreferrer">语法扩展</a> 。</p>
<h3> VuePress 扩展</h3>
<p>为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。</p>
<p>关于这些扩展，请阅读 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html" target="_blank" rel="noopener noreferrer">VuePress 中的 Markdown 扩展</a>。</p>
<h3> 主题扩展</h3>
<p>通过 <a href="https://md-enhance.vuejs.press/zh/" target="_blank" rel="noopener noreferrer"><code>vuepress-plugin-md-enhance</code></a>，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。</p>
<h4> 自定义容器</h4>
<div v-pre="">
<p>安全的在 Markdown 中使用 {{ variable }}。</p>
</div>
<div class="hint-container info">
<p class="hint-container-title">自定义标题</p>
<p>信息容器，包含 <code>代码</code> 与 <a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8">链接</a>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<div class="hint-container tip">
<p class="hint-container-title">自定义标题</p>
<p>提示容器</p>
</div>
<div class="hint-container warning">
<p class="hint-container-title">自定义标题</p>
<p>警告容器</p>
</div>
<div class="hint-container danger">
<p class="hint-container-title">自定义标题</p>
<p>危险容器</p>
</div>
<details class="hint-container details"><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/container.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 代码块</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/code-tabs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 上下角标</h4>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/sup-sub.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 自定义对齐</h4>
<div style="text-align:center">
<p>我是居中的</p>
</div>
<div style="text-align:right">
<p>我在右对齐</p>
</div>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/align.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Attrs</h4>
<p>一个拥有 ID 的 <strong id="word">单词</strong>。</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/attrs.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 脚注</h4>
<p>此文字有脚注<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">.</a></p><a class="footnote-anchor" id="footnote-ref1">
</a><ul><a class="footnote-anchor" id="footnote-ref1">
</a><li><a class="footnote-anchor" id="footnote-ref1"></a><a href="https://theme-hope.vuejs.press/zh/guide/markdown/footnote.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 标记</h4>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/mark.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 任务列表</h4>
<ul class="task-list-container">
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 计划 1</label></p>
</li>
<li class="task-list-item">
<p><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 计划 2</label></p>
</li>
<li>
<p><a href="https://theme-hope.vuejs.press/zh/guide/markdown/tasklist.html" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
</ul>
<h3> 图片增强</h3>
<p>支持为图片设置颜色模式和大小</p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/image.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 图表</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/chart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Echarts</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/echarts.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 流程图</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/flowchart.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Mermaid</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/mermaid.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Tex 语法</h4>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><msup><mi mathvariant="normal">∂</mi><mi>r</mi></msup><mrow><mi mathvariant="normal">∂</mi><msup><mi>ω</mi><mi>r</mi></msup></mrow></mfrac><mrow><mo fence="true">(</mo><mfrac><msup><mi>y</mi><mi>ω</mi></msup><mi>ω</mi></mfrac><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mfrac><msup><mi>y</mi><mi>ω</mi></msup><mi>ω</mi></mfrac><mo fence="true">)</mo></mrow><mrow><mo fence="true">{</mo><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>i</mi></msup><mi>r</mi><mo>⋯</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>y</mi><msup><mo stretchy="false">)</mo><mrow><mi>r</mi><mo>−</mo><mi>i</mi></mrow></msup></mrow><msup><mi>ω</mi><mi>i</mi></msup></mfrac><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">
\frac {\partial^r} {\partial \omega^r} \left(\frac {y^{\omega}} {\omega}\right)
= \left(\frac {y^{\omega}} {\omega}\right) \left\{(\log y)^r + \sum_{i=1}^r \frac {(-1)^i r \cdots (r-i+1) (\log y)^{r-i}} {\omega^i} \right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3414em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0277em;vertical-align:-1.2777em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3414em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5017em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">}</span></span></span></span></span></span></span></p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/tex.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 导入文件</h4>
<ul>
<li>
<p><a href="/demo/markdown.html" target="blank">Markdown 展示</a></p>
</li>
<li>
<p><a href="/demo/page.html" target="blank">页面展示</a></p>
</li>
<li>
<p><a href="/demo/disable.html" target="blank">禁用展示</a></p>
</li>
</ul>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/include.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 代码演示</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/demo.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 样式化</h4>
<p>向 Mr.Hope 捐赠一杯咖啡。 </p>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/stylize.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 交互演示</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/playground.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> Vue 交互演示</h4>

<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/vue-playground.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h4> 幻灯片</h4>
<ul>
<li><a href="https://theme-hope.vuejs.press/zh/guide/markdown/presentation.html" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>这是脚注内容 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
  </channel>
</rss>